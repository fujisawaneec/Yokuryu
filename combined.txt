### ðŸŒ³ Codebase File Tree (Excluding ignored directories)

â”œâ”€â”€ CG2_DirectXGame.vcxproj
â”œâ”€â”€ CG2_DirectXGame.vcxproj.filters
â”œâ”€â”€ Resources/
â””â”€â”€ â”œâ”€â”€ No_Eyed_Dragon_v2_by_Dommk/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ model/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ textures/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ special_shaded/
â””â”€â”€ â”œâ”€â”€ Toothless2.0/
â””â”€â”€ â”œâ”€â”€ block01/
â””â”€â”€ â”œâ”€â”€ block02/
â””â”€â”€ â”œâ”€â”€ boneTest/
â””â”€â”€ â”œâ”€â”€ box/
â””â”€â”€ â”œâ”€â”€ csv/
â””â”€â”€ â”œâ”€â”€ cube/
â””â”€â”€ â”œâ”€â”€ fighter/
â””â”€â”€ â”œâ”€â”€ ironSphere/
â””â”€â”€ â”œâ”€â”€ levels/
â””â”€â”€ â”œâ”€â”€ panel/
â””â”€â”€ â”œâ”€â”€ sea/
â””â”€â”€ â”œâ”€â”€ shaders/
â””â”€â”€ â”œâ”€â”€ sky/
â””â”€â”€ â”œâ”€â”€ stone/
â””â”€â”€ â”œâ”€â”€ triangle_mat/
â”œâ”€â”€ app/
â””â”€â”€ â”œâ”€â”€ platform/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ Framework.h
â””â”€â”€ â””â”€â”€ scene/
â””â”€â”€     â”œâ”€â”€ BaseScene.cpp
â””â”€â”€     â””â”€â”€ BaseScene.h
â”œâ”€â”€ engine/
â””â”€â”€ â”œâ”€â”€ 2d/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ Sprite.h
â””â”€â”€ â”œâ”€â”€ 3d/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Boss.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Boss.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossBullet.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BossBullet.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBullet.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBullet.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Energy.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Energy.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxLoader.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxLoader.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxModel.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxModel.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxObject3d.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FbxObject3d.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3d.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3d.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayerBullet.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayerBullet.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RailCamera.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RailCamera.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ViewProjection.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ViewProjection.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WorldTransform.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WorldTransform.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ XMViewProjection.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ XMViewProjection.h
â””â”€â”€ â”œâ”€â”€ base/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FPSFixed.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FPSFixed.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ JsonLoader.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ JsonLoader.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WinApp.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ WinApp.h
â””â”€â”€ â”œâ”€â”€ collision/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseCollider.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionInfo.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionPrimitive.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionPrimitive.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionTypes.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RaycastHit.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SphereCollider.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ SphereCollider.h
â””â”€â”€ â”œâ”€â”€ effect/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PostEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ PostEffect.h
â””â”€â”€ â”œâ”€â”€ math/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix4.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix4.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Spline.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Spline.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector2.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector2.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector3.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector3.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector4.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ Vector4.h
â””â”€â”€ â””â”€â”€ scene/
â””â”€â”€     â”œâ”€â”€ AbstractSceneFactory.h
â””â”€â”€     â”œâ”€â”€ Game.cpp
â””â”€â”€     â”œâ”€â”€ Game.h
â””â”€â”€     â”œâ”€â”€ GameBaseScene.cpp
â””â”€â”€     â”œâ”€â”€ GameBaseScene.h
â””â”€â”€     â”œâ”€â”€ GameClearScene.cpp
â””â”€â”€     â”œâ”€â”€ GameClearScene.h
â””â”€â”€     â”œâ”€â”€ GameOverScene.cpp
â””â”€â”€     â”œâ”€â”€ GameOverScene.h
â””â”€â”€     â”œâ”€â”€ GameScene.cpp
â””â”€â”€     â”œâ”€â”€ GameScene.h
â””â”€â”€     â”œâ”€â”€ GameSceneManager.cpp
â””â”€â”€     â”œâ”€â”€ GameSceneManager.h
â””â”€â”€     â”œâ”€â”€ GameTitleScene.cpp
â””â”€â”€     â”œâ”€â”€ GameTitleScene.h
â””â”€â”€     â”œâ”€â”€ SIFrameWork.cpp
â””â”€â”€     â”œâ”€â”€ SIFrameWork.h
â””â”€â”€     â”œâ”€â”€ SceneFactory.cpp
â””â”€â”€     â””â”€â”€ SceneFactory.h
â””â”€â”€ main.cpp
================================================================================


============================================================
File Path: CG2_DirectXGame.vcxproj
============================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e2b32998-cddf-4587-aac4-cfebbfbd82fd}</ProjectGuid>
    <RootNamespace>CG2DirectXGame</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir)engine\external\DirectXTex\include;$(ProjectDir)engine\external\fbx_sdk\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)engine\external\fbx_sdk\lib\Debug;$(ProjectDir)engine\external\DirectXTex\lib\Debug;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\Generated\Obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\Generated\Output\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)engine\external\DirectXTex\include;$(ProjectDir)engine\external\fbx_sdk\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)engine\external\fbx_sdk\lib\Release;$(ProjectDir)engine\external\DirectXTex\lib\Release;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\Generated\Obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\Generated\Output\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)app\scene;$(ProjectDir)app\platform;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\base;$(ProjectDir)engine\effect;$(ProjectDir)engine\math;$(ProjectDir)engine\collision;$(ProjectDir)engine\scene</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-md.lib;libxml2-md.lib;zlib-md.lib;DirectXTex.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_ITERATOR_DEBUG_LEVEL=2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)app\scene;$(ProjectDir)app\platform;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\base;$(ProjectDir)engine\effect;$(ProjectDir)engine\math;$(ProjectDir)engine\collision;$(ProjectDir)engine\scene</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <UndefineAllPreprocessorDefinitions>false</UndefineAllPreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>libfbxsdk-md.lib;libxml2-md.lib;zlib-md.lib;DirectXTex.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="app\platform\Framework.cpp" />
    <ClCompile Include="app\scene\BaseScene.cpp" />
    <ClCompile Include="engine\3d\Boss.cpp" />
    <ClCompile Include="engine\3d\BossBullet.cpp" />
    <ClCompile Include="engine\3d\Enemy.cpp" />
    <ClCompile Include="engine\3d\EnemyBullet.cpp" />
    <ClCompile Include="engine\3d\Energy.cpp" />
    <ClCompile Include="engine\3d\Player.cpp" />
    <ClCompile Include="engine\3d\PlayerBullet.cpp" />
    <ClCompile Include="engine\3d\RailCamera.cpp" />
    <ClCompile Include="engine\base\DirectXCommon.cpp" />
    <ClCompile Include="engine\base\FPSFixed.cpp" />
    <ClCompile Include="engine\base\Input.cpp" />
    <ClCompile Include="engine\base\JsonLoader.cpp" />
    <ClCompile Include="engine\collision\Collision.cpp" />
    <ClCompile Include="engine\collision\CollisionManager.cpp" />
    <ClCompile Include="engine\collision\CollisionPrimitive.cpp" />
    <ClCompile Include="engine\collision\SphereCollider.cpp" />
    <ClCompile Include="engine\effect\PostEffect.cpp" />
    <ClCompile Include="engine\math\Spline.cpp" />
    <ClCompile Include="engine\scene\Game.cpp" />
    <ClCompile Include="engine\scene\GameBaseScene.cpp" />
    <ClCompile Include="engine\scene\GameClearScene.cpp" />
    <ClCompile Include="engine\scene\GameOverScene.cpp" />
    <ClCompile Include="engine\scene\GameSceneManager.cpp" />
    <ClCompile Include="engine\scene\GameTitleScene.cpp" />
    <ClCompile Include="engine\scene\SceneFactory.cpp" />
    <ClCompile Include="engine\scene\SIFrameWork.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="engine\math\Matrix4.cpp" />
    <ClCompile Include="engine\3d\Model.cpp" />
    <ClCompile Include="engine\3d\Object3d.cpp" />
    <ClCompile Include="engine\effect\Particle.cpp" />
    <ClCompile Include="engine\effect\ParticleManager.cpp" />
    <ClCompile Include="engine\2d\Sprite.cpp" />
    <ClCompile Include="engine\math\Vector2.cpp" />
    <ClCompile Include="engine\math\Vector3.cpp" />
    <ClCompile Include="engine\math\Vector4.cpp" />
    <ClCompile Include="engine\3d\ViewProjection.cpp" />
    <ClCompile Include="engine\base\WinApp.cpp" />
    <ClCompile Include="engine\scene\GameScene.cpp" />
    <ClCompile Include="engine\3d\WorldTransform.cpp" />
    <ClCompile Include="engine\3d\XMViewProjection.cpp" />
    <ClCompile Include="engine\3d\FbxLoader.cpp" />
    <ClCompile Include="engine\3d\FbxModel.cpp" />
    <ClCompile Include="engine\3d\FbxObject3d.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\shaders\Basic.hlsli" />
    <None Include="Resources\shaders\FBX.hlsli" />
    <None Include="Resources\shaders\OBJ.hlsli" />
    <None Include="Resources\shaders\Particle.hlsli" />
    <None Include="Resources\shaders\PostEffect.hlsli" />
    <None Include="Resources\shaders\Sprite.hlsli" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\BasicPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\BasicVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXPS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXVS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleGS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Geometry</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Geometry</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Geometry</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticlePS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpritePS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpriteVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="app\platform\Framework.h" />
    <ClInclude Include="app\scene\BaseScene.h" />
    <ClInclude Include="engine\3d\Boss.h" />
    <ClInclude Include="engine\3d\BossBullet.h" />
    <ClInclude Include="engine\3d\Enemy.h" />
    <ClInclude Include="engine\3d\EnemyBullet.h" />
    <ClInclude Include="engine\3d\Energy.h" />
    <ClInclude Include="engine\3d\Player.h" />
    <ClInclude Include="engine\3d\PlayerBullet.h" />
    <ClInclude Include="engine\3d\RailCamera.h" />
    <ClInclude Include="engine\base\DirectXCommon.h" />
    <ClInclude Include="engine\base\FPSFixed.h" />
    <ClInclude Include="engine\base\Input.h" />
    <ClInclude Include="engine\base\json.hpp" />
    <ClInclude Include="engine\base\JsonLoader.h" />
    <ClInclude Include="engine\collision\BaseCollider.h" />
    <ClInclude Include="engine\collision\Collision.h" />
    <ClInclude Include="engine\collision\CollisionInfo.h" />
    <ClInclude Include="engine\collision\CollisionManager.h" />
    <ClInclude Include="engine\collision\CollisionPrimitive.h" />
    <ClInclude Include="engine\collision\CollisionTypes.h" />
    <ClInclude Include="engine\collision\RaycastHit.h" />
    <ClInclude Include="engine\collision\SphereCollider.h" />
    <ClInclude Include="engine\effect\PostEffect.h" />
    <ClInclude Include="engine\math\Matrix4.h" />
    <ClInclude Include="engine\3d\Model.h" />
    <ClInclude Include="engine\3d\Object3d.h" />
    <ClInclude Include="engine\effect\Particle.h" />
    <ClInclude Include="engine\effect\ParticleManager.h" />
    <ClInclude Include="engine\2d\Sprite.h" />
    <ClInclude Include="engine\math\Spline.h" />
    <ClInclude Include="engine\math\Vector2.h" />
    <ClInclude Include="engine\math\Vector3.h" />
    <ClInclude Include="engine\math\Vector4.h" />
    <ClInclude Include="engine\3d\ViewProjection.h" />
    <ClInclude Include="engine\base\WinApp.h" />
    <ClInclude Include="engine\scene\AbstractSceneFactory.h" />
    <ClInclude Include="engine\scene\Game.h" />
    <ClInclude Include="engine\scene\GameBaseScene.h" />
    <ClInclude Include="engine\scene\GameClearScene.h" />
    <ClInclude Include="engine\scene\GameOverScene.h" />
    <ClInclude Include="engine\scene\GameScene.h" />
    <ClInclude Include="engine\3d\WorldTransform.h" />
    <ClInclude Include="engine\3d\XMViewProjection.h" />
    <ClInclude Include="engine\3d\FbxLoader.h" />
    <ClInclude Include="engine\3d\FbxModel.h" />
    <ClInclude Include="engine\3d\FbxObject3d.h" />
    <ClInclude Include="engine\scene\GameSceneManager.h" />
    <ClInclude Include="engine\scene\GameTitleScene.h" />
    <ClInclude Include="engine\scene\SceneFactory.h" />
    <ClInclude Include="engine\scene\SIFrameWork.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: CG2_DirectXGame.vcxproj.filters
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{0ec641aa-dd1b-4500-8535-382c3827c462}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{8af0deee-6556-46f7-99ed-db9664eaec35}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{385839e5-4dc3-4305-b5f9-d2ff99e4d14b}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d">
      <UniqueIdentifier>{fa0a1209-5613-41f4-8336-a1b32e0bb017}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d">
      <UniqueIdentifier>{c9e7a42e-e554-4643-b452-9d37989931a1}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base">
      <UniqueIdentifier>{ef959771-e341-4b66-b050-784b8557adaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math">
      <UniqueIdentifier>{c5ed0df1-7d03-4dcc-9231-f51298ef7b4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene">
      <UniqueIdentifier>{6bef14bd-ffae-4ac6-9aee-6e82cdf7d056}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect">
      <UniqueIdentifier>{436c057a-8f47-423b-8489-b9aceefb13ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform">
      <UniqueIdentifier>{46d387be-bb6f-44f2-acdc-483e1b27f2b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene">
      <UniqueIdentifier>{0554bbb1-90f0-423b-b877-043bcaaa4592}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{2e619881-ee64-4395-9e02-763883744995}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine">
      <UniqueIdentifier>{dbabf37a-58f2-44ee-90e9-abbd314ee416}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math">
      <UniqueIdentifier>{0025325f-b1da-41dc-8b22-11a61d4549fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene">
      <UniqueIdentifier>{5855e325-0d99-4092-bf18-d5326cc03816}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect">
      <UniqueIdentifier>{3285a7bc-7645-4c4c-a945-e02fdeece07d}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base">
      <UniqueIdentifier>{df34dcd6-551e-4994-8c34-9780c07caa06}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d">
      <UniqueIdentifier>{b1febb7f-4466-46af-aa04-d3bf26ecbdbf}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d">
      <UniqueIdentifier>{5138cc02-99cf-4f0f-bdef-c2321640aa1c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform">
      <UniqueIdentifier>{5d923fb2-2d4d-47e6-ac8a-df6b18b95a2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene">
      <UniqueIdentifier>{bcb6b033-1690-4db6-a7a7-f0e436506639}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj">
      <UniqueIdentifier>{db1e4cf1-5bc3-450f-8d25-9e3810865cb0}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj">
      <UniqueIdentifier>{f3046790-de45-420a-9f52-00891842d0ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera">
      <UniqueIdentifier>{d39ca11e-0299-46e3-9634-f3dae2283183}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera">
      <UniqueIdentifier>{564b3b6e-4c8d-4015-879a-b2fe90bba468}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision">
      <UniqueIdentifier>{6d468e4a-84a8-4f43-aa92-3bd8a1d2e728}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision">
      <UniqueIdentifier>{9db64233-bb0d-4897-ba7c-418dd1007c1e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\Sprite.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3d.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Input.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Matrix4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector2.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector3.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\WorldTransform.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Model.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\Particle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\ParticleManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxModel.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxObject3d.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="app\scene\BaseScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene</Filter>
    </ClCompile>
    <ClCompile Include="app\platform\Framework.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Spline.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Player.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\XMViewProjection.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ViewProjection.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\RailCamera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\PlayerBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Enemy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\Collision.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\CollisionManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\CollisionPrimitive.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\SphereCollider.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\WinApp.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\EnemyBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Boss.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\FPSFixed.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\JsonLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\PostEffect.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\BossBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Energy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\Game.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameBaseScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameClearScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameSceneManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameTitleScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SceneFactory.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SIFrameWork.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameOverScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\shaders\Basic.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\Sprite.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\OBJ.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\Particle.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\FBX.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\PostEffect.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\BasicPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\BasicVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpritePS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpriteVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleGS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticlePS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine\2d\Sprite.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Input.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\WinApp.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3d.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Matrix4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Model.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector2.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector3.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\WorldTransform.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\Particle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\ParticleManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxModel.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxObject3d.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="app\platform\Framework.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform</Filter>
    </ClInclude>
    <ClInclude Include="app\scene\BaseScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Spline.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Player.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\XMViewProjection.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ViewProjection.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\RailCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\PlayerBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Enemy.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\BaseCollider.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\Collision.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionInfo.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionPrimitive.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionTypes.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\RaycastHit.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\SphereCollider.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\EnemyBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\FPSFixed.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\JsonLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\json.hpp">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\PostEffect.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\BossBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Boss.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Energy.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\AbstractSceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\Game.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameBaseScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameClearScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameSceneManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameTitleScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SIFrameWork.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameOverScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
  </ItemGroup>
</Project>

============================================================
File Path: app/platform/Framework.cpp
============================================================
#include "Framework.h"

void Framework::Run()
{
	// ï¿½Qï¿½[ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	Initialize();

	while (true) // ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½v 
	{
		// ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Xï¿½V
		Update();

		// ï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½Gï¿½Xï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½çƒ‹ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
		if (IsEndRequest()) {
			// ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
			break;
		}
		if (input->TriggerKey(DIK_ESCAPE)) {
			// ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
			break;
		}

		// ï¿½`ï¿½ï¿½
		Draw();
	}

	// ï¿½Qï¿½[ï¿½ï¿½ï¿½ÌIï¿½ï¿½
	Finalize();
}

void Framework::Initialize()
{
	// WindowsAPIï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	winApp = WinApp::GetInstance();
	winApp->Initialize();

	// DirectXï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	dXCommon = DirectXCommon::GetInstance();
	dXCommon->Initialize(winApp);

	// ï¿½ï¿½ï¿½Í‚Ìï¿½ï¿½ï¿½ï¿½ï¿½
	input = Input::GetInstance();
	input->Initialize(winApp);
	//3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	Object3d::StaticInitialize(dXCommon->GetDevice(), WinApp::window_width, WinApp::window_height);
	// ï¿½rï¿½ï¿½ï¿½[ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	ViewProjection::StaticInitialize(dXCommon->GetDevice());
	// ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	ParticleManager::StaticInitialize(dXCommon->GetDevice());
	//fbxï¿½Ä—pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	FbxLoader::GetInstance()->Initialize(dXCommon->GetDevice());
	//
	FbxObject3d::StaticInitialize(dXCommon->GetDevice());

	postEffect.Initialize(dXCommon->GetDevice());
#pragma endregion ï¿½ï¿½ÕƒVï¿½Xï¿½eï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½

	//ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½
	/*gameScene = new GameScene();*/
	gameScene->Initialize();
}

void Framework::Update()
{
	// Windowsï¿½Ìƒï¿½ï¿½bï¿½Zï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½
	if (winApp->ProcessMessage()) {
		// ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
		endRequest_ = true;
	}
	gameScene->Update();
	// ï¿½ï¿½ï¿½Í‚ÌXï¿½V
	/*input->Update();*/
}

void Framework::Draw()
{
#pragma region ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½`ï¿½ï¿½


#pragma endregion

#pragma region ï¿½`ï¿½ï¿½
	postEffect.PreDrawScene(dXCommon->GetCommandList());
	gameScene->Draw();
	postEffect.PostDrawScene(dXCommon->GetCommandList());
	// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	dXCommon->PreDraw();
	//=== ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½`ï¿½ï¿½ ===//
	postEffect.Draw(dXCommon->GetCommandList());
	// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	dXCommon->PostDraw();
#pragma endregion
}

void Framework::Finalize()
{
	delete gameScene;
	FbxLoader::GetInstance()->Finalize();
	// WindowsAPIï¿½ÌIï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	winApp->Finalize();

	// DirectXï¿½ï¿½ï¿½
	dXCommon->fpsFixedFinalize();
	
}


============================================================
File Path: app/platform/Framework.h
============================================================
#pragma once

#include "Input.h"
#include "WinApp.h"
#include "DirectXCommon.h"
#include "Sprite.h"
#include "Model.h"
#include "Object3d.h"
#include "GameScene.h"
#include "ParticleManager.h"
#include "FbxLoader.h"
#include "FbxObject3d.h"
#include"WinApp.h"
#include"DirectXCommon.h"

#include<windows.h>
#include<cassert>
#include<vector>
#include<string>
#include<d3dcompiler.h>
#include<DirectXMath.h>
#include<dinput.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include "PostEffect.h"

#pragma comment(lib,"d3dcompiler.lib")
#pragma comment(lib,"dxguid.lib")

class Framework
{

public:
	// ï¿½ï¿½ï¿½s
	void Run();

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize();

	// ï¿½Xï¿½V
	void Update();

	// ï¿½Xï¿½V
	void Draw();

	// ï¿½Iï¿½ï¿½
	void Finalize();

public:
	//ï¿½@ï¿½Iï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	bool IsEndRequest() { return endRequest_; }

protected:
	WinApp* winApp = nullptr;
	DirectXCommon* dXCommon = nullptr;
	Input* input = nullptr;
	SpriteCommon spriteCommon;
	GameScene* gameScene = nullptr;
	PostEffect postEffect;
	ParticleManager* particleManager = nullptr;

private:
	// ï¿½Qï¿½[ï¿½ï¿½ï¿½Iï¿½ï¿½ï¿½tï¿½ï¿½ï¿½O
	bool endRequest_ = false;
};


============================================================
File Path: app/scene/BaseScene.cpp
============================================================
#include "BaseScene.h"

//void BaseScene::Initialize()
//{
//	// ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½Xï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
//	Framework::Initialize();
//
//	dXCommon = DirectXCommon::GetInstance();
//
//	// ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½Æï¿½ï¿½ï¿½ï¿½ï¿½
//	scene_ = new GameScene();
//	scene_->Initialize(spriteCommon);
//}
//
//void BaseScene::Update()
//{
//	// ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½Xï¿½ÌXï¿½Vï¿½ï¿½ï¿½ï¿½
//	Framework::Update();
//
//	// ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½ÌXï¿½V
//	scene_->Update();
//
//}
//
//void BaseScene::Draw()
//{
//#pragma region ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½`ï¿½ï¿½
//
//	//=== ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½`ï¿½ï¿½ ===//
//	scene_->Draw();
//
//#pragma endregion
//
//#pragma region ï¿½`ï¿½ï¿½
//	// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
//	dXCommon->PreDraw();
//
//	// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
//	dXCommon->PostDraw();
//#pragma endregion
//}
//
//void BaseScene::Finalize()
//{
//	// ï¿½Qï¿½[ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½Ì‰ï¿½ï¿½
//	delete scene_;
//
//	// ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½Xï¿½ÌIï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
//	Framework::Finalize();
//}


============================================================
File Path: app/scene/BaseScene.h
============================================================
#pragma once

#include "Framework.h"

// ï¿½Qï¿½[ï¿½ï¿½ï¿½Sï¿½ï¿½
class BaseScene
{
//public:
//	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
//	void Initialize() override;
//
//	// ï¿½Xï¿½V
//	void Update() override;
//
//	// ï¿½`ï¿½ï¿½
//	void Draw() override;
//
//	// ï¿½Iï¿½ï¿½
//	void Finalize() override;

};


============================================================
File Path: engine/2d/Sprite.cpp
============================================================
#include "Sprite.h"

Sprite::Sprite() {

}

Sprite::~Sprite() {

}

PipelineSet Sprite::SpriteCreateGraphicsPipeline(ID3D12Device* device) 
{
	HRESULT result;
	ComPtr<ID3DBlob> vsBlob; // ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> psBlob; // ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> errorBlob; // ï¿½Gï¿½ï¿½ï¿½[ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g

	// ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/Shaders/SpriteVS.hlsl", // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "vs_5_0", // ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&vsBlob, &errorBlob);

	// ï¿½Gï¿½ï¿½ï¿½[ï¿½È‚ï¿½
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/Shaders/SpritePS.hlsl",   // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "ps_5_0", // ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&psBlob, &errorBlob);

	// ï¿½Gï¿½ï¿½ï¿½[ï¿½È‚ï¿½
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½g
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyzï¿½ï¿½ï¿½W(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

		{ // uvï¿½ï¿½ï¿½W(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÌÝ’ï¿½
	CD3DX12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

	CD3DX12_ROOT_PARAMETER rootParams[2];
	rootParams[0].InitAsConstantBufferView(0);
	rootParams[1].InitAsDescriptorTable(1, &descriptorRange, D3D12_SHADER_VISIBILITY_ALL);

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½[ï¿½ÌÝ’ï¿½
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //ï¿½ï¿½ï¿½Jï¿½ï¿½Ô‚ï¿½ï¿½iï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½j
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //ï¿½cï¿½Jï¿½ï¿½Ô‚ï¿½ï¿½iï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½j
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //ï¿½ï¿½ï¿½sï¿½Jï¿½ï¿½Ô‚ï¿½ï¿½iï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½j
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK; //ï¿½{ï¿½[ï¿½_ï¿½[ï¿½ÌŽï¿½ï¿½Íï¿½
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; //ï¿½Sï¿½Äƒï¿½ï¿½jï¿½Aï¿½ï¿½ï¿½
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX; //ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½Å‘ï¿½l
	samplerDesc.MinLOD = 0.0f; //ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½Åï¿½ï¿½l
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; //ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½ï¿½Ì‚ÝŽgï¿½pï¿½Â”\

	// ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½Xï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ý’ï¿½
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ÌÝ’ï¿½
	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	// ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½}ï¿½Xï¿½Nï¿½ÌÝ’ï¿½
	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // ï¿½Wï¿½ï¿½ï¿½Ý’ï¿½

	// ï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Cï¿½Uï¿½ÌÝ’ï¿½
	pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;  // ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½È‚ï¿½
	//pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ï¿½|ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½ï¿½hï¿½ï¿½Â‚Ô‚ï¿½
	//pipelineDesc.RasterizerState.DepthClipEnable = true; // ï¿½[ï¿½xï¿½Nï¿½ï¿½ï¿½bï¿½sï¿½ï¿½ï¿½Oï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½

	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½Ìƒuï¿½ï¿½ï¿½ï¿½ï¿½hï¿½Ý’ï¿½
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; // RBGAï¿½Sï¿½Ä‚Ìƒ`ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½
	blenddesc.BlendEnable = true;                   // ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½hï¿½ï¿½Lï¿½ï¿½ï¿½É‚ï¿½ï¿½ï¿½
	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;    // ï¿½ï¿½ï¿½Z
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;      // ï¿½\ï¿½[ï¿½Xï¿½Ì’lï¿½ï¿½100% ï¿½gï¿½ï¿½
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;    // ï¿½fï¿½Xï¿½gï¿½Ì’lï¿½ï¿½  0% ï¿½gï¿½ï¿½

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;             // ï¿½ï¿½ï¿½Z
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;         // ï¿½\ï¿½[ï¿½Xï¿½ÌƒAï¿½ï¿½ï¿½tï¿½@ï¿½l
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;    // 1.0f-ï¿½\ï¿½[ï¿½Xï¿½ÌƒAï¿½ï¿½ï¿½tï¿½@ï¿½l

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½gï¿½ÌÝ’ï¿½
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// ï¿½}ï¿½`ï¿½ÌŒ`ï¿½ï¿½Ý’ï¿½
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// ï¿½ï¿½ï¿½Ì‘ï¿½ï¿½ÌÝ’ï¿½
	pipelineDesc.NumRenderTargets = 1; // ï¿½`ï¿½ï¿½ÎÛ‚ï¿½1ï¿½ï¿½
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï¿½`255ï¿½wï¿½ï¿½ï¿½RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½É‚Â‚ï¿½1ï¿½ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½O

	// ï¿½fï¿½vï¿½Xï¿½Xï¿½eï¿½ï¿½ï¿½Vï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½ÌÝ’ï¿½
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS; // ï¿½ï¿½Éã‘ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthEnable = false;

	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams; // ï¿½ï¿½ï¿½[ï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½Ìæ“ªï¿½Aï¿½hï¿½ï¿½ï¿½X
	rootSignatureDesc.NumParameters = _countof(rootParams); // ï¿½ï¿½ï¿½[ï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½ï¿½
	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Æƒï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌƒZï¿½bï¿½g
	PipelineSet pipelineSet;

	ComPtr<ID3DBlob> rootSigBlob;
	// ï¿½oï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Å‚ÌƒVï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Cï¿½Y
	result = D3D12SerializeRootSignature(
		&rootSignatureDesc, 
		D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, 
		&errorBlob);
	assert(SUCCEEDED(result));
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateRootSignature(
		0, 
		rootSigBlob->GetBufferPointer(), 
		rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineSet.rootsignature));
	assert(SUCCEEDED(result));

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Éƒï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½g
	pipelineDesc.pRootSignature = pipelineSet.rootsignature.Get();

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineSet.pipelinestate));
	assert(SUCCEEDED(result));

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ð¶ï¿½	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½çŒ©ï¿½ï¿½ï¿½ï¿½æ‚¤ï¿½ï¿½
	descHeapDesc.NumDescriptors = 1; // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[1ï¿½ï¿½
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap));//ï¿½ï¿½ï¿½ï¿½
	if (FAILED(result)) {
		assert(0);
	}

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Æƒï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½
	return pipelineSet;
}

void Sprite::SpriteCreate(ID3D12Device* dev, int window_width, int window_height, 
	UINT texNumber, Vector2 anchorpoint, bool isFlipX, bool isFlipY) {

	HRESULT result = S_FALSE;

	//ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^
	VertexPosUv vertices[] = {
		{{	0.0f, 100.0f,	0.0f},{0.0f,1.0f}},
		{{	0.0f,	0.0f,	0.0f},{0.0f,0.0f}},
		{{100.0f, 100.0f,	0.0f},{1.0f,1.0f}},
		{{100.0f,	0.0f,	0.0f},{1.0f,0.0f}},
	};

	UINT sizeVB = static_cast<UINT>(sizeof(VertexPosUv) * _countof(vertices));

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapPropsVertexBuffer = 
		CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDescVertexBuffer =
		CD3DX12_RESOURCE_DESC::Buffer(sizeof(vertices));

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ôï¿½ï¿½ï¿½ï¿½Rï¿½sï¿½[
	this->texNumber = texNumber;

	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	result = dev->CreateCommittedResource(
		&heapPropsVertexBuffer, // ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
		D3D12_HEAP_FLAG_NONE,
		&resourceDescVertexBuffer, // ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	// ï¿½wï¿½ï¿½Ôï¿½ï¿½Ì‰æ‘œï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ÝÏ‚Ý‚È‚ï¿½
	if (spriteCommon_.texBuff[this->texNumber]) {
		// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
		D3D12_RESOURCE_DESC resDesc = spriteCommon_.texBuff[this->texNumber]->GetDesc();
		// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½Ì‘å‚«ï¿½ï¿½ï¿½ï¿½ï¿½æ‘œï¿½Ì‰ð‘œ“xï¿½Éï¿½ï¿½í‚¹ï¿½ï¿½
		scale = { (float)resDesc.Width,(float)resDesc.Height };
		// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	}

	texSize_ = { (float)resDesc.Width, (float)resDesc.Height };

	// ï¿½Aï¿½ï¿½ï¿½Jï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Rï¿½sï¿½[
	this->anchorpoint = anchorpoint;

	// ï¿½ï¿½ï¿½]ï¿½tï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½Rï¿½sï¿½[
	this->isFlipX_ = isFlipX;
	this->isFlipY_ = isFlipY;

	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	VertexPosUv* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	vertBuff->Unmap(0, nullptr);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½Ìì¬
	// GPUï¿½ï¿½ï¿½zï¿½Aï¿½hï¿½ï¿½ï¿½X
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ÌƒTï¿½Cï¿½Y
	vbView.SizeInBytes = sizeof(vertices);
	// ï¿½ï¿½ï¿½_1ï¿½Â•ï¿½ï¿½Ìƒfï¿½[ï¿½^ï¿½Tï¿½Cï¿½Y
	vbView.StrideInBytes = sizeof(vertices[0]);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapPropsConstantBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDescConstantBuffer =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB0) + 0xff) & ~0xff);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = dev->CreateCommittedResource(
		&heapPropsConstantBuffer, // ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
		D3D12_HEAP_FLAG_NONE,
		&resourceDescConstantBuffer, // ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB0));
	assert(SUCCEEDED(result));

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	result = constBuffB0->Map(0, nullptr, (void**)&constMap); // ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½O
	assert(SUCCEEDED(result));

	constMap->color = color_;

	// ï¿½Pï¿½Êsï¿½ï¿½ï¿½ï¿½ï¿½
	constMap->mat.identity();

	// ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½
	constMap->mat.m[0][0] = 2.0f / WinApp::window_width;
	constMap->mat.m[1][1] = -2.0f / WinApp::window_height;
	constMap->mat.m[3][0] = -1.0f;
	constMap->mat.m[3][1] = 1.0f;
}

void Sprite::PreDraw(ID3D12GraphicsCommandList* cmdList, const SpriteCommon& spriteCommon) {

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½Æƒï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½
	cmdList->SetPipelineState(spriteCommon.pipelineSet.pipelinestate.Get());
	cmdList->SetGraphicsRootSignature(spriteCommon.pipelineSet.rootsignature.Get());

	// ï¿½vï¿½ï¿½ï¿½~ï¿½eï¿½Bï¿½uï¿½`ï¿½ï¿½ÌÝ’ï¿½
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); // ï¿½Oï¿½pï¿½`ï¿½ï¿½ï¿½Xï¿½g

	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½ÅƒXï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ÌÝ’ï¿½
	ID3D12DescriptorHeap* ppHeaps[] = { spriteCommon.descHeap.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
}

void Sprite::PostDraw()
{
}

void Sprite::SpriteDraw(ID3D12GraphicsCommandList* cmdList_, const SpriteCommon& spriteCommon, 
	ID3D12Device* dev) 
{
	// ï¿½ï¿½\ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½Oï¿½ï¿½trueï¿½È‚ï¿½
	if (isInvisible) {
		// ï¿½`ï¿½æ‚¹ï¿½ï¿½ï¿½É”ï¿½ï¿½ï¿½ï¿½ï¿½
		return;
	}

	this->cmdList = cmdList_;

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@(CBV)ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootConstantBufferView(0, constBuffB0->GetGPUVirtualAddress());

	//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootDescriptorTable(
		1, CD3DX12_GPU_DESCRIPTOR_HANDLE(
			spriteCommon.descHeap->GetGPUDescriptorHandleForHeapStart(),
			texNumber, 
			dev->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)));

	//ï¿½|ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½Ì•`ï¿½ï¿½(4ï¿½ï¿½ï¿½_ï¿½ÅŽlï¿½pï¿½`)
	cmdList->DrawInstanced(4, 1, 0, 0);
}

SpriteCommon Sprite::SpriteCommonCreate(ID3D12Device* dev) 
{
	HRESULT result = S_FALSE;

	// ï¿½Vï¿½ï¿½ï¿½ÈƒXï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½ï¿½ï¿½Êƒfï¿½[ï¿½^ï¿½ð¶ï¿½
	SpriteCommon spriteCommon{};

	// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½pï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	spriteCommon.pipelineSet = SpriteCreateGraphicsPipeline(dev);

	spriteCommon.matProjection = Matrix4::identity();

	// ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½
	spriteCommon.matProjection.m[0][0] = 2.0f / WinApp::window_width;
	spriteCommon.matProjection.m[1][1] = -2.0f / WinApp::window_height;
	spriteCommon.matProjection.m[3][0] = -1.0f;
	spriteCommon.matProjection.m[3][1] = 1.0f;

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ð¶ï¿½
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	descHeapDesc.NumDescriptors = SpriteCommon::kMaxSRVCount;
	result = dev->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&spriteCommon.descHeap));

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½ï¿½Ô‚ï¿½
	return spriteCommon;
}

void Sprite::SpriteUpdate(Sprite& sprite, const SpriteCommon& spriteCommon) 
{
	// ï¿½sï¿½ï¿½ÌÝ’ï¿½
	Matrix4 matRot;
	Matrix4 matTrans;
	Matrix4 matRotX, matRotY, matRotZ;

	//ï¿½eï¿½sï¿½ï¿½vï¿½Z
	matRot = Matrix4::identity();
	matRot *= matRotZ.rotateZ(rotation * 180.0f / 3.1415f);
	matRot *= matRotX.rotateX(rotation_.x * 180.0f / 3.1415f);
	matRot *= matRotY.rotateY(rotation_.y * 180.0f / 3.1415f);
	matTrans = Matrix4::identity();
	matTrans.translate(position);

	// ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½sï¿½ï¿½ÌXï¿½V
	Matrix4 mat;
	sprite.matWorld = mat.identity();
	// Zï¿½ï¿½ï¿½ï¿½]
	sprite.matWorld *= matRot;
	// ï¿½ï¿½ï¿½sï¿½Ú“ï¿½
	sprite.matWorld *= matTrans;

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ì“]ï¿½ï¿½
	HRESULT result = sprite.constBuffB0->Map(0, nullptr, (void**)&constMap);
	constMap->mat = sprite.matWorld * spriteCommon.matProjection;
	sprite.constBuffB0->Unmap(0, nullptr);
}

void Sprite::LoadTexture(SpriteCommon& spriteCommon, UINT texnumber, const wchar_t* filename, ID3D12Device* dev) {

	assert(texnumber <= SpriteCommon::kMaxSRVCount - 1);

	HRESULT result;
	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// WICï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ìƒï¿½ï¿½[ï¿½h
	result = LoadFromWICFile(filename, WIC_FLAGS_NONE, &metadata, scratchImg);
	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	// ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½ï¿½
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// ï¿½Ç‚Ýï¿½ï¿½ñ‚¾ƒfï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Yï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½SRGBï¿½Æ‚ï¿½ï¿½Äˆï¿½ï¿½ï¿½
	metadata.format = MakeSRGB(metadata.format);

	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = dev->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½wï¿½ï¿½
		nullptr, IID_PPV_ARGS(&spriteCommon.texBuff[texnumber]));
	assert(SUCCEEDED(result));

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½ï¿½o
		result = spriteCommon.texBuff[texnumber]->WriteToSubresource(
			(UINT)i,
			nullptr, // ï¿½Sï¿½Ìˆï¿½ÖƒRï¿½sï¿½[
			img->pixels, // ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½Aï¿½hï¿½ï¿½ï¿½X
			(UINT)img->rowPitch, // 1ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Tï¿½Cï¿½Y
			(UINT)img->slicePitch // 1ï¿½ï¿½ï¿½Tï¿½Cï¿½Y
		);
		assert(SUCCEEDED(result));
	}

	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ì¬
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // ï¿½Ý’ï¿½\ï¿½ï¿½ï¿½ï¿½
	D3D12_RESOURCE_DESC resDesc = spriteCommon.texBuff[texnumber]->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;// 2Dï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
	srvDesc.Texture2D.MipLevels = 1;

	dev->CreateShaderResourceView(spriteCommon.texBuff[texnumber].Get(), // ï¿½rï¿½ï¿½ï¿½[ï¿½ÆŠÖ˜Aï¿½tï¿½ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
		&srvDesc, // ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ý’ï¿½ï¿½ï¿½
		CD3DX12_CPU_DESCRIPTOR_HANDLE(spriteCommon.descHeap->GetCPUDescriptorHandleForHeapStart(), 
		texnumber, 
		dev->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV))
	);
}

void Sprite::SpriteTransferVertexBuffer(const Sprite& sprite, uint32_t texIndex)
{
	HRESULT result = S_FALSE;

	this->texIndex_ = texIndex;

	// ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^
	VertexPosUv vertices[] = {
		//    u    v
		{{},{0.0f,1.0f}}, // ï¿½ï¿½ï¿½ï¿½
		{{},{0.0f,0.0f}}, // ï¿½ï¿½ï¿½ï¿½
		{{},{1.0f,1.0f}}, // ï¿½Eï¿½ï¿½
		{{},{1.0f,0.0f}}, // ï¿½Eï¿½ï¿½
	};

	//  ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½Aï¿½Eï¿½ï¿½ï¿½Aï¿½Eï¿½ï¿½
	enum { LB, LT, RB, RT };

	// ï¿½ï¿½ï¿½Eï¿½ã‰ºï¿½[ï¿½Ìï¿½ï¿½Wï¿½vï¿½Z
	float left = (0.0f - anchorpoint.x) * scale.x;
	float right = (1.0f - anchorpoint.x) * scale.x;
	float top = (0.0f - anchorpoint.y) * scale.y;
	float bottom = (1.0f - anchorpoint.y) * scale.y;

	if (isFlipX_ = false) 
	{// ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½Ö‚ï¿½
		left = -left;
		right = -right;
	}

	if (isFlipY_ = false)
	{// ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½Ö‚ï¿½
		top = -top;
		bottom = -bottom;
	}

	// ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½zï¿½ï¿½Éï¿½ï¿½Wï¿½Zï¿½bï¿½g
	vertices[LB].pos = { left,  bottom, 0.0f }; // ï¿½ï¿½ï¿½ï¿½
	vertices[LT].pos = { left,     top, 0.0f }; // ï¿½ï¿½ï¿½ï¿½
	vertices[RB].pos = { right, bottom, 0.0f }; // ï¿½Eï¿½ï¿½
	vertices[RT].pos = { right,    top, 0.0f }; // ï¿½Eï¿½ï¿½

	// UVï¿½vï¿½Z
	// ï¿½wï¿½ï¿½Ôï¿½ï¿½Ì‰æ‘œï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ÝÏ‚Ý‚È‚ï¿½
	if (spriteCommon_.texBuff[sprite.texIndex_]) {
		// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
		resDesc = spriteCommon_.texBuff[sprite.texIndex_]->GetDesc();

		float tex_left = sprite.texLeftTop_.x / resDesc.Width;
		float tex_right = (sprite.texLeftTop_.x + sprite.texSize_.x) / resDesc.Width;
		float tex_top = sprite.texLeftTop_.y / resDesc.Height;
		float tex_bottom = (sprite.texLeftTop_.y + sprite.texSize_.y) / resDesc.Height;

		vertices[LB].uv = { tex_left,  tex_bottom }; // ï¿½ï¿½ï¿½ï¿½
		vertices[LT].uv = { tex_left,     tex_top }; // ï¿½ï¿½ï¿½ï¿½
		vertices[RB].uv = { tex_right, tex_bottom }; // ï¿½Eï¿½ï¿½z
		vertices[RT].uv = { tex_right,    tex_top }; // ï¿½Eï¿½ï¿½
	}

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	VertexPosUv* vertMap = nullptr;
	result = sprite.vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	sprite.vertBuff->Unmap(0, nullptr);
}

void Sprite::Finalize()
{
	//delete dXCommon;
}

void Sprite::SetAlpha(Sprite sprite,float alpha_) {

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ì“]ï¿½ï¿½
	HRESULT result = sprite.constBuffB0->Map(0, nullptr, (void**)&constMap);
	constMap->color.w = alpha_;
	sprite.constBuffB0->Unmap(0, nullptr);
	assert(SUCCEEDED(result));
}


============================================================
File Path: engine/2d/Sprite.h
============================================================
#pragma once

#include <Windows.h>
#include <D3dx12.h>
#include <DirectXMath.h>
#include <d3dcompiler.h>
#include <cassert>
#pragma warning(push)
#pragma	warning(disable:26813)
#include <DirectXTex.h>
#pragma warning(pop)
#include <wrl.h>
#include <array>
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include"Matrix4.h"

#include "DirectXCommon.h"

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;



// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Zï¿½bï¿½g
struct PipelineSet {
	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3D12PipelineState> pipelinestate;
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½
	ComPtr<ID3D12RootSignature> rootsignature;
};

// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½Ì‹ï¿½ï¿½Êƒfï¿½[ï¿½^
struct SpriteCommon {
	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Zï¿½bï¿½g
	PipelineSet pipelineSet;
	// ï¿½Ë‰eï¿½sï¿½ï¿½
	Matrix4 matProjection{};
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìï¿½ï¿½ï¿½
	ComPtr<ID3D12DescriptorHeap> descHeap;
	// SRVï¿½ÌÅ‘å–‡ï¿½ï¿½
	static const size_t kMaxSRVCount = 512;
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½\ï¿½[ï¿½X(ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@)ï¿½Ì”zï¿½ï¿½
	ComPtr<ID3D12Resource> texBuff[kMaxSRVCount];
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½æ“¾
	ID3D12Resource* GetTexBuffer(uint32_t index) const { return texBuff[index].Get(); }
};

// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½g
class Sprite
{
public://ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X
	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½pï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½B0
	struct ConstBufferDataB0
	{
		Vector4 color;
		Matrix4 mat;	// ï¿½Rï¿½cï¿½ÏŠï¿½ï¿½sï¿½ï¿½
	};

	// ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^
	struct VertexPosUv {
		Vector3 pos;
		Vector2 uv;
	};
public:
	Sprite();
	~Sprite();

	/// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½ï¿½ï¿½Êƒfï¿½[ï¿½^ï¿½ï¿½ï¿½ï¿½
	SpriteCommon SpriteCommonCreate(ID3D12Device* dev);

	/// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½pï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	PipelineSet SpriteCreateGraphicsPipeline(ID3D12Device* device);

	/// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½ï¿½ï¿½Êƒeï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	void LoadTexture(SpriteCommon& spriteCommon, UINT texnumber, 
		const wchar_t* filename, ID3D12Device* dev);

	/// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½ï¿½ï¿½ï¿½
	void SpriteCreate(ID3D12Device* dev, int window_width, int window_height, 
		UINT texNumber, Vector2 anchorpoint, bool isFlipX, bool FlipY);

	/// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½Pï¿½Ì’ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Ì“]ï¿½ï¿½
	void SpriteTransferVertexBuffer(const Sprite& sprite, uint32_t texIndex_ = UINT32_MAX);

	/// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½Pï¿½ÌXï¿½V
	void SpriteUpdate(Sprite& sprite, const SpriteCommon& spriteCommon);

	/// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	static void PreDraw(ID3D12GraphicsCommandList* cmdList, const SpriteCommon& spriteCommon);

	/// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	static void PostDraw();

	/// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½Pï¿½Ì•`ï¿½ï¿½
	void SpriteDraw(ID3D12GraphicsCommandList* cmdList_, const SpriteCommon& spriteCommon, 
		ID3D12Device* dev);

	/// ï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Finalize();

public: // ï¿½Zï¿½bï¿½^ï¿½[
	// ï¿½ï¿½ï¿½Wï¿½Ý’ï¿½
	void SetPosition(Vector3 position) { this->position = position; }
	// ï¿½Tï¿½Cï¿½Yï¿½Ý’ï¿½
	void SetScale(Vector2 scale) { this->scale = scale; }
	// ï¿½ï¿½]
	void SetRotation(float rotation) { this->rotation = rotation; }
	// ï¿½Ôï¿½
	void SetTexNumber(UINT texNumber) { this->texNumber = texNumber; }
	// ï¿½F
	void SetColor(const Vector4& color) { this->color_ = color; }
	void SetAlpha(Sprite sprite, float alpha_);
	// ï¿½tï¿½ï¿½ï¿½bï¿½v
	void SetIsFlipX(bool isFlipX) { this->isFlipX_ = isFlipX; } // X
	void SetIsFlipY(bool isFlipY) { this->isFlipY_ = isFlipY; } // Y
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½W
	void SetTexLeftTop(const Vector2& texLeftTop) { this->texLeftTop_ = texLeftTop; }
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ø‚ï¿½oï¿½ï¿½ï¿½Tï¿½Cï¿½Y
	void SetTexSize(const Vector2& texSize) { this->texSize_ = texSize; }

public: // ï¿½Qï¿½bï¿½^ï¿½[
	// ï¿½ï¿½ï¿½W
	Vector3 GetPosition() const { return position; }
	// ï¿½Tï¿½Cï¿½Y
	Vector2 GetScale() const { return scale; }
	//ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½sï¿½ï¿½
	Matrix4 GetMat() { return constMap->mat; }
	// ï¿½ï¿½]
	float GetRotation() const { return rotation; }
	// ï¿½Ôï¿½
	UINT GetTexNumber() const { return texNumber; }
	// ï¿½F
	Vector4 GetColor() const { return color_; }
	// ï¿½tï¿½ï¿½ï¿½bï¿½v
	bool GetIsFlipX() const { return isFlipX_; } // X
	bool GetIsFlipY() const { return isFlipY_; } // Y
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½W
	Vector2 GetTexLeftTop() const { return texLeftTop_; }
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ø‚ï¿½oï¿½ï¿½ï¿½Tï¿½Cï¿½Y
	Vector2 GetTexSize() const { return texSize_; }

public:
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> vertBuff;
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	D3D12_RESOURCE_DESC resDesc;

private:
	// DirectXCommonï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½X
	DirectXCommon* dXCommon = nullptr;
	SpriteCommon spriteCommon_;

	ComPtr<ID3D12GraphicsCommandList> cmdList;
	ComPtr<ID3D12DescriptorHeap> descHeap;
	//ï¿½è”ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> constBuffB0 = nullptr;
	// ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½Oï¿½Ï‚ÝƒAï¿½hï¿½ï¿½ï¿½X
	ConstBufferDataB0* constMap = nullptr;
	D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
	static const size_t kMaxSRVCount = 2056;
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
	std::array<ComPtr<ID3D12Resource>, kMaxSRVCount> texBuffers_;

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ôï¿½
	UINT texNumber = 0;
	uint32_t texIndex_ = 0;
	// ï¿½ï¿½ï¿½W
	Vector3 position = { 0.0f, 0.0f, 0.0f };
	// ï¿½Tï¿½Cï¿½Y
	Vector2 scale = { 1.0f, 1.0f };
	// ï¿½ï¿½]
	Vector3 rotation_ = { 0.0f,0.0f,0.0f };
	// ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½sï¿½ï¿½
	Matrix4 matWorld;
	// ï¿½Aï¿½ï¿½ï¿½Jï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½g
	Vector2 anchorpoint = { 0.0f,0.0f };
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½Ý’ï¿½
	Vector2 texLeftTop_ = { 50.0f, 50.0f };
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ø‚ï¿½oï¿½ï¿½ï¿½Tï¿½Cï¿½Y
	Vector2 texSize_ = { 100.0f, 100.0f };
	// ï¿½F
	Vector4 color_ = { 1,1,1,1 };

	// Zï¿½ï¿½ï¿½ï¿½ï¿½Ì‰ï¿½]
	float rotation = 0.0f;
	// ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½]
	bool isFlipX_ = false;
	// ï¿½ã‰ºï¿½ï¿½ï¿½]
	bool isFlipY_ = false;
	// ï¿½ï¿½\ï¿½ï¿½
	bool isInvisible = false;
};



============================================================
File Path: engine/3d/Boss.cpp
============================================================
#include "Boss.h"
#include "SphereCollider.h"
#include "time.h"
#include "stdlib.h"
#include "GameScene.h"

Boss::~Boss()
{
	delete bossModel;
}

void Boss::BossInitialize()
{
	Initialize();
	// OBJï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	bossModel = Model::LoadFromOBJ("fighter");
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Create();
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ð‚ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½
	SetModel(bossModel);
	SetPosition({ -75,65,-200 });
	SetScale({ 10,10,10 });
	//ï¿½pï¿½[ï¿½cï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	for (int i = 0; i < PARTS_NUM; i++) {
		parts[i] = Create();
		parts[i]->worldTransform_.SetParent3d(&worldTransform_);
		parts[i]->SetCollider(new SphereCollider());
	}
	parts[0]->SetPosition({ -2.0f,0.0f,-0.5f });
	parts[1]->SetPosition({ 2.0f,0.0f,-0.5f });
	parts[2]->SetPosition({ 0.0f,0.0f,1.0f });
	parts[3]->SetPosition({ -3.0f,0.0f,-1.0f });
	parts[4]->SetPosition({ 3.0f,0.0f,-1.0f });

	isDead_ = false;
	isInvisible = true;
	//ï¿½^ï¿½Cï¿½}ï¿½[
	appearTimer = 0;
	bossAlpha = 0.0f;
	hp = 300;
	isHit = false;
	hitTimer = 0;
	timer = 0;
	timeCount = 0;
	state = WAIT;
	//ï¿½ï¿½ï¿½ï¿½
	srand((unsigned int)time(NULL));
}

void Boss::Update(Vector3 velo)
{
	//ï¿½oï¿½êŽž
	if (appearTimer > 0) {
		if (appearTimer > 150) {
			SetPosition(GetPosition() + Vector3(0.5f, -0.1f, 0));
		}
		if (appearTimer > 100) {
			bossAlpha += 0.02f;
		}
		appearTimer--;
	}
	//ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½
	Move();
	ChangeState();

	//ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½Xï¿½V
	for (std::unique_ptr<BossBullet>& bullet : bullets_) {
		bullet->Update(velo);
	}
	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½Oï¿½Ì—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½íœ
	bullets_.remove_if([](std::unique_ptr <BossBullet>& bullets_) {
		return bullets_->IsDead();
		});
	
	 //ï¿½_ï¿½ï¿½ï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½
	if (hitTimer > 0) {
		hitTimer--;
		if (hitTimer == 0) {
			isHit = false;
		}
	}
	//HPï¿½ï¿½0ï¿½È‚çŽ€ï¿½S
	if (hp <= 0) {
		isDead_ = true;
	}
	//ï¿½Xï¿½V
	worldTransform_.UpdateMatrix();
	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½Xï¿½V
	if (collider)
	{
		collider->Update();
	}
	//ï¿½{ï¿½Xï¿½pï¿½[ï¿½cï¿½Aï¿½bï¿½vï¿½fï¿½[ï¿½g
	for (int i = 0; i < PARTS_NUM; i++) {
		parts[i]->Update();
	}
	//ï¿½Jï¿½Eï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Zï¿½bï¿½g
	if (timeCount == 4) {
		timeCount = 0;
	}
}

void Boss::Pop()
{
	if (isInvisible == true) {
		isInvisible = false;
	}
	appearTimer = 300;
}

void Boss::Attack()
{
	//ï¿½eï¿½ð¶ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	std::unique_ptr<BossBullet> newBullet = std::make_unique<BossBullet>();

	//ï¿½Pï¿½ï¿½													   
	newBullet->BulletInitialize(GetPosition());
	newBullet->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 5.0f));

	//ï¿½eï¿½Ì“oï¿½^										 
   //ï¿½ï¿½ï¿½ï¿½
	newBullet->SetPosition(GetPosition());
	newBullet->SetScale({ 1.2f,1.2f,1.2f });
	bullets_.push_back(std::move(newBullet));
}

void Boss::Move()
{
	//ï¿½{ï¿½Xï¿½oï¿½ï¿½ï¿½
	if (isInvisible == false) {
		if (timer < 75) {
			SetPosition(GetPosition() + Vector3(0.0f, 0.01f, 0.0f));
		}
		else if (timer < 150) {
			SetPosition(GetPosition() + Vector3(0.0f, -0.01f, 0.0f));
		}
		else {
			timer = 0;
			timeCount++;
		}
		timer++;
	}
}

void Boss::ChangeState()
{
	//ï¿½Ò‹@ï¿½ï¿½ï¿½
	if (state == WAIT) {
		if (timeCount == 4) {
			//ï¿½ï¿½ï¿½ï¿½ï¿½É‚ï¿½ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
			int random = rand() % 1 + 1;
			//ï¿½ï¿½ï¿½Iï¿½ï¿½ï¿½ê‚½ï¿½sï¿½ï¿½
			state = (State)random;
		}						 
	}
	//ï¿½ËŒï¿½ï¿½ï¿½ï¿½
	else if (state == SHOT) {
		Attack();
		state = WAIT;
	}
}

void Boss::BossDraw(ViewProjection* viewProjection_)
{
	Draw(viewProjection_, bossAlpha);
	//ï¿½eï¿½`ï¿½ï¿½
	for (std::unique_ptr<BossBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}

void Boss::OnCollision(const CollisionInfo& info)
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	const char* str1 = "class PlayerBullet";

	//ï¿½ï¿½ï¿½è‚ªplayerï¿½Ì’e
	if (strcmp(toCollisionName, str1) == 0) {
		if (isHit == false && isInvisible == false) {
			isHit = true;
			hitTimer = 30;
			hp-= 5;
			for (int i = 0; i < PARTS_NUM; i++) {
				if (parts[i]->GetIsLocked() == true) {
					parts[i]->SetIsLocked(false);
					GameScene::PopEnergy(parts[i]->GetWorldPos());
					hp -= 5;
				}
			}
		}
	}
}

void Boss::SkipMovie()
{
	appearTimer = 0;
	SetPosition({ 0.0f,49.99f,-200.0f });
	bossAlpha = 1.0f;
}


============================================================
File Path: engine/3d/Boss.h
============================================================
#pragma once
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include "BossBullet.h"

//GameSceneï¿½Ì‘Oï¿½ï¿½ï¿½éŒ¾
class GameScene;

class Boss : public Object3d
{
public:
	//ï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	~Boss();
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void BossInitialize();

	void Update(Vector3 velo);
	void Pop();
	void Attack();
	void Move();
	void ChangeState();
	
	void BossDraw(ViewProjection* viewProjection_);

	bool GetIsDead() const { return isDead_; }
	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	void OnCollision(const CollisionInfo& info) override;
	//Getter
	bool GetIsInvisible() { return isInvisible; }
	float GetAlpha() { return bossAlpha; }
	int GetTimer() { return appearTimer; }
	float GetHP() { return hp; }
	int GetPartsNum() { return PARTS_NUM; }
	Object3d* GetParts(int i) { return parts[i]; }
	//ï¿½ï¿½ï¿½oï¿½Xï¿½Lï¿½bï¿½v
	void SkipMovie();

	

private:

	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½O
	bool isDead_ = false;
	bool isInvisible = true;
	//ï¿½^ï¿½Cï¿½}ï¿½[
	int appearTimer = 0;
	float bossAlpha = 0.0f;
	float hp;
	bool isHit;
	int hitTimer;
	int timeCount;
	int timer;
	
	//ï¿½{ï¿½Xï¿½sï¿½ï¿½ï¿½ï¿½ï¿½
	enum State {
		WAIT,
		SHOT
	};
	State state;

	// ï¿½ï¿½ï¿½fï¿½ï¿½
	Model* bossModel = nullptr;
	//ï¿½e
	std::list<std::unique_ptr<BossBullet>> bullets_;
	static const int PARTS_NUM = 5;
	Object3d* parts[PARTS_NUM];
};


============================================================
File Path: engine/3d/BossBullet.cpp
============================================================
#include "BossBullet.h"
#include "BaseCollider.h"

void BossBullet::BulletInitialize(const Vector3& position)
{
	Initialize();

	// OBJï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	bulletModel->LoadTexture("Resources/blue.png");
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Create();
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ð‚ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½
	SetModel(bulletModel);

	//ï¿½Ì—ÍŽwï¿½ï¿½
	hp = 2;
	hitTime = 0;
	isHit = false;
}

void BossBullet::Update(const Vector3& playerPos_)
{
	//ï¿½Ú“ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½vï¿½Z
	velocity = playerPos_ - GetPosition();
	velocity.normalize();
	//ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½Z
	SetPosition(GetPosition() + velocity);
	//ï¿½Xï¿½V
	worldTransform_.UpdateMatrix();

	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½Xï¿½V
	if (collider)
	{
		collider->Update();
	}
	//ï¿½qï¿½bï¿½gï¿½ï¿½ï¿½Nï¿½[ï¿½ï¿½ï¿½^ï¿½Cï¿½ï¿½
	if (hitTime > 0) {
		hitTime--;
		if (isHit == false) {
			isHit = true;
			bulletModel->LoadTexture("Resources/red.png");
		}
	}
	else {
		if (isHit == true) {
			isHit = false;
			bulletModel->LoadTexture("Resources/blue.png");
		}
	}
	//ï¿½ï¿½ï¿½ÔŒoï¿½ß‚Åƒfï¿½X
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}
}

void BossBullet::OnCollision(const CollisionInfo& info)
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	const char* str1 = "class Player";
	const char* str2 = "class PlayerBullet";

	//ï¿½ï¿½ï¿½è‚ªplayer
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
	//ï¿½ï¿½ï¿½è‚ªplayerï¿½Ì’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (hitTime == 0) {
			if (hp == 2) {
				hp--;
			}
			else {
				isDead_ = true;
				hitTime = 10;
			}
		}
	}
}


============================================================
File Path: engine/3d/BossBullet.h
============================================================
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class BossBullet : public Object3d
{
public:
	///< summary>
	///ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	///</summary>
	void BulletInitialize(const Vector3& position);

	///< summary>
	///ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	///</summary>
	void Update(const Vector3& playerPos_);


	//ï¿½Õ“Ë‚ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚Ñoï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½[ï¿½ï¿½ï¿½oï¿½bï¿½Nï¿½Öï¿½
	void OnCollision(const CollisionInfo& info) override;


public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }

private:
	//ï¿½ï¿½ï¿½fï¿½ï¿½
	Model* bulletModel = nullptr;

	//ï¿½ï¿½ï¿½x
	Vector3 playerPos;
	Vector3 velocity;

	//ï¿½ï¿½ï¿½ï¿½
	static const int32_t kLifeTime = 60 * 3;
	//ï¿½fï¿½Xï¿½^ï¿½Cï¿½}ï¿½[
	int32_t deathTimer_ = kLifeTime;
	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½O
	int hp;
	int hitTime;
	bool isHit;
	bool isDead_ = false;

};


============================================================
File Path: engine/3d/Enemy.cpp
============================================================
#include "Enemy.h"
#include "string.h"
#include "BaseCollider.h"
#include "SphereCollider.h"
#include "GameScene.h"

//ï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
Enemy::~Enemy() {
	delete enemyModel;
}

//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
void Enemy::EnemyInitialize()
{
	Initialize();
	// OBJï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	enemyModel = Model::LoadFromOBJ("triangle_mat");
	enemyModel->LoadTexture("Resources/red.png");
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Create();
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ð‚ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½
	SetModel(enemyModel);
	isDead_ = false;
	isInvisible = true;
	timer = 0;
	isAttack = false;
	timeCount = 0;
	alpha = 0;
}

void Enemy::Update(Vector3 velo,float t) {
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ô‚È‚ï¿½
	if (isInvisible == true) {
		float len = stagePoint - t + 1.0f;
 		if (len < 4.0f) {
			isInvisible = false;
		}
	}
	else {
		if (alpha < 1) {
			alpha += 0.05f;
		}
		float moveX;
		if (timeCount == 0) {
			moveX = -0.05f;
		}
		else if (timeCount == 1) {
			moveX = 0.05f;
		}
		else if (timeCount == 2) {
			moveX = 0.05f;
		}
		else {
			moveX = -0.05f;
		}

		if (timer < 75) {
			SetPosition(GetPosition() + Vector3(moveX, 0.005f, 0));
		}
		else if (timer < 150) {
			SetPosition(GetPosition() + Vector3(moveX, -0.005f, 0));
		}
		else {
			timer = 0;
			if (timeCount == 4) {
				timeCount = 0;
			}
			else {
				timeCount++;
			}
		}
		//playerï¿½ï¿½ï¿½Gï¿½ï¿½Ç‚ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½
		if (stagePoint < t + 1.0f) {
			if (isAttack == true) {
				isAttack = false;
			}
		}
		//ï¿½Uï¿½ï¿½
		if (isAttack == false) {
			Vector3 playerVec = velo - GetPosition();
			float len = playerVec.length();
			if (len < 70.0f) {
				isAttack = true;
			}
		}
		else {
			Attack();
		}

		for (std::unique_ptr<EnemyBullet>& bullet : bullets_) {
			bullet->Update(velo);
		}
		//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½Oï¿½Ì—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½íœ
		bullets_.remove_if([](std::unique_ptr <EnemyBullet>& bullets_) {
			return bullets_->IsDead();
			});
		//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½Xï¿½V
		if (collider)
		{
			collider->Update();
		}
		worldTransform_.UpdateMatrix();
		timer++;
	}
}

void Enemy::OnCollision(const CollisionInfo& info)
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	const char* str1 = "class PlayerBullet";

	//ï¿½ï¿½ï¿½è‚ªplayerï¿½Ì’e
	if (strcmp(toCollisionName, str1) == 0) {
		if (isInvisible == false) {
			if (isDead_ == false) {
				isDead_ = true;
				for (int i = 0; i < 3; i++) {
					GameScene::PopEnergy(GetPosition());
				}
			}
		}
	}
}

void Enemy::Attack() {

		if (coolTime == 0) {
			//ï¿½eï¿½ð¶ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		//ï¿½ï¿½ï¿½ï¿½
			std::unique_ptr<EnemyBullet> newBullet = std::make_unique<EnemyBullet>();

			//ï¿½Pï¿½ï¿½													   
			newBullet->BulletInitialize(GetPosition());
			newBullet->SetCollider(new SphereCollider(Vector3{0,0,0},0.5f));

			//ï¿½eï¿½Ì“oï¿½^										 
		   //ï¿½ï¿½ï¿½ï¿½
			newBullet->SetPosition(GetPosition());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			bullets_.push_back(std::move(newBullet));


			//ï¿½Nï¿½[ï¿½ï¿½ï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½Ý’ï¿½
			coolTime = 200;
		}
		else if (coolTime > 0) {
			coolTime--;
		}

}

void Enemy::EnemyDraw(ViewProjection* viewProjection_) {
	Draw(viewProjection_, alpha);
	//ï¿½eï¿½`ï¿½ï¿½
	for (std::unique_ptr<EnemyBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}

============================================================
File Path: engine/3d/Enemy.h
============================================================
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include <list>
#include "EnemyBullet.h"

//GameSceneï¿½Ì‘Oï¿½ï¿½ï¿½éŒ¾
class GameScene;

class Enemy : public Object3d
{
public:
	//ï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	~Enemy();
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void EnemyInitialize();


	bool GetIsDead() const { return isDead_; }
	
	void Update(Vector3 velo,float t);
	void EnemyDraw(ViewProjection* viewProjection_);

	void Attack();

	void OnCollision(const CollisionInfo& info) override;
	void SetStagePoint(float pos_) { stagePoint = pos_; }
	float GetStagePoint(){return stagePoint;}
	Object3d* GetPointer() { return this; }
	bool GetIsInvisible() { return isInvisible; }

	//ï¿½eï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½æ“¾
	const std::list<std::unique_ptr<EnemyBullet>>& GetBullets() { return bullets_; }

private:

	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½O
	bool isDead_ = false;
	//
	bool isInvisible = true;

	//ï¿½G
	std::list<std::unique_ptr<EnemyBullet>> bullets_;

	// ï¿½ï¿½ï¿½fï¿½ï¿½
	Model* enemyModel = nullptr;
	float alpha;

	//ï¿½ï¿½ï¿½a
	int timer;
	float radius = 1.0f;
	int coolTime = 0;
	float stagePoint;

	bool isAttack;
	int timeCount;
};


============================================================
File Path: engine/3d/EnemyBullet.cpp
============================================================
#include "EnemyBullet.h"
#include "BaseCollider.h"

void EnemyBullet::BulletInitialize(const Vector3& position) {

	Initialize();

	// OBJï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Create();
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ð‚ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½
	SetModel(bulletModel);

	//ï¿½ï¿½ï¿½ï¿½ï¿½ÅŽó‚¯Žï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½É‘ï¿½ï¿½
	bulletTime = 0;
}

void EnemyBullet::Update(const Vector3& playerPos_) {

	if (bulletTime < 40) {
		velocity = (playerPos_ - GetPosition()) * 0.05f;
		bulletTime++;
	}

	SetPosition(GetPosition() + velocity);

	worldTransform_.UpdateMatrix();

	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½Xï¿½V
	if (collider)
	{
		collider->Update();
	}
	//ï¿½ï¿½ï¿½ÔŒoï¿½ß‚Åƒfï¿½X
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}
}

void EnemyBullet::OnCollision(const CollisionInfo& info)
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	const char* str1 = "class Player";
	const char* str2 = "class PlayerBullet";

	//ï¿½ï¿½ï¿½è‚ªplayer
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
	//ï¿½ï¿½ï¿½è‚ªplayerï¿½Ì’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
}


============================================================
File Path: engine/3d/EnemyBullet.h
============================================================
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class EnemyBullet : public Object3d
{
public:
	///< summary>
	///ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	///</summary>
	void BulletInitialize(const Vector3& position);

	///< summary>
	///ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	///</summary>
	void Update(const Vector3& playerPos_);


	//ï¿½Õ“Ë‚ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚Ñoï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½[ï¿½ï¿½ï¿½oï¿½bï¿½Nï¿½Öï¿½
	void OnCollision(const CollisionInfo& info) override;


public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }

private:
	//ï¿½ï¿½ï¿½fï¿½ï¿½
	Model* bulletModel = nullptr;

	//ï¿½ï¿½ï¿½x
	Vector3 playerPos;
	Vector3 velocity;

	//ï¿½ï¿½ï¿½ï¿½
	static const int32_t kLifeTime = 60 * 3;
	//ï¿½fï¿½Xï¿½^ï¿½Cï¿½}ï¿½[
	int32_t deathTimer_ = kLifeTime;
	int bulletTime;
	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½O
	bool isDead_ = false;

};


============================================================
File Path: engine/3d/Energy.cpp
============================================================
#include "Energy.h"
#include "string.h"
#include "BaseCollider.h"
#include "SphereCollider.h"

void Energy::EnergyInitialize()
{
	Initialize();
	// OBJï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	energyModel = Model::LoadFromOBJ("panel");
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Create();
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ð‚ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½
	SetModel(energyModel);
	SetScale(Vector3(0.5f, 0.5f, 0.5f));
	isDead = false;
}

void Energy::Update(Vector3 pos,Vector3 rot)
{
	//playerï¿½Ì‚ï¿½ï¿½Æ‚ï¿½
	Vector3 velo = pos - GetPosition();
	velo = velo.normalize();
	SetPosition(GetPosition() + velo);
	SetRotation(rot + Vector3(0,90,0));

	worldTransform_.UpdateMatrix();

	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½Xï¿½V
	if (collider)
	{
		collider->Update();
	}
}

void Energy::OnCollision(const CollisionInfo& info)
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	const char* str1 = "class Player";

	//ï¿½ï¿½ï¿½è‚ªplayerï¿½Ì’e
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead == false) {
			isDead = true;
		}
	}
}


============================================================
File Path: engine/3d/Energy.h
============================================================
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include <list>

//GameSceneï¿½Ì‘Oï¿½ï¿½ï¿½éŒ¾
class GameScene;

class Energy : public Object3d
{
public:

	void EnergyInitialize();
	
	void Update(Vector3 pos, Vector3 rot);

	void OnCollision(const CollisionInfo& info) override;

	bool GetIsDead() const { return isDead; }

private:
	// ï¿½ï¿½ï¿½fï¿½ï¿½
	Model* energyModel = nullptr;
	
	bool isDead;
};


============================================================
File Path: engine/3d/FbxLoader.cpp
============================================================
#include "FbxLoader.h"
#include <cassert>
#include "Vector3.h"
#include "DirectXMath.h"

//ï¿½Ã“Iï¿½Ïï¿½ï¿½ÌŽï¿½ï¿½ï¿½
const std::string FbxLoader::baseDirectory =
"Resources/";
const std::string FbxLoader::defaultTextureFileName =
"white1x1.png";

//ï¿½Cï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½æ“¾
FbxLoader* FbxLoader::GetInstance() {
	static FbxLoader instance;
	return &instance;
}

//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
void FbxLoader::Initialize(ID3D12Device* device) {

	//ï¿½Äï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	assert(fbxManager == nullptr);
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½çƒï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½É‘ï¿½ï¿½
	this->device = device;
	//FBXï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½[ï¿½Ìï¿½ï¿½ï¿½
	fbxManager = FbxManager::Create();
	//FBXï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½[ï¿½Ì“ï¿½ï¿½oï¿½ÍÝ’ï¿½
	FbxIOSettings* ios = FbxIOSettings::Create(fbxManager, IOSROOT);
	fbxManager->SetIOSettings(ios);
	//FBXï¿½Cï¿½ï¿½ï¿½|ï¿½[ï¿½^ï¿½[ï¿½Ìï¿½ï¿½ï¿½
	fbxImporter = FbxImporter::Create(fbxManager, "");
}

//ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
FbxModel* FbxLoader::LoadModelFlomFile(const string& modelName) {
	const string directoryPath = baseDirectory + modelName + "/";
	const string fileName = modelName + ".fbx";
	//ï¿½Aï¿½ï¿½
	const string fullPath = directoryPath + fileName;

	//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½Ä“Ç‚Ýï¿½ï¿½ï¿½
	if (!fbxImporter->Initialize(fullPath.c_str(), -1, fbxManager->GetIOSettings())) {
		assert(0);
	}
	FbxScene* fbxScene = FbxScene::Create(fbxManager, "fbxScene");

	//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½ÉƒCï¿½ï¿½ï¿½|ï¿½[ï¿½g
	fbxImporter->Import(fbxScene);

	//ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	FbxModel* model = new FbxModel();
	model->name = modelName;
	//ï¿½mï¿½[ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	int nodeCount = fbxScene->GetNodeCount();

	model->nodes.reserve(nodeCount);

	ParseNodeRecursive(model, fbxScene->GetRootNode());
	model->fbxScene = fbxScene;

	//ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	model->CreateBuffers(device);
	assert(model->indices.size());

	return model;
}

//ï¿½mï¿½[ï¿½hï¿½ï¿½ï¿½
void FbxLoader::ParseNodeRecursive(FbxModel* model, FbxNode* fbxNode, Node* parent) {

	model->nodes.emplace_back();
	Node& node = model->nodes.back();
	//ï¿½mï¿½[ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	node.name = fbxNode->GetName();

	//fbxï¿½mï¿½[ï¿½hï¿½Ìƒï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½Ú“ï¿½ï¿½ï¿½ï¿½
	FbxDouble3 rotation = fbxNode->LclRotation.Get();
	FbxDouble3 scaling = fbxNode->LclScaling.Get();
	FbxDouble3 translation = fbxNode->LclTranslation.Get();

	//ï¿½`ï¿½ï¿½ï¿½ÏŠï¿½ï¿½ï¿½ï¿½Ä‘ï¿½ï¿½
	node.rotation = { (float)rotation[0],(float)rotation[1],(float)rotation[2],0.0f };
	node.scaling = { (float)scaling[0],(float)scaling[1],(float)scaling[2],0.0f };
	node.translation = { (float)translation[0],(float)translation[1],(float)translation[2],1.0f };

	//ï¿½ï¿½]ï¿½pï¿½ï¿½Degreeï¿½ï¿½ï¿½çƒ‰ï¿½Wï¿½Aï¿½ï¿½ï¿½É•ÏŠï¿½
	node.rotation.x = Matrix4::ConvertToRadian(node.rotation.x);
	node.rotation.y = Matrix4::ConvertToRadian(node.rotation.y);
	node.rotation.z = Matrix4::ConvertToRadian(node.rotation.z);

	//ï¿½pï¿½sï¿½ï¿½ÌŒvï¿½Z
	Matrix4 matScaling, matRotation, matTranslation;
	Matrix4 matRotX, matRotY, matRotZ;
	Vector3 scl = { node.scaling.x,node.scaling.y ,node.scaling.z };
	matScaling = Matrix4::identity();
	matScaling.scale(scl);
	matRotation = Matrix4::identity();
	matRotation *= matRotZ.rotateZ(Matrix4::ConvertToRadian(node.rotation.z));
	matRotation *= matRotX.rotateX(Matrix4::ConvertToRadian(node.rotation.x));
	matRotation *= matRotY.rotateY(Matrix4::ConvertToRadian(node.rotation.y));
	Vector3 trl = { node.translation.x,node.translation.y,node.translation.z };
	matTranslation = Matrix4::identity();
	matTranslation.translate(trl);

	//ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½ÏŠï¿½ï¿½sï¿½ï¿½ÌŒvï¿½Z
	node.tranform = Matrix4::identity();
	node.tranform *= matScaling;
	node.tranform *= matRotation;
	node.tranform *= matTranslation;

	//ï¿½Oï¿½ï¿½ï¿½[ï¿½oï¿½ï¿½ï¿½ÏŒ`ï¿½sï¿½ï¿½ÌŒvï¿½Z
	node.globalTransform = node.tranform;
	if (parent) {
		node.parent = parent;
		//ï¿½eï¿½Ì•ÏŒ`ï¿½ï¿½ï¿½ï¿½Z
		node.globalTransform *= parent->globalTransform;
	}

	//ï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½
	FbxNodeAttribute* fbxNodeAttribute = fbxNode->GetNodeAttribute();

	if (fbxNodeAttribute) {
		if (fbxNodeAttribute->GetAttributeType() == FbxNodeAttribute::eMesh) {
			model->meshNode = &node;
			ParseMesh(model, fbxNode);
		}
	}

	//ï¿½qï¿½mï¿½[ï¿½hï¿½É‘Î‚ï¿½ï¿½ÄÄ‹Nï¿½Ä‚Ñoï¿½ï¿½
	for (int i = 0; i < fbxNode->GetChildCount(); i++) {
		ParseNodeRecursive(model, fbxNode->GetChild(i), &node);
	}


}

void FbxLoader::ParseMesh(FbxModel* model, FbxNode* fbxNode) {
	FbxMesh* fbxMesh = fbxNode->GetMesh();

	//ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Wï¿½Ç‚ÝŽï¿½ï¿½
	ParseMeshVertices(model, fbxMesh);
	//ï¿½ï¿½
	ParseMeshFaces(model, fbxMesh);
	//ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½
	ParseMatrial(model, fbxNode);
	//ï¿½Xï¿½Lï¿½jï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½Ç‚ÝŽï¿½ï¿½
	ParseSkin(model, fbxMesh);

}
//ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Ç‚ÝŽï¿½ï¿½
void FbxLoader::ParseMeshVertices(FbxModel* model, FbxMesh* fbxMesh) {
	auto& vertices = model->vertices;

	//ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Wï¿½Ìƒfï¿½[ï¿½^ï¿½Ìï¿½
	const int controlPointsCount = fbxMesh->GetControlPointsCount();

	//ï¿½Kï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½ï¿½ï¿½mï¿½ï¿½
	FbxModel::VertexPosNormalUvSkin vert{};
	model->vertices.resize(controlPointsCount, vert);

	//fbxï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½Ì’ï¿½ï¿½_ï¿½ï¿½ï¿½Wï¿½zï¿½ï¿½ï¿½ï¿½æ“¾
	FbxVector4* pCoord = fbxMesh->GetControlPoints();

	//fbxï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½Ì‘Sï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ì”zï¿½ï¿½ÉƒRï¿½sï¿½[ï¿½ï¿½ï¿½ï¿½
	for (int i = 0; i < controlPointsCount; i++) {
		FbxModel::VertexPosNormalUvSkin& vertex = vertices[i];
		//ï¿½ï¿½ï¿½Wï¿½ÌƒRï¿½sï¿½[
		vertex.pos.x = (float)pCoord[i][0];
		vertex.pos.y = (float)pCoord[i][1];
		vertex.pos.z = (float)pCoord[i][2];
	}
}
//ï¿½Êï¿½ï¿½Ç‚ÝŽï¿½ï¿½
void FbxLoader::ParseMeshFaces(FbxModel* model, FbxMesh* fbxMesh) {
	auto& vertices = model->vertices;
	auto& indices = model->indices;

	//1ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½É•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½Ìƒï¿½ï¿½fï¿½ï¿½ï¿½Í”ï¿½Î‰ï¿½
	assert(indices.size() == 0);

	//ï¿½Ê‚Ìï¿½
	const int polygonCount = fbxMesh->GetPolygonCount();
	//uvï¿½fï¿½[ï¿½^ï¿½Ìï¿½
	const int textureUVCount = fbxMesh->GetTextureUVCount();
	//uvï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½g
	FbxStringList uvNames;
	fbxMesh->GetUVSetNames(uvNames);

	//ï¿½Ê‚ï¿½ï¿½Æ‚Ìï¿½ï¿½Ç‚ÝŽï¿½ï¿½
	for (int i = 0; i < polygonCount; i++) {
		const int polygonSize = fbxMesh->GetPolygonSize(i);
		assert(polygonSize <= 4);

		for (int j = 0; j < polygonSize; j++) {
			int index = fbxMesh->GetPolygonVertex(i, j);
			assert(index >= 0);
			//ï¿½ï¿½ï¿½_ï¿½@ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			FbxModel::VertexPosNormalUvSkin& vertex = vertices[index];
			FbxVector4 normal;
			if (fbxMesh->GetPolygonVertexNormal(i, j, normal)) {
				vertex.normal.x = (float)normal[0];
				vertex.normal.y = (float)normal[1];
				vertex.normal.z = (float)normal[2];
			}
			//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½uvï¿½Ç‚Ýï¿½ï¿½ï¿½
			if (textureUVCount > 0) {
				FbxVector2 uvs;
				bool lUnmappedUV;
				//0ï¿½ÔŒï¿½ï¿½ß‘Å‚ï¿½ï¿½Å“Ç‚Ýï¿½ï¿½ï¿½
				if (fbxMesh->GetPolygonVertexUV(i, j, uvNames[0], uvs, lUnmappedUV)) {
					vertex.uv.x = (float)uvs[0];
					vertex.uv.y = (float)uvs[1];
				}
			}

			//ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½zï¿½ï¿½É’ï¿½ï¿½_ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½ï¿½Ç‰ï¿½
			if (j < 3) {
				indices.push_back(index);
			}
			//4ï¿½ï¿½ï¿½_
			else {
				int index2 = indices[indices.size() - 1];
				int index3 = index;
				int index0 = indices[indices.size() - 3];
				indices.push_back(index2);
				indices.push_back(index3);
				indices.push_back(index0);
			}
		}
	}

}
//ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
void FbxLoader::ParseMatrial(FbxModel* model, FbxNode* fbxNode) {
	const int materialCount = fbxNode->GetMaterialCount();
	if (materialCount > 0) {
		FbxSurfaceMaterial* material = fbxNode->GetMaterial(0);
		bool textureLoaded = false;

		if (material) {
			if (material->GetClassId().Is(FbxSurfaceLambert::ClassId)) {
				FbxSurfaceLambert* lambert =
					static_cast<FbxSurfaceLambert*>(material);

				//ï¿½Â‹ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½
				FbxPropertyT<FbxDouble3> ambient = lambert->Ambient;
				model->ambient.x = (float)ambient.Get()[0];
				model->ambient.y = (float)ambient.Get()[1];
				model->ambient.z = (float)ambient.Get()[2];

				//ï¿½gï¿½Uï¿½ï¿½ï¿½ËŒï¿½ï¿½Wï¿½ï¿½
				FbxPropertyT<FbxDouble3> diffuse = lambert->Diffuse;
				model->diffuse.x = (float)diffuse.Get()[0];
				model->diffuse.y = (float)diffuse.Get()[1];
				model->diffuse.z = (float)diffuse.Get()[2];
			}
			//ï¿½fï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Yï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½
			const FbxProperty diffuseProperty =
				material->FindProperty(FbxSurfaceMaterial::sDiffuse);
			if (diffuseProperty.IsValid()) {
				const FbxFileTexture* texture = diffuseProperty.GetSrcObject<FbxFileTexture>();
				if (texture) {
					const char* filepath = texture->GetFileName();
					//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½pï¿½Xï¿½ï¿½ï¿½ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½o
					string path_str(filepath);
					string name = ExtracFileName(path_str);
					//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
					LoadTexture(model, baseDirectory + model->name + "/" + name);
					textureLoaded = true;
				}
			}
		}
		//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½ê‡ï¿½ï¿½ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½
		if (!textureLoaded) {
			LoadTexture(model, baseDirectory + defaultTextureFileName);
		}
	}
}

//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
void FbxLoader::LoadTexture(FbxModel* model, const std::string& fullPath) {
	HRESULT result = S_FALSE;
	//WICï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ìƒï¿½ï¿½[ï¿½h
	DirectX::TexMetadata& metadata = model->metaData;
	DirectX::ScratchImage& scratchImage = model->scratchImg;
	//ï¿½ï¿½ï¿½jï¿½Rï¿½[ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É•ÏŠï¿½
	wchar_t wfilepath[128];
	MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, wfilepath, _countof(wfilepath));
	result = DirectX::LoadFromWICFile(wfilepath, DirectX::WIC_FLAGS_NONE, &metadata, scratchImage);

	if (FAILED(result)) {
		assert(0);
	}
}

//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½o
std::string FbxLoader::ExtracFileName(const std::string& path) {
	size_t pos1;
	//ï¿½ï¿½Ø‚è•¶ï¿½ï¿½""ï¿½ï¿½ï¿½oï¿½Ä‚ï¿½ï¿½ï¿½ï¿½ÔÅŒï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	pos1 = path.rfind("\\");
	if (pos1 != string::npos) {
		return path.substr(pos1 + 1, path.size() - pos1 - 1);
	}
	//ï¿½ï¿½Ø‚è•¶ï¿½ï¿½'/'
	pos1 = path.rfind('/');
	if (pos1 != string::npos) {
		return path.substr(pos1 + 1, path.size() - pos1 - 1);
	}

	return path;
}

//ï¿½ï¿½nï¿½ï¿½
void FbxLoader::Finalize() {
	//ï¿½eï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½Ì”jï¿½ï¿½
	fbxImporter->Destroy();
	fbxManager->Destroy();
}

void FbxLoader::ConvertMatrixFromFbx(Matrix4 dst, const FbxAMatrix& src) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			dst.m[i][j] = (float)src.Get(i, j);
		}
	}
}

void FbxLoader::ParseSkin(FbxModel* model, FbxMesh* fbxMesh) {
	FbxSkin* fbxSkin =
	static_cast<FbxSkin*>(fbxMesh->GetDeformer(0, FbxDeformer::eSkin));
	//ï¿½Xï¿½Lï¿½jï¿½ï¿½ï¿½Oï¿½ï¿½ñ‚ª‚È‚ï¿½ï¿½ï¿½ÎIï¿½ï¿½
	if (fbxSkin == nullptr) {
		return;
	}
	//ï¿½{ï¿½[ï¿½ï¿½ï¿½zï¿½ï¿½ÌŽQï¿½ï¿½
	std::vector<FbxModel::Bone>& bones = model->bones;
	//ï¿½{ï¿½[ï¿½ï¿½ï¿½Ìï¿½
	int clusterCount = fbxSkin->GetClusterCount();
	bones.reserve(clusterCount);

	//ï¿½Sï¿½Ä‚Ìƒ{ï¿½[ï¿½ï¿½ï¿½É‚Â‚ï¿½ï¿½ï¿½
	for (int i = 0; i < clusterCount; i++) {
		//FBXï¿½{ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½
		FbxCluster* fbxCluster = fbxSkin->GetCluster(i);
		//ï¿½{ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚Ìƒmï¿½[ï¿½hï¿½Ì–ï¿½ï¿½Oï¿½ï¿½ï¿½æ“¾
		const char* boneName = fbxCluster->GetLink()->GetName();
		//ï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½[ï¿½ï¿½ï¿½ï¿½Ç‰ï¿½ï¿½ï¿½ï¿½Ç‰ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½[ï¿½ï¿½ï¿½ÌŽQï¿½Æ‚ð“¾‚ï¿½
		bones.emplace_back(FbxModel::Bone(boneName));
		FbxModel::Bone& bone = bones.back();
		//ï¿½ï¿½ï¿½ï¿½{ï¿½[ï¿½ï¿½ï¿½ï¿½Fbxï¿½Ìƒ{ï¿½[ï¿½ï¿½ï¿½ï¿½Rï¿½Ã‚ï¿½ï¿½ï¿½
		bone.fbxCluster = fbxCluster;
		//FBXï¿½ï¿½ï¿½ç‰ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½sï¿½ï¿½ï¿½ï¿½æ“¾ï¿½ï¿½ï¿½ï¿½
		FbxAMatrix fbxMat;
		fbxCluster->GetTransformLinkMatrix(fbxMat);
		//Matrix4ï¿½^ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½
		Matrix4 initialPose;
		ConvertMatrixFromFbx(initialPose, fbxMat);
		//ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½sï¿½ï¿½Ì‹tï¿½sï¿½ï¿½ð“¾‚ï¿½
		bone.inInitialPose.MakeInverse();
	}
	//ï¿½{ï¿½[ï¿½ï¿½ï¿½Ôï¿½ï¿½ÆƒXï¿½Lï¿½ï¿½ï¿½Eï¿½Fï¿½Cï¿½gï¿½Ìƒyï¿½A
	struct WeightSet {
		UINT index;
		float weight;
	};

	//ï¿½ñŽŸŒï¿½ï¿½zï¿½ï¿½(ï¿½Wï¿½ï¿½ï¿½Oï¿½zï¿½ï¿½)
	//list:ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½ó‚¯‚ï¿½{ï¿½[ï¿½ï¿½ï¿½Ì‘Sï¿½ï¿½ï¿½Xï¿½g
	//vector:ï¿½ï¿½ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½_ï¿½ï¿½
	std::vector<std::list<WeightSet>>
	weightLists(model->vertices.size());
	//ï¿½Sï¿½Ä‚Ìƒ{ï¿½[ï¿½ï¿½ï¿½É‚Â‚ï¿½ï¿½ï¿½
	for (int i = 0; i < clusterCount; i++) {
		FbxCluster* fbxCluster = fbxSkin->GetCluster(i);
		//ï¿½ï¿½ï¿½Ìƒ{ï¿½[ï¿½ï¿½ï¿½É‰eï¿½ï¿½ï¿½ï¿½ï¿½ó‚¯‚é’¸ï¿½_
		int controlPointIndicesCount = fbxCluster->GetControlPointIndicesCount();
		//ï¿½ï¿½ï¿½Ìƒ{ï¿½[ï¿½ï¿½ï¿½É‰eï¿½ï¿½ï¿½ï¿½ï¿½ó‚¯‚é’¸ï¿½_ï¿½Ì”zï¿½ï¿½
		int* controlPointIndices = fbxCluster->GetControlPointIndices();
		double* controlPointWeights = fbxCluster->GetControlPointWeights();
		//ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½ó‚¯‚ï¿½Sï¿½ï¿½ï¿½_ï¿½É‚Â‚ï¿½ï¿½ï¿½
		for (int j = 0; j < controlPointIndicesCount; j++) {
			int vertIndex = controlPointIndices[j];
			//ï¿½Xï¿½Lï¿½ï¿½ï¿½Eï¿½Fï¿½Cï¿½g
			float weight = (float)controlPointWeights[j];
			//ï¿½ï¿½ï¿½Ì’ï¿½ï¿½_ï¿½Ì‰eï¿½ï¿½ï¿½ï¿½ï¿½ó‚¯‚ï¿½{ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½gï¿½Éƒ{ï¿½[ï¿½ï¿½ï¿½ÆƒEï¿½Fï¿½Cï¿½gï¿½Ìƒyï¿½Aï¿½ï¿½Ç‰ï¿½
			weightLists[vertIndex].emplace_back(WeightSet{ (UINT)i,weight });
		}

		auto& vertices = model->vertices;
		for (int i = 0; i < vertices.size(); i++) {
			auto& weightList = weightLists[i];
			weightList.sort([](auto const& lhs, auto const& rhs) {
			//ï¿½ï¿½ï¿½Ì—vï¿½fï¿½Ì•ï¿½ï¿½ï¿½ï¿½å‚«ï¿½ï¿½ï¿½ï¿½ï¿½true ï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½falseï¿½ï¿½Ô‚ï¿½
			return lhs.weight > rhs.weight;
			});

			int weightArrayIndex = 0;
			//ï¿½~ï¿½ï¿½ï¿½\ï¿½[ï¿½gï¿½Ï‚Ý‚ÌƒEï¿½Fï¿½Cï¿½gï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½ï¿½
			for (auto& weightSet : weightList) {
				vertices[i].boneIndex[weightArrayIndex] = weightSet.index;
				vertices[i].boneWeight[weightArrayIndex] = weightSet.weight;
				//4ï¿½Â‚É’Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Iï¿½ï¿½
				if (++weightArrayIndex >= FbxModel::MAX_BONE_INDICES) {
					float weight = 0.0f;
					//2ï¿½Ô–ÚˆÈ~ï¿½ÌƒEï¿½Fï¿½Cï¿½gï¿½ï¿½ï¿½ï¿½ï¿½v
					for (int j = 1; j < FbxModel::MAX_BONE_INDICES; j++) {
						weight += vertices[i].boneWeight[j];
					}
					//ï¿½ï¿½ï¿½vï¿½ï¿½1.0f(100%)ï¿½É‚È‚ï¿½æ‚¤ï¿½É’ï¿½ï¿½ï¿½
					vertices[i].boneWeight[0] = 1.0f - weight;
					break;
				}
			}
		}
	}
}

============================================================
File Path: engine/3d/FbxLoader.h
============================================================
#pragma once
#pragma warning(push)
#pragma	warning(disable:26495)
#pragma	warning(disable:26451)
#include <fbxsdk.h>
#pragma warning(pop)

#include "d3d12.h"
#include "d3dx12.h"
#include <string>
#include "FbxModel.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma	warning(disable:26813)
#include "DirectXTex.h"
#pragma warning(pop)

class FbxLoader {
	//ï¿½Gï¿½Cï¿½ï¿½ï¿½Aï¿½X
private:
	using string = std::string;

public:
	//ï¿½Vï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½ÌŽæ“¾
	//<return>ï¿½Cï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½X</return>
	static FbxLoader* GetInstance();

	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize(ID3D12Device* device);

	//fbxï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	FbxModel* LoadModelFlomFile(const string& modelName);

	//ï¿½mï¿½[ï¿½hï¿½ï¿½ï¿½
	void ParseNodeRecursive(FbxModel* model, FbxNode* fbxNode,Node* parent = nullptr);

	//ï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½
	void ParseMesh(FbxModel* model, FbxNode* fbxNode);
	//ï¿½Tï¿½u
	void ParseMeshVertices(FbxModel* model, FbxMesh* fbxMesh);
	void ParseMeshFaces(FbxModel* model, FbxMesh* fbxMesh);
	void ParseMatrial(FbxModel* model, FbxNode* fbxNode);
	void LoadTexture(FbxModel* model, const std::string& fullPath);

	static void ConvertMatrixFromFbx(Matrix4 dst, const FbxAMatrix& src);

	//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½o
	std::string ExtracFileName(const std::string& path);

	//ï¿½ï¿½nï¿½ï¿½
	void Finalize();

	//ï¿½Xï¿½Lï¿½jï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½Ì“Ç‚ÝŽï¿½ï¿½
	void ParseSkin(FbxModel* model, FbxMesh* fbxMesh);

private:
	//D3D12ï¿½fï¿½oï¿½Cï¿½X
	ID3D12Device* device = nullptr;
	//FBXï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½[
	FbxManager* fbxManager = nullptr;
	//FBXï¿½Cï¿½ï¿½ï¿½|ï¿½[ï¿½^ï¿½[
	FbxImporter* fbxImporter = nullptr;

private:
	//privateï¿½ÈƒRï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	FbxLoader() = default;
	//privateï¿½Èƒfï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	~FbxLoader() = default;
	//ï¿½Rï¿½sï¿½[ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^ï¿½ï¿½ï¿½ÖŽ~
	FbxLoader(const FbxLoader& obj) = delete;
	//ï¿½Rï¿½sï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½ï¿½ï¿½ÖŽ~
	void operator=(const FbxLoader& obj) = delete;

//privateï¿½Ã“Iï¿½Öï¿½
private:
	static const string defaultTextureFileName;
public:
	static const string baseDirectory;
};

============================================================
File Path: engine/3d/FbxModel.cpp
============================================================
#include "FbxModel.h"

FbxModel::~FbxModel() {
	//FBXï¿½Vï¿½[ï¿½ï¿½ï¿½Ì‰ï¿½ï¿½
	fbxScene->Destroy();
}

void FbxModel::CreateBuffers(ID3D12Device* device)
{
	HRESULT result;

	//ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½Sï¿½Ì‚ÌƒTï¿½Cï¿½Y
	UINT sizeVB =
		static_cast<UINT>(sizeof(VertexPosNormalUvSkin) * vertices.size());

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	VertexPosNormalUvSkin* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		std::copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[(VBV)ï¿½Ìï¿½ï¿½ï¿½
	vbView.BufferLocation =
		vertBuff->GetGPUVirtualAddress();
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	//ï¿½ï¿½ï¿½_ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½Sï¿½Ì‚ÌƒTï¿½Cï¿½Y
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	resourceDesc.Width = sizeIB;

	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&indexBuff));
	//ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	unsigned short* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result)) {
		std::copy(indices.begin(), indices.end(), indexMap);
		indexBuff->Unmap(0, nullptr);
	}
	//ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[(IBV)ï¿½Ìì¬
	ibView.BufferLocation =
		indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	ibView.SizeInBytes = sizeIB;

	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½æ‘œï¿½fï¿½[ï¿½^ï¿½ÌŽæ“¾
	const DirectX::Image* img = scratchImg.GetImage(0, 0, 0);
	assert(img);
	//ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metaData.format, metaData.width,
		(UINT)metaData.height, (UINT16)metaData.arraySize,
		(UINT16)metaData.mipLevels);
	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps1 = CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);
	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps1,
		D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr, IID_PPV_ARGS(&texBuff));
	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	result = texBuff->WriteToSubresource(
		0, nullptr,
		img->pixels,
		(UINT)img->rowPitch, (UINT)img->slicePitch);

	//SRVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½[ï¿½qï¿½[ï¿½vï¿½Ìï¿½ï¿½ï¿½
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	descHeapDesc.NumDescriptors = 1;
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeapSRV));
	//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[(SRV)ï¿½ì¬
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	D3D12_RESOURCE_DESC resDesc = texBuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texBuff.Get(),
		&srvDesc, descHeapSRV->GetCPUDescriptorHandleForHeapStart()
	);
}

void FbxModel::Draw(ID3D12GraphicsCommandList* cmdList)
{
	assert(cmdList);
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	//ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->IASetIndexBuffer(&ibView);

	//ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ÌƒZï¿½bï¿½g
	ID3D12DescriptorHeap* ppheaps[] = { descHeapSRV.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppheaps), ppheaps);

	//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootDescriptorTable(3, descHeapSRV->GetGPUDescriptorHandleForHeapStart());
	//ï¿½`ï¿½ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	cmdList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}


============================================================
File Path: engine/3d/FbxModel.h
============================================================
#pragma once
#include <string>
#include <vector>
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#pragma warning(push)
#pragma	warning(disable:26495)
#pragma	warning(disable:26451)
#include <fbxsdk.h>
#pragma warning(pop)

//ï¿½mï¿½[ï¿½h
struct Node {
	//ï¿½ï¿½ï¿½O
	std::string name;
	//ï¿½Xï¿½Pï¿½[ï¿½ï¿½
	Vector4 scaling = { 1,1,1,0 };
	//ï¿½ï¿½]ï¿½p
	Vector4 rotation = { 0,0,0,0 };
	//ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½Ú“ï¿½
	Vector4 translation = { 0,0,0,1 };
	//ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½ÏŒ`ï¿½sï¿½ï¿½
	Matrix4 tranform;
	//ï¿½Oï¿½ï¿½ï¿½[ï¿½oï¿½ï¿½ï¿½ÏŒ`ï¿½sï¿½ï¿½
	Matrix4 globalTransform;
	//ï¿½eï¿½mï¿½[ï¿½h
	Node* parent = nullptr;
};

class FbxModel {
public:
	friend class FbxLoader;
public://ï¿½è”
	//ï¿½{ï¿½[ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½ÌÅ‘å”
	static const int MAX_BONE_INDICES = 4;
//ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X
public:
	struct VertexPosNormalUvSkin {
		Vector3 pos;
		Vector3 normal;
		Vector2 uv;
		UINT boneIndex[MAX_BONE_INDICES];
		float boneWeight[MAX_BONE_INDICES];
	};
	//ï¿½{ï¿½[ï¿½ï¿½
	struct Bone {
		std::string name;
		//ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½Ì‹tï¿½sï¿½ï¿½
		Matrix4 inInitialPose;
		//ï¿½Nï¿½ï¿½ï¿½Xï¿½^ï¿½[
		FbxCluster* fbxCluster;
		//ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
		Bone(const std::string& name) {
			this->name = name;
		}
	};

private://ï¿½Gï¿½Cï¿½ï¿½ï¿½Aï¿½X
	template <class T> using ComPtr =
		Microsoft::WRL::ComPtr<T>;
	//DirectX::ï¿½ï¿½ï¿½È—ï¿½
	using TexMetadata = DirectX::TexMetadata;
	using sSratchImage = DirectX::ScratchImage;
	//std::ï¿½ï¿½ï¿½È—ï¿½
	using string = std::string;
	template <class T> using vector =
		std::vector<T>;
private:
	//ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	std::string name;
	//ï¿½mï¿½[ï¿½hï¿½zï¿½ï¿½
	std::vector<Node> nodes;
	//ï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âƒmï¿½[ï¿½h
	Node* meshNode = nullptr;
	//ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^
	std::vector<VertexPosNormalUvSkin> vertices;
	//ï¿½ï¿½ï¿½_ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½X
	std::vector<unsigned int>indices;
	//ï¿½Aï¿½ï¿½ï¿½rï¿½Gï¿½ï¿½ï¿½g
	Vector3 ambient = { 1,1,1 };
	//ï¿½fï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Y
	Vector3 diffuse = { 1,1,1 };
	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½^ï¿½fï¿½[ï¿½^
	DirectX::TexMetadata metaData = {};
	//ï¿½Xï¿½Nï¿½ï¿½ï¿½bï¿½`ï¿½Cï¿½ï¿½ï¿½[ï¿½W
	DirectX::ScratchImage scratchImg = {};
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> vertBuff;
	//ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> indexBuff;
	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> texBuff;
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[
	D3D12_VERTEX_BUFFER_VIEW vbView = {};
	//ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[
	D3D12_INDEX_BUFFER_VIEW ibView = {};
	//SRVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½[ï¿½qï¿½[ï¿½v
	ComPtr<ID3D12DescriptorHeap> descHeapSRV;
	//ï¿½{ï¿½[ï¿½ï¿½ï¿½zï¿½ï¿½
	std::vector<Bone> bones;
	//FBXï¿½Vï¿½[ï¿½ï¿½
	FbxScene* fbxScene = nullptr;

public://ï¿½Öï¿½
	~FbxModel();
	void CreateBuffers(ID3D12Device* device);
	//ï¿½`ï¿½ï¿½
	void Draw(ID3D12GraphicsCommandList* cmdList);
	//ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½Ì•ÏŒ`ï¿½sï¿½ï¿½æ“¾
	const Matrix4& GetModelTransform() { return meshNode->globalTransform; }
	//getter
	std::vector<Bone>& GetBones() { return bones; }
	FbxScene* GetFbxScene() { return fbxScene; }
};

============================================================
File Path: engine/3d/FbxObject3d.cpp
============================================================
#include "FbxObject3d.h"
#include <d3dcompiler.h>
#pragma comment(lib, "d3dcompiler.lib")

using namespace Microsoft::WRL;

ID3D12Device* FbxObject3d::device = nullptr;
ViewProjection* FbxObject3d::view = nullptr;
ComPtr<ID3D12RootSignature> FbxObject3d::rootsignature;
ComPtr<ID3D12PipelineState> FbxObject3d::pipelinestate;
ID3D12GraphicsCommandList* FbxObject3d::cmdList = nullptr;

void FbxObject3d::CreateGraphicsPipeline()
{

	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> psBlob;	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> errorBlob; // ï¿½Gï¿½ï¿½ï¿½[ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g

	// ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/Shaders/FBXVS.hlsl",	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "vs_5_0",	// ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/Shaders/FBXPS.hlsl",	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "ps_5_0",	// ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½g
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyï¿½ï¿½ï¿½W(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // uvï¿½ï¿½ï¿½W(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½Xï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ì—ï¿½ï¿½ï¿½ï¿½Ý’ï¿½
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½}ï¿½Xï¿½N
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // ï¿½Wï¿½ï¿½ï¿½Ý’ï¿½
	// ï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Cï¿½Uï¿½Xï¿½eï¿½[ï¿½g
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// ï¿½fï¿½vï¿½Xï¿½Xï¿½eï¿½ï¿½ï¿½Vï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½g
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);

	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½Ìƒuï¿½ï¿½ï¿½ï¿½ï¿½hï¿½Ý’ï¿½
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAï¿½Sï¿½Ä‚Ìƒ`ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½hï¿½Xï¿½eï¿½[ï¿½gï¿½ÌÝ’ï¿½
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// ï¿½[ï¿½xï¿½oï¿½bï¿½tï¿½@ï¿½Ìƒtï¿½Hï¿½[ï¿½}ï¿½bï¿½g
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½gï¿½ÌÝ’ï¿½
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// ï¿½}ï¿½`ï¿½ÌŒ`ï¿½ï¿½Ý’ï¿½iï¿½Oï¿½pï¿½`ï¿½j
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	gpipeline.NumRenderTargets = 1;	// ï¿½`ï¿½ï¿½ÎÛ‚ï¿½1ï¿½ï¿½
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï¿½`255ï¿½wï¿½ï¿½ï¿½RGBA
	gpipeline.SampleDesc.Count = 1; // 1ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½É‚Â‚ï¿½1ï¿½ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½O

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½W
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 ï¿½ï¿½ï¿½Wï¿½Xï¿½^

	// ï¿½ï¿½ï¿½[ï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^
	#pragma warning(push)
	#pragma	warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[4];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsConstantBufferView(1, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[2].InitAsConstantBufferView(2, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[3].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// ï¿½Xï¿½^ï¿½eï¿½Bï¿½bï¿½Nï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½[
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// ï¿½oï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÌƒVï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Cï¿½Y
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½Xï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}

void FbxObject3d::Initialize()
{
	HRESULT result;
	//ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
		// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataTransform) + 0xff) & ~0xff);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffTransform)
	);

	worldTransform.Initialize();
}

void FbxObject3d::Update()
{
	// ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½gï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½tï¿½Hï¿½[ï¿½ï¿½ï¿½Ìsï¿½ï¿½Xï¿½Vï¿½Æ“]ï¿½ï¿½
	worldTransform.UpdateMatrix();
}

void FbxObject3d::Draw(ViewProjection* viewProjection)
{
		// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device);
	assert(FbxObject3d::cmdList);

	// ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½gï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½Î•`ï¿½ï¿½ï¿½ï¿½Xï¿½Lï¿½bï¿½v
	if (model == nullptr) return;

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform.GetBuff()->GetGPUVirtualAddress());

	// ï¿½rï¿½ï¿½ï¿½[ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½ÏŠï¿½ï¿½fï¿½[ï¿½^ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());
	// ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½
	model->Draw(cmdList);
}

void FbxObject3d::StaticInitialize(ID3D12Device* device)
{
	// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device);

	FbxObject3d::device = device;

	// ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½gï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½tï¿½Hï¿½[ï¿½ï¿½ï¿½Éƒfï¿½oï¿½Cï¿½Xï¿½ï¿½Ý‚ï¿½
	WorldTransform::StaticInitialize(device);
}

void FbxObject3d::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	// PreDrawï¿½ï¿½PostDrawï¿½ï¿½ï¿½yï¿½Aï¿½ÅŒÄ‚Î‚ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½ÎƒGï¿½ï¿½ï¿½[
	assert(FbxObject3d::cmdList == nullptr);

	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Zï¿½bï¿½g
	FbxObject3d::cmdList = cmdList;


	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½ÌÝ’ï¿½
	cmdList->SetPipelineState(pipelinestate.Get());
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// ï¿½vï¿½ï¿½ï¿½~ï¿½eï¿½Bï¿½uï¿½`ï¿½ï¿½ï¿½Ý’ï¿½
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

}

void FbxObject3d::PostDraw()
{
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	FbxObject3d::cmdList = nullptr;
}

============================================================
File Path: engine/3d/FbxObject3d.h
============================================================
#pragma once

#include "FbxModel.h"
#include "ViewProjection.h"
#include "WorldTransform.h"
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#include <string>

class FbxObject3d {
protected://ï¿½Gï¿½Cï¿½ï¿½ï¿½Aï¿½X
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
public:
	static void StaticInitialize(ID3D12Device* device);
	static void SetCamera(ViewProjection* view_) { FbxObject3d::view = view_; }

	/// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);
	/// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	static void PostDraw();
	
	static void CreateGraphicsPipeline();
private://ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	static ID3D12Device* device;
	static ViewProjection* view;
public://ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X
	struct ConstBufferDataTransform {
		Matrix4 viewproj;
		Matrix4 world;
		Vector3 cameraPos;
	};
public://ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	void Initialize();

	void Update();

	void SetModel(FbxModel* model) { this->model = model; }

	void Draw(ViewProjection* viewProjection);

	const Vector3& GetPosition() const { return worldTransform.position_; }
	void SetPosition(const Vector3& position) { this->worldTransform.position_ = position; }
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Ì‘å‚«ï¿½ï¿½
	void SetScale(const Vector3& scale) { this->worldTransform.scale_ = scale; }
	const Vector3& GetScale() const { return worldTransform.scale_; }
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Ì‰ï¿½]
	void SetRotation(const Vector3& rotation) { this->worldTransform.rotation_ = rotation; }
	const Vector3& GetRotation() const { return worldTransform.rotation_; }

protected://ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	ComPtr<ID3D12Resource> constBuffTransform;
private:
	static ComPtr<ID3D12RootSignature> rootsignature;
	static ComPtr<ID3D12PipelineState> pipelinestate;
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½g
	static ID3D12GraphicsCommandList* cmdList;

	WorldTransform worldTransform;
	FbxModel* model = nullptr;
};

============================================================
File Path: engine/3d/Model.cpp
============================================================
#include "Model.h"

#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <fstream>
#include <sstream>
#include <vector>
#include <cassert>

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;

// ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½ÌŽï¿½ï¿½ï¿½
ID3D12Device* Model::device = nullptr;

Model* Model::LoadFromOBJ(const string& modelname, const string& texname)
{
	// ï¿½Vï¿½ï¿½ï¿½ï¿½Modelï¿½^ï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½Ìƒï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½
	Model* model = new Model();

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìï¿½ï¿½ï¿½
	model->InitializeDescriptorHeap();

	// OBJï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	model->LoadFromOBJInternal(modelname);

	// ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	model->CreateBuffers();

	//model->LoadTexture(texname);
	
	return model;
}

void Model::LoadMaterial(const std::string& directoryPath, const std::string& filename)
{
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½
	std::ifstream file;
	// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½
	file.open(directoryPath + filename);
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Iï¿½[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	if (file.fail()) {
		assert(0);
	}

	// 1ï¿½sï¿½ï¿½ï¿½Â“Ç‚Ýï¿½ï¿½ï¿½
	string line;
	while (getline(file, line)) {
		// 1ï¿½sï¿½ï¿½ï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½É•ÏŠï¿½
		std::istringstream line_stream(line);

		// ï¿½ï¿½ï¿½pï¿½Xï¿½yï¿½[ï¿½Xï¿½ï¿½Ø‚ï¿½Åsï¿½Ìæ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
		string key;
		getline(line_stream, key, ' ');

		// ï¿½æ“ªï¿½Ìƒ^ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½Í–ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		if (key[0] == '\t')
		{
			key.erase(key.begin()); // ï¿½æ“ªï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½íœ
		}
		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½newmtlï¿½È‚ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½
		if (key == "newmtl")
		{
			// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			line_stream >> material.name;
		}
		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Kaï¿½È‚ï¿½Aï¿½ï¿½ï¿½rï¿½Gï¿½ï¿½ï¿½gï¿½F
		if (key == "Ka")
		{
			line_stream >> material.ambient.x;
			line_stream >> material.ambient.y;
			line_stream >> material.ambient.z;
		}
		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Kdï¿½È‚ï¿½fï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Yï¿½F
		if (key == "Kd")
		{
			line_stream >> material.diffuse.x;
			line_stream >> material.diffuse.y;
			line_stream >> material.diffuse.z;
		}
		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ksï¿½È‚ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½F
		if (key == "Ks")
		{
			line_stream >> material.specular.x;
			line_stream >> material.specular.y;
			line_stream >> material.specular.z;
		}
		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½map_Kdï¿½È‚ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		if (key == "map_Kd") {
			// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ìƒtï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			line_stream >> material.textureFilename;
			// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			LoadTexture(directoryPath, material.textureFilename);
		}
	}
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½Â‚ï¿½ï¿½ï¿½
	file.close();
}

void Model::LoadTexture(const std::string& directoryPath, const std::string& filename)
{
	HRESULT result = S_FALSE;

	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½pï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	string filepath = directoryPath + filename;

	// ï¿½ï¿½ï¿½jï¿½Rï¿½[ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½
	wchar_t wfilepath[128];
	int iBufferSize = MultiByteToWideChar(CP_ACP, 0, filepath.c_str(), -1, wfilepath, _countof(wfilepath));
#pragma warning(push)
#pragma warning(disable:6054)
#pragma warning(disable:6001)
	result = LoadFromWICFile(
		wfilepath, WIC_FLAGS_NONE,
		&metadata, scratchImg
	);
	assert(SUCCEEDED(result));
#pragma warning(pop)

	ScratchImage mipChain{};
	// ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½ï¿½
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// ï¿½Ç‚Ýï¿½ï¿½ñ‚¾ƒfï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Yï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½SRGBï¿½Æ‚ï¿½ï¿½Äˆï¿½ï¿½ï¿½
	metadata.format = MakeSRGB(metadata.format);

	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½wï¿½ï¿½
		nullptr, IID_PPV_ARGS(&texbuff));
	assert(SUCCEEDED(result));

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½ï¿½o
		result = texbuff->WriteToSubresource(
			(UINT)i,
			nullptr,              // ï¿½Sï¿½Ìˆï¿½ÖƒRï¿½sï¿½[
			img->pixels,          // ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½Aï¿½hï¿½ï¿½ï¿½X
			(UINT)img->rowPitch,  // 1ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Tï¿½Cï¿½Y
			(UINT)img->slicePitch // 1ï¿½ï¿½ï¿½Tï¿½Cï¿½Y
		);
		assert(SUCCEEDED(result));
	}

	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ì¬
	cpuDescHandleSRV = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);
	gpuDescHandleSRV = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // ï¿½Ý’ï¿½\ï¿½ï¿½ï¿½ï¿½
	D3D12_RESOURCE_DESC resDesc = texbuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2Dï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texbuff.Get(), //ï¿½rï¿½ï¿½ï¿½[ï¿½ÆŠÖ˜Aï¿½tï¿½ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
		&srvDesc, //ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ý’ï¿½ï¿½ï¿½
		cpuDescHandleSRV
	);

}

void Model::LoadTexture(const std::string& filename)
{
	HRESULT result = S_FALSE;

	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½pï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	string filepath = filename;

	// ï¿½ï¿½ï¿½jï¿½Rï¿½[ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½
	wchar_t wfilepath[128];
	int iBufferSize = MultiByteToWideChar(CP_ACP, 0, filepath.c_str(), -1, wfilepath, _countof(wfilepath));

	result = LoadFromWICFile(
		wfilepath, WIC_FLAGS_NONE,
		&metadata, scratchImg
	);
	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	// ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½ï¿½
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// ï¿½Ç‚Ýï¿½ï¿½ñ‚¾ƒfï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Yï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½SRGBï¿½Æ‚ï¿½ï¿½Äˆï¿½ï¿½ï¿½
	metadata.format = MakeSRGB(metadata.format);

	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½wï¿½ï¿½
		nullptr, IID_PPV_ARGS(&texbuff));
	assert(SUCCEEDED(result));

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½ï¿½o
		result = texbuff->WriteToSubresource(
			(UINT)i,
			nullptr,              // ï¿½Sï¿½Ìˆï¿½ÖƒRï¿½sï¿½[
			img->pixels,          // ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½Aï¿½hï¿½ï¿½ï¿½X
			(UINT)img->rowPitch,  // 1ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Tï¿½Cï¿½Y
			(UINT)img->slicePitch // 1ï¿½ï¿½ï¿½Tï¿½Cï¿½Y
		);
		assert(SUCCEEDED(result));
	}

	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ì¬
	cpuDescHandleSRV = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);
	gpuDescHandleSRV = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // ï¿½Ý’ï¿½\ï¿½ï¿½ï¿½ï¿½
	D3D12_RESOURCE_DESC resDesc = texbuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2Dï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texbuff.Get(), //ï¿½rï¿½ï¿½ï¿½[ï¿½ÆŠÖ˜Aï¿½tï¿½ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
		&srvDesc, //ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ý’ï¿½ï¿½ï¿½
		cpuDescHandleSRV
	);

}

void Model::Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndexMaterial,float alpha_)
{
	// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device);
	assert(cmdList);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½ÌÝ’ï¿½
	cmdList->IASetVertexBuffers(0, 1, &vbView);
	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½ÌÝ’ï¿½
	cmdList->IASetIndexBuffer(&ibView);
	//alphaï¿½lï¿½Ý’ï¿½
	SetAlpha(alpha_);
	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootConstantBufferView(rootParamIndexMaterial,
		constBuffB1->GetGPUVirtualAddress());

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ì”zï¿½ï¿½
	ID3D12DescriptorHeap* ppHeaps[] = { descHeap.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	if (material.textureFilename.size() > 0) {
		// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
		cmdList->SetGraphicsRootDescriptorTable(3, gpuDescHandleSRV);
	}

	// ï¿½`ï¿½ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	cmdList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}

void Model::LoadFromOBJInternal(const string& modelname)
{
	HRESULT result = S_FALSE;

	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½
	std::ifstream file;
	// .objï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½
	const string filename = modelname + ".obj"; // "modelname.obj"
	const string directoryPath = "Resources/" + modelname + "/"; // "Resources/modelname/"
	file.open(directoryPath + filename); // "Resources/modelname.obj"
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Iï¿½[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	if (file.fail()) {
		assert(0);
	}
	vector<Vector3> positions; // ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½W
	vector<Vector3> normals;   // ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½

	vector<Vector2> texcoords; // ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½UV
	// ï¿½Pï¿½sï¿½ï¿½ï¿½Â“Ç‚Ýï¿½ï¿½ï¿½
	string line;
	while (getline(file, line)) {

		// ï¿½Pï¿½sï¿½ï¿½ï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½Ä‰ï¿½Í‚ï¿½ï¿½â‚·ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		std::istringstream line_stream(line);

		// ï¿½ï¿½ï¿½pï¿½Xï¿½pï¿½[ï¿½Xï¿½ï¿½Ø‚ï¿½Åsï¿½Ìæ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
		string key;
		getline(line_stream, key, ' ');

		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ñ‚ª‚ï¿½ï¿½È‚ç’¸ï¿½_ï¿½ï¿½ï¿½W
		if (key == "v") {
			// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
			positions.emplace_back(position);
			// ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
			/*VertexPosNormalUvSkin vertex{};
			vertex.pos = position;
			vertices.emplace_back(vertex);*/
		}

		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ñ‚ª‚ï¿½ï¿½È‚ï¿½|ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½iï¿½Oï¿½pï¿½`ï¿½j
		if (key == "f") {
			// ï¿½ï¿½ï¿½pï¿½Xï¿½yï¿½[ï¿½Xï¿½ï¿½Ø‚ï¿½Åsï¿½Ì‘ï¿½ï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			string index_string;
			while (getline(line_stream, index_string, ' ')) {
				// ï¿½ï¿½ï¿½_ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½Pï¿½Â•ï¿½ï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½Ä‰ï¿½Í‚ï¿½ï¿½â‚·ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
				std::istringstream index_stream(index_string);
				unsigned short indexPosition, indexNormal, indexTexcoord;
				index_stream >> indexPosition;
				index_stream.seekg(1, ios_base::cur); // ï¿½Xï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½Î‚ï¿½
				index_stream >> indexTexcoord;
				index_stream.seekg(1, ios_base::cur); // ï¿½Xï¿½ï¿½ï¿½bï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½Î‚ï¿½
				index_stream >> indexNormal;
				// ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½Ì’Ç‰ï¿½
				VertexPosNormalUvSkin vertex{};
				vertex.pos = positions[indexPosition - 1];
				vertex.normal = normals[indexNormal - 1];
				vertex.uv = texcoords[indexTexcoord - 1];
				vertices.emplace_back(vertex);
				// ï¿½ï¿½ï¿½_ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½É’Ç‰ï¿½
				//indices.emplace_back(indexPosition - 1);
				indices.emplace_back((unsigned short)indices.size());
			}
		}

		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vtï¿½È‚ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
		if (key == "vt")
		{
			// U,Vï¿½ï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			Vector2 texcoord{};
			line_stream >> texcoord.x;
			line_stream >> texcoord.y;
			// Vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]
			texcoord.y = 1.0f - texcoord.y;
			// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
			texcoords.emplace_back(texcoord);
		}

		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vnï¿½È‚ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
		if (key == "vn") {
			// X,Y,Zï¿½ï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			Vector3 normal{};
			line_stream >> normal.x;
			line_stream >> normal.y;
			line_stream >> normal.z;
			// ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½eï¿½[ï¿½^ï¿½É’Ç‰ï¿½
			normals.emplace_back(normal);
		}

		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mtllibï¿½È‚ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½
		if (key == "mtllib")
		{
			// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Ìƒtï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			string filename;
			line_stream >> filename;
			// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
			LoadMaterial(directoryPath, filename);
		}
	}
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Æ•Â‚ï¿½ï¿½ï¿½
	file.close();
}

void Model::InitializeDescriptorHeap()
{
	assert(device);

	HRESULT result = S_FALSE;

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ð¶ï¿½	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½çŒ©ï¿½ï¿½ï¿½ï¿½æ‚¤ï¿½ï¿½
	descHeapDesc.NumDescriptors = 1; // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[1ï¿½ï¿½
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap));//ï¿½ï¿½ï¿½ï¿½
	if (FAILED(result)) {
		assert(0);
	}

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½Tï¿½Cï¿½Yï¿½ï¿½ï¿½æ“¾
	descriptorHandleIncrementSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

void Model::CreateBuffers()
{
	HRESULT result = S_FALSE;

	std::vector<VertexPosNormalUvSkin> realVertices;

	/*UINT sizeVB = static_cast<UINT>(sizeof(vertices));*/
	UINT sizeVB = static_cast<UINT>(sizeof(VertexPosNormalUvSkin) * vertices.size());

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	VertexPosNormalUvSkin* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		/*memcpy(vertMap, vertices, sizeof(vertices));*/
		std::copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½Ìì¬
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	/*vbView.SizeInBytes = sizeof(vertices);*/
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	/*UINT sizeIB = static_cast<UINT>(sizeof(indices));*/
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	resourceDesc.Width = sizeIB;

	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&indexBuff));

	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	unsigned short* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result)) {

		// ï¿½Sï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½É‘Î‚ï¿½ï¿½ï¿½
		//for (int i = 0; i < _countof(indices); i++)
		//{
		//	indexMap[i] = indices[i];	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½ï¿½ï¿½Rï¿½sï¿½[
		//}

		std::copy(indices.begin(), indices.end(), indexMap);

		indexBuff->Unmap(0, nullptr);
	}

	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½Ìì¬
	ibView.BufferLocation = indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	/*ibView.SizeInBytes = sizeof(indices);*/
	ibView.SizeInBytes = sizeIB;

	// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps1 = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);

	//HRESULT result;

	resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB1) + 0xff) & ~0xff);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapProps1,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB1)
	);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Öƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	ConstBufferDataB1* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	if (SUCCEEDED(result)) {
		constMap1->ambient = material.ambient;
		constMap1->diffuse = material.diffuse;
		constMap1->specular = material.specular;
		constMap1->alpha = material.alpha;
		constBuffB1->Unmap(0, nullptr);
	}
}

void Model::SetAlpha(float alpha_) {

	HRESULT result = S_FALSE;

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Öƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	ConstBufferDataB1* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	if (SUCCEEDED(result)) {
		constMap1->alpha = alpha_;
		constBuffB1->Unmap(0, nullptr);
	}
}

============================================================
File Path: engine/3d/Model.h
============================================================
#pragma once

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#include <string>
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma warning(disable:26495)
class Model 
{
private: // ï¿½Gï¿½Cï¿½ï¿½ï¿½Aï¿½X
	// Microsoft::WRL::ï¿½ï¿½ï¿½È—ï¿½
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X
	// ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½
	struct VertexPosNormalUvSkin
	{
		Vector3 pos; // xyzï¿½ï¿½ï¿½W
		Vector3 normal; // ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
		Vector2 uv;  // uvï¿½ï¿½ï¿½W
	};

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½pï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½B0
	struct ConstBufferDataB0
	{
		//XMFLOAT4 color;	// ï¿½F (RGBA)
		Matrix4 mat;	// ï¿½Rï¿½cï¿½ÏŠï¿½ï¿½sï¿½ï¿½
	};

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½pï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½B1
	struct ConstBufferDataB1
	{
		Vector3 ambient; // ï¿½Aï¿½ï¿½ï¿½rï¿½Gï¿½ï¿½ï¿½gï¿½Wï¿½ï¿½
		float pad1;       // ï¿½pï¿½fï¿½Bï¿½ï¿½ï¿½O
		Vector3 diffuse; // ï¿½fï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Yï¿½Wï¿½ï¿½
		float pad2;       // ï¿½pï¿½fï¿½Bï¿½ï¿½ï¿½O
		Vector3 specular; // ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½Wï¿½ï¿½
		float alpha;       // ï¿½Aï¿½ï¿½ï¿½tï¿½@
	};

	// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½
	struct Material
	{
		std::string name; // ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½
		Vector3 ambient; // ï¿½Aï¿½ï¿½ï¿½rï¿½Gï¿½ï¿½ï¿½gï¿½eï¿½ï¿½ï¿½x
		Vector3 diffuse; // ï¿½fï¿½Bï¿½tï¿½Fï¿½[ï¿½Yï¿½eï¿½ï¿½ï¿½x
		Vector3 specular;// ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½eï¿½ï¿½ï¿½x
		float alpha;      // ï¿½Aï¿½ï¿½ï¿½tï¿½@
		std::string textureFilename; // ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		// ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
		Material() {
			ambient = { 0.3f,0.3f,0.3f };
			diffuse = { 0.0f,0.0f,0.0f };
			specular = { 0.0f,0.0f,0.0f };
			alpha = 1.0f;
		}
	};

private: // ï¿½è”
	static const int division = 50; // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	static const float radius; // ï¿½ï¿½Ê‚Ì”ï¿½ï¿½a
	static const float prizmHeight; // ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	static const int planeCount = division * 2 + division * 2; // ï¿½Ê‚Ìï¿½
	static const int vertexCount = planeCount * 3; // ï¿½ï¿½ï¿½_ï¿½ï¿½

public: // ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	
	// OBJï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3Dï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	static Model* LoadFromOBJ(const std::string& modelname, const std::string& texname = "Resources");

	// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	void LoadMaterial(const std::string& directoryPath, const std::string& filename);

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	void LoadTexture(const std::string& directoryPath, const std::string& filename);
	void LoadTexture(const std::string& filename = "Resources");

	// ï¿½`ï¿½ï¿½
	/// <param name="cmdList">ï¿½`ï¿½ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½g</param>
	/// <param name="rootParamIndexMaterial">ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½pï¿½ï¿½ï¿½[ï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½Ôï¿½</param>
	void Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndexMaterial,float alpha_ = 1);

	// setter
	static void SetDevice(ID3D12Device* device) { Model::device = device; }

	void SetAlpha(float alpha_);


private: // ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	// ï¿½fï¿½oï¿½Cï¿½X
	static ID3D12Device* device;
	// ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½zï¿½ï¿½
	std::vector<VertexPosNormalUvSkin> vertices;
	// ï¿½ï¿½ï¿½_ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½zï¿½ï¿½
	std::vector<unsigned short> indices;
	// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½
	Material material;
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> texbuff;
	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½v
	ComPtr<ID3D12DescriptorHeap> descHeap;
	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½(CPU)
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuDescHandleSRV;
	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½(CPU)
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuDescHandleSRV;
	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½Tï¿½Cï¿½Y
	UINT descriptorHandleIncrementSize;
	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> vertBuff;
	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> indexBuff;
	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[
	D3D12_VERTEX_BUFFER_VIEW vbView;
	// ï¿½Cï¿½ï¿½ï¿½fï¿½bï¿½Nï¿½Xï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[
	D3D12_INDEX_BUFFER_VIEW ibView;
	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½iï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½j
	ComPtr<ID3D12Resource> constBuffB1; // ï¿½è”ï¿½oï¿½bï¿½tï¿½@

private:// ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// OBJï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½3Dï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½J)
	void LoadFromOBJInternal(const std::string& modelname);

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeDescriptorHeap();

	// ï¿½eï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	void CreateBuffers();

};

============================================================
File Path: engine/3d/Object3d.cpp
============================================================
ï»¿#include "Object3d.h"
#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <fstream>
#include <sstream>
#include <vector>
#include <CollisionManager.h>

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;

/// <summary>
/// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®Ÿä½“
/// </summary>
ID3D12Device* Object3d::device = nullptr;
ID3D12GraphicsCommandList* Object3d::cmdList = nullptr;
ComPtr<ID3D12RootSignature> Object3d::rootsignature;
ComPtr<ID3D12PipelineState> Object3d::pipelinestate;

Object3d::~Object3d()
{
	if (collider)
	{
		//ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã‹ã‚‰ç™»éŒ²ã‚’è§£é™¤ã™ã‚‹
		CollisionManager::GetInstance()->RemoveCollider(collider);

		delete collider;
	}
}

void Object3d::StaticInitialize(ID3D12Device * device, int window_width, int window_height)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);

	Object3d::device = device;

	// ãƒ¢ãƒ‡ãƒ«ã«ãƒ‡ãƒã‚¤ã‚¹ã‚’ã‚»ãƒƒãƒˆ
	Model::SetDevice(device);

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã«ãƒ‡ãƒã‚¤ã‚¹ã‚’è²¸ã™
	WorldTransform::StaticInitialize(device);

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åˆæœŸåŒ–
	InitializeGraphicsPipeline();
}

void Object3d::PreDraw(ID3D12GraphicsCommandList * cmdList)
{
	// PreDrawã¨PostDrawãŒãƒšã‚¢ã§å‘¼ã°ã‚Œã¦ã„ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼
	assert(Object3d::cmdList == nullptr);

	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ã‚»ãƒƒãƒˆ
	Object3d::cmdList = cmdList;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	cmdList->SetPipelineState(pipelinestate.Get());
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã‚’è¨­å®š
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

void Object3d::PostDraw()
{
	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’è§£é™¤
	Object3d::cmdList = nullptr;
}

Object3d * Object3d::Create()
{
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	Object3d* object3d = new Object3d();
	if (object3d == nullptr) {
		return nullptr;
	}

	// åˆæœŸåŒ–
	if (!object3d->Initialize()) {
		delete object3d;
		assert(0);
		return nullptr;
	}


	return object3d;
}

void Object3d::InitializeGraphicsPipeline()
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/OBJVS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/OBJPS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringåž‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // uvåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æµã‚Œã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// ã‚µãƒ³ãƒ—ãƒ«ãƒžã‚¹ã‚¯
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // æ¨™æº–è¨­å®š
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®šï¼ˆä¸‰è§’å½¢ï¼‰
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	gpipeline.NumRenderTargets = 1;	// æç”»å¯¾è±¡ã¯1ã¤
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½ž255æŒ‡å®šã®RGBA
	gpipeline.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›žã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 ãƒ¬ã‚¸ã‚¹ã‚¿

	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	#pragma warning(push)
	#pragma warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[4];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsConstantBufferView(1, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[2].InitAsConstantBufferView(2, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[3].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è‡ªå‹•åˆ¤å®šã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}

bool Object3d::Initialize()
{
	//worldTransformåˆæœŸåŒ–
	worldTransform_.Initialize();

	//ã‚¯ãƒ©ã‚¹åã®æ–‡å­—åˆ—ã‚’å–å¾—
	name = typeid(*this).name();

	isLocked = false;

	return true;
}

void Object3d::Update()
{
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¡Œåˆ—æ›´æ–°ã¨è»¢é€
	worldTransform_.UpdateMatrix();

	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}

}

void Object3d::Draw(ViewProjection* viewProjection)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(Object3d::cmdList);

	// ãƒ¢ãƒ‡ãƒ«ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (model == nullptr) return;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform_.GetBuff()->GetGPUVirtualAddress());

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›ãƒ‡ãƒ¼ã‚¿å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());

	// ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
	model->Draw(cmdList, 2,1);
}

void Object3d::Draw(ViewProjection* viewProjection,float alpha_)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(Object3d::cmdList);
		
	// ãƒ¢ãƒ‡ãƒ«ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (model == nullptr) return;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform_.GetBuff()->GetGPUVirtualAddress());

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›ãƒ‡ãƒ¼ã‚¿å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());

	// ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
	model->Draw(cmdList, 2,alpha_);
}

void Object3d::SetCollider(BaseCollider* collider)
{
	collider->SetObject(this);
	this->collider = collider;
	//ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã«ç™»éŒ²
	CollisionManager::GetInstance()->AddCollider(collider);
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ›´æ–°ã—ã¦ãŠã
	collider->Update();
}

Vector3 Object3d::GetWorldPos() {
	Vector3 worldPos{ 0,0,0 };

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰åº§æ¨™ã‚’å–å¾—
	worldPos.x = worldTransform_.matWorld_.m[3][0];
	worldPos.y = worldTransform_.matWorld_.m[3][1];
	worldPos.z = worldTransform_.matWorld_.m[3][2];

	return worldPos;
}

============================================================
File Path: engine/3d/Object3d.h
============================================================
ï»¿#pragma once

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include <d3dx12.h>
#include <string>
#include "WorldTransform.h"
#include "ViewProjection.h"
#include "Model.h"
#include "CollisionInfo.h"

class BaseCollider;

/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
class Object3d
{
private: // ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	/// é™çš„åˆæœŸåŒ–
	static void StaticInitialize(ID3D12Device* device, int window_width, int window_height);

	/// æç”»å‰å‡¦ç†
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);

	/// æç”»å¾Œå‡¦ç†
	static void PostDraw();

	/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	static Object3d* Create();

private: // é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ‡ãƒã‚¤ã‚¹
	static ID3D12Device* device;
	// ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	static ID3D12GraphicsCommandList* cmdList;
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	static ComPtr<ID3D12RootSignature> rootsignature;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	static ComPtr<ID3D12PipelineState> pipelinestate;

private:// é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°

	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	static void InitializeGraphicsPipeline();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	//ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Object3d() = default;

	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~Object3d();

	//åˆæœŸåŒ–
	virtual bool Initialize();

	/// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†
	virtual void Update();

	/// æç”»
	void Draw(ViewProjection* viewProjection);
	void Draw(ViewProjection* viewProjection, float alpha_);

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®å–å¾—
	const Matrix4& GetMatWorld() { return matWorld; }

	// ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
	void SetModel(Model* model) { this->model = model; }

	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚»ãƒƒãƒˆ
	void SetCollider(BaseCollider* collider);

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	virtual void OnCollision(const CollisionInfo& info) {}
	virtual void OffCollision(const CollisionInfo& info) {}

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åº§æ¨™
	Vector3 GetWorldPos();
	const Vector3& GetPosition() const { return worldTransform_.position_; }
	bool GetIsLocked() { return isLocked; }
	void SetIsLocked(bool isLock) { isLocked = isLock; }
	const float& GetPositionZ() const { return worldTransform_.position_.z; }
	void SetPosition(const Vector3& position) { this->worldTransform_.position_ = position; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤§ãã•
	void SetScale(const Vector3& scale) { this->worldTransform_.scale_ = scale; }
	const Vector3& GetScale() const { return worldTransform_.scale_; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å›žè»¢
	void SetRotation(const Vector3& rotation) { this->worldTransform_.rotation_ = rotation; }
	const Vector3& GetRotation() const { return worldTransform_.rotation_; }
	void SetRotationX(const float& rotation) { this->worldTransform_.rotation_.x = rotation; }
	void SetRotationY(const float& rotation) { this->worldTransform_.rotation_.y = rotation; }

	const char* GetName() const { return name; }
public:
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ãƒ‡ãƒ¼ã‚¿
	WorldTransform worldTransform_;
	const char* toCollisionName = nullptr;

protected: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	//ã‚¯ãƒ©ã‚¹å
	const char* name = nullptr;
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
	BaseCollider* collider = nullptr;
	// ãƒ¢ãƒ‡ãƒ«
	Model* model = nullptr;
	// ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›è¡Œåˆ—
	Matrix4 matWorld;
	//ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool isLocked;
};



============================================================
File Path: engine/3d/Player.cpp
============================================================
#include "Player.h"
#include "string.h"
#include "RailCamera.h"
#include "SphereCollider.h"
#include"Input.h"

//ï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
Player::~Player() {
	delete playerModel;
}

//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
bool Player::PlayerInitialize() {
	if (!Object3d::Initialize()) {
		return false;
	}

	input = Input::GetInstance();
	Initialize();

	// OBJï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	playerModel = Model::LoadFromOBJ("box");
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Create();
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ð‚ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½
	SetModel(playerModel);
	SetPosition(Vector3(0, 0, 500));
	SetRotation(Vector3(0, 270, 0));

	hp = 100;
	coolTime = 0;
	len = 6.0f;
	pTimer = 0;
	isHit = false;
	isShooted = false;
	hitTime = 0;
	alpha = 1.0f;
	energy = 0;
	isUltimate = false;
	ultTime = 0;
	pos_ = { 0,0,0 };
	rot_ = { 0,0,0 };

	return true;
}

void Player::Update(Vector3 velo, std::vector<LockInfo>& info)
{
	if (isShooted == true) {
		isShooted = false;
	}


	Move();
	LockAttack(info);
	Attack(velo);
	//ULT
	if (energy >= 100) {
		if (input->TriggerKey(DIK_Q)) {
			if (isUltimate == false) {
				pos_ = GetPosition();
				rot_ = GetRotation();
				isUltimate = true;
			}
		}
	}
	for (std::unique_ptr<PlayerBullet>& bullet : bullets_) {
		if (bullet->GetIsHoming() == true) {
			bullet->HomingVec(GetWorldPos());
		}
		bullet->Update();
	}
	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½Oï¿½Ì—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½íœ
	bullets_.remove_if([](std::unique_ptr < PlayerBullet>& bullets_) {
		return bullets_->IsDead();
		});

	if (isHit == true) {
		hitTime++;
		if (hitTime == 15) {
			hitTime = 0;
			isHit = false;
		}
	}

	worldTransform_.UpdateMatrix();
	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½Xï¿½V
	if (collider)
	{
		collider->Update();
	}
	if (alpha < 1.0f) {
		alpha += 0.01f;
	}
}

void Player::Move()
{
	move = { 0,0,0 };

	//playerï¿½Ú“ï¿½
	if (input->PushKey(DIK_W)) {
		if (input->PushKey(DIK_A) == true && input->PushKey(DIK_D) == false) {
			move = { -0.03f, 0.03f, 0 };
		}
		else if (input->PushKey(DIK_A) == false && input->PushKey(DIK_D) == true) {
			move = { 0.03f, 0.03f, 0 };
		}
		else {
			move = { 0, 0.04f, 0 };
		}
	}
	else if (input->PushKey(DIK_A)) {
		if (input->PushKey(DIK_S) == true && input->PushKey(DIK_W) == false) {
			move = { -0.03f, -0.03f, 0 };
		}
		else {
			move = { -0.04f, 0, 0 };
		}
	}
	else if (input->PushKey(DIK_D)) {
		if (input->PushKey(DIK_S) == true && input->PushKey(DIK_W) == false) {
			move = { 0.03f, -0.03f, 0 };
		}
		else {
			move = { 0.04f, 0, 0 };
		}
	}
	else if (input->PushKey(DIK_S)) {
		move = { 0, -0.04f, 0 };
	}

	Vector3 floating(0, 0, 0);
	//playerï¿½Ó‚ï¿½Ó‚ï¿½
	if (pTimer < 75) {
		floating += Vector3(0, 0.005f, 0);
	}
	else if (pTimer < 150) {
		floating += Vector3(0, -0.005f, 0);
	}
	else {
		pTimer = 0;
	}

	Vector3 tmp = GetPosition() + move + floating;
	//
	if (abs(tmp.x) <= 3.0f) {
		if (tmp.y >= -1.5f && tmp.y <= 2.0f) {
			if (GetPosition().z < -1.6f) {
				SetPosition(GetPosition() + move + floating + Vector3(0.0f,0.0f,0.05f));
			}
			else {
				SetPosition(GetPosition() + move + floating);
			}
		}
	}
	else {
		move = { 0,0,0 };
	}
	pTimer++;
}

void Player::Attack(Vector3 velo) {
	
	if (Input::GetInstance()->PushMouseLeft()) {
		if (coolTime == 0) {
			//ï¿½eï¿½ð¶ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		//ï¿½ï¿½ï¿½ï¿½
			std::unique_ptr<PlayerBullet> newBullet = std::make_unique<PlayerBullet>();

			//ï¿½Pï¿½ï¿½
			newBullet->BulletInitialize(velo + Vector3(0,0.05f,0));
			newBullet->SetCollider(new SphereCollider());

			//ï¿½eï¿½Ì“oï¿½^
		   //ï¿½ï¿½ï¿½ï¿½
			newBullet->SetPosition(GetWorldPos());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			bullets_.push_back(std::move(newBullet));


			//ï¿½Nï¿½[ï¿½ï¿½ï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½Ý’ï¿½
			coolTime = 6;
		}
		else if (coolTime > 0) {
			coolTime--;
		}

	}
}

void Player::LockAttack(std::vector<LockInfo>& info)
{
	if (Input::GetInstance()->TriggerMouseRight() == true) {
		for (int i = 0; i < info.size(); i++) {
			//ï¿½eï¿½ð¶ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
			std::unique_ptr<PlayerBullet> newBullet = std::make_unique<PlayerBullet>();
			Vector3 shotVec = (info[i].vec - GetWorldPos());
			//ï¿½Pï¿½ï¿½
			newBullet->BulletInitialize(shotVec);
			newBullet->SetCollider(new SphereCollider());

			//ï¿½eï¿½Ì“oï¿½^
		   //ï¿½ï¿½ï¿½ï¿½
			newBullet->SetPosition(GetWorldPos());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			newBullet->SetLock(info[i].obj);
			newBullet->SetisHoming(true);
			bullets_.push_back(std::move(newBullet));
		}
		isShooted = true;
	}
}

void Player::Ultimate()
{
	if (ultTime > 50 && ultTime < 175) {
		SetPosition(GetPosition() + Vector3(0.0f, 0.05f, 0.0f));
	}
	else if (ultTime == 175) {
		ultTime = 0;
		isUltimate = false;
		energy = 0;
	}
	worldTransform_.UpdateMatrix();
	ultTime++;
}

void Player::PlayerDraw(ViewProjection* viewProjection_) {
	if (hitTime % 5 == 0) {
		Draw(viewProjection_,alpha);
	}
	//ï¿½eï¿½`ï¿½ï¿½
	for (std::unique_ptr<PlayerBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}

void Player::BackRail()
{
	SetPosition(pos_);
	SetRotation(rot_);
}

void Player::OnCollision(const CollisionInfo& info)
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	const char* str1 = "class Enemy";
	const char* str2 = "class EnemyBullet";
	const char* str3 = "class BossBullet";
	const char* str4 = "class Energy";

	//ï¿½ï¿½ï¿½è‚ªenemy
	if (strcmp(toCollisionName, str1) == 0) {
	}
	//ï¿½ï¿½ï¿½è‚ªenemyï¿½Ì’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (isHit == false) {
			hp-=10;
			isHit = true;
		}
	}
	//ï¿½ï¿½ï¿½è‚ªbossï¿½Ì’e
	if (strcmp(toCollisionName, str3) == 0) {
		if (isHit == false) {
			hp-=25;
			isHit = true;
		}
	}

	//ï¿½ï¿½ï¿½è‚ªenergy
	if (strcmp(toCollisionName, str4) == 0) {
		if (energy < 100) {
			energy += 5;
		}
	}
}

============================================================
File Path: engine/3d/Player.h
============================================================
ï»¿#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "input.h"
#include "Spline.h"
#include "Model.h"
#include "Particle.h"
#include "PlayerBullet.h"

struct LockInfo {
	Vector3 vec = {0,0,0};
	 Object3d* obj = nullptr;
};

class Player : public Object3d
{
public:
	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Player();
	//åˆæœŸåŒ–
	bool PlayerInitialize();

	void Update(Vector3 velo, std::vector<LockInfo>& info);

	void Move();
	///</summary>
	void Attack(Vector3 velo);
	void LockAttack(std::vector<LockInfo>& info);
	void Ultimate();
	void PlayerDraw(ViewProjection* viewProjection_);
	void BackRail();

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void OnCollision(const CollisionInfo& info) override;


	/////getter/////
	//hp
	float GetHP() { return hp; }
	float GetEnergy() { return energy; }
	bool GetIsHit() { return isHit; }
	bool GetIsShooted() { return isShooted; }
	float GetLen() { return len; }
	bool GetIsUltimate() { return isUltimate; }
	Vector3 GetMove() { return move; }
	//setter
	void SetIsHit(bool isHit_) { isHit = isHit_; }
	void SetAlpha(float a) { alpha = a; }
	void SetIsUltimate(bool ult) { isUltimate = ult; }

	//å¼¾ãƒªã‚¹ãƒˆã‚’å–å¾—
	const std::list<std::unique_ptr<PlayerBullet>>& GetBullets() { return bullets_; }


private:
	Input* input = nullptr;
	// ãƒ¢ãƒ‡ãƒ«
	Model* playerModel = nullptr;
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	Particle* particle = nullptr;
	//å¼¾ 
	std::list<std::unique_ptr<PlayerBullet>> bullets_;
	//HP
	float hp;
	int coolTime = 0;
	float len = 6;
	int pTimer = 0;
	bool isHit;
	bool isShooted;
	int hitTime;
	float alpha;
	float energy;
	bool isUltimate;
	int ultTime;
	Vector3 pos_;
	Vector3 rot_;
	Vector3 move;
};


============================================================
File Path: engine/3d/PlayerBullet.cpp
============================================================
#include "PlayerBullet.h"
#include "BaseCollider.h"

void PlayerBullet::BulletInitialize(const Vector3& velocity) {

	Initialize();

	// OBJï¿½ï¿½ï¿½çƒ‚ï¿½fï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Create();
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Ð‚ï¿½ï¿½tï¿½ï¿½ï¿½ï¿½
	SetModel(bulletModel);

	//ï¿½ï¿½ï¿½ï¿½ï¿½ÅŽó‚¯Žï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½É‘ï¿½ï¿½
	velocity_ = velocity;
}

void PlayerBullet::Update() {

	SetPosition(GetPosition() + velocity_);

	worldTransform_.UpdateMatrix();

	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½Xï¿½V
	if (collider)
	{
		collider->Update();
	}
	//ï¿½ï¿½ï¿½ÔŒoï¿½ß‚Åƒfï¿½X
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}

}

void PlayerBullet::HomingVec(Vector3 pos)
{
	if (isHoming == true) {
		velocity_ = lockObj->GetWorldPos() - GetPosition();
		velocity_ = velocity_ * 0.25f;
	}
}

void PlayerBullet::OnCollision(const CollisionInfo& info)
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½Ì–ï¿½ï¿½O
	const char* str1 = "class Enemy";
	const char* str2 = "class EnemyBullet";
	const char* str3 = "class Boss";
	const char* str4 = "class BossBullet";

	//ï¿½ï¿½ï¿½è‚ªenemy
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

	//ï¿½ï¿½ï¿½è‚ªenemyï¿½Ì’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (isDead_ == false && isHoming == false) {
			isDead_ = true;
		}
	}
	//ï¿½ï¿½ï¿½è‚ªï¿½{ï¿½X
	if (strcmp(toCollisionName, str3) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

	//ï¿½ï¿½ï¿½è‚ªï¿½{ï¿½Xï¿½Ì’e
	if (strcmp(toCollisionName, str4) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

}

============================================================
File Path: engine/3d/PlayerBullet.h
============================================================
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class PlayerBullet : public Object3d 
{
  public:
	///< summary>
	///ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	///</summary>
	void BulletInitialize(const Vector3& velocity);

	///< summary>
	///ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	///</summary>
	void Update();
	void HomingVec(Vector3 pos);


	//ï¿½Õ“Ë‚ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚Ñoï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½[ï¿½ï¿½ï¿½oï¿½bï¿½Nï¿½Öï¿½
	void OnCollision(const CollisionInfo& info) override;


  public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }
	bool GetIsHoming() { return isHoming; }
	void SetisHoming(bool isHoming_) { isHoming = isHoming_; }
	void SetLock(Object3d* obj) { lockObj = obj; }

  private:
	//ï¿½ï¿½ï¿½fï¿½ï¿½
	Model* bulletModel = nullptr;
	
	//ï¿½ï¿½ï¿½x
	Vector3 velocity_;
	
	//ï¿½ï¿½ï¿½ï¿½
	static const int32_t kLifeTime = 60 * 8;
	//ï¿½fï¿½Xï¿½^ï¿½Cï¿½}ï¿½[
	int32_t deathTimer_ = kLifeTime;
	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½O
	bool isDead_ = false;
	bool isHoming = false;
	Object3d* lockObj = nullptr;
};


============================================================
File Path: engine/3d/RailCamera.cpp
============================================================
#include "RailCamera.h"

RailCamera::RailCamera() {
	isEnd = false;
}

RailCamera::~RailCamera() {
	delete viewProjection;
	delete camera;
}

//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
void RailCamera::Initialize(Player* player_) {
	viewProjection = new ViewProjection;
	input = Input::GetInstance();
	viewProjection->Initialize();
	camera = Object3d::Create();
	viewProjection->eye = { 0, 1, 505 };
	viewProjection->target = { 0.3f,0.5f,499 };
	camera->SetPosition({0,0,500});
	camera->SetRotation(Vector3(0, 0, 0));
	SetPlayer(player_);
	oldCamera = { 0,0,0 };
	isEnd = false;
	OnRail = true;
	playerMoveVel = { 0,0,0 };
	cameraDelay = { 0,0,0 };
}

void RailCamera::ViewUpdate() {
	viewProjection->UpdateMatrix();
}

//ï¿½Xï¿½V
void RailCamera::Update(Player* player_, std::vector<Vector3>& point) {

	if (OnRail == true) {
		Vector3 target_ = spline_.Update(point, 0.00001f);
		camera->SetPosition(splineCam.Update(point, 0.0f));
		//ï¿½Åï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½[ï¿½vï¿½Ì‚ÝŒï¿½ï¿½ÝˆÊ’uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		if (oldCamera.x == 0 && oldCamera.y == 0 && oldCamera.z == 0) {
			oldCamera = camera->GetPosition();
		}

		//ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ÌŽæ“¾
		GetVec(camera->GetPosition(), target_);

		//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Éï¿½ï¿½í‚¹ï¿½ï¿½Yï¿½ï¿½ï¿½Ì‰ï¿½]
		float radY = std::atan2(frontVec.x, frontVec.z);
		camera->SetRotationY(radY * 180.0f / 3.1415f);
		//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Éï¿½ï¿½í‚¹ï¿½ï¿½Xï¿½ï¿½ï¿½Ì‰ï¿½]
		Vector3 rotaVec = { frontVec.x,0,frontVec.z };
		float length = rotaVec.length();
		float radX = std::atan2(-frontVec.y, length);
		camera->SetRotationX(radX * 180.0f / 3.1415f);

		if (spline_.GetIsEnd() == true) {
			OnRail = false;
		}
		Vector3 eyeTmp = camera->GetPosition() - frontVec * player_->GetLen();

		//ï¿½Xï¿½V
		camera->Update();
		viewProjection->target = ((target_ + frontVec));
		//playerï¿½ÌˆÚ“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ‚Éƒfï¿½Bï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÄXï¿½V
		viewProjection->eye = ((camera->GetPosition() + cameraDelay) - frontVec * player_->GetLen());
		if (viewProjection->eye.y > (eyeTmp.y + 1)) {
			viewProjection->eye.y += 0.05f;
		}

		viewProjection->UpdateMatrix();
		oldCamera = camera->GetPosition();
	}
	else {
		viewProjection->UpdateMatrix();
		camera->Update();
	}
	//cameraDelay
	playerMoveVel += (player_->GetMove() *= Vector3(1,-1,1));
	//
	if (playerMoveVel.x > 2.0f) {
		playerMoveVel.x = 2.0f;
	}
	else if (playerMoveVel.x < -2.0f) {
		playerMoveVel.x = -2.0f;
	}
	if (playerMoveVel.y > 1.2f) {
		playerMoveVel.y = 1.2f;
	}
	else if (playerMoveVel.y < -1.2f) {
		playerMoveVel.y = -1.2f;
	}
	//
	if (abs((playerMoveVel.x - cameraDelay.x)) > abs(0.05f)) {
		if (playerMoveVel.x > cameraDelay.x) {
			cameraDelay.x += 0.02f;
		}
		else if (playerMoveVel.x < cameraDelay.x) {
			cameraDelay.x += -0.02f;
		}
		else{}
	}
	if (abs((playerMoveVel.y - cameraDelay.y)) > abs(0.05f)) {
		if (playerMoveVel.y > cameraDelay.y) {
			cameraDelay.y += 0.02f;
		}
		else if (playerMoveVel.y < cameraDelay.y) {
			cameraDelay.y += -0.02f;
		}
		else {}
	}

}

void RailCamera::TitleR(Player* player_)
{
	viewProjection->eye.z -= 1.5;
}

void RailCamera::RailReset()
{
	splineCam.Reset();
	spline_.Reset();
}

////////////////////--------ï¿½Nï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½Ö—ï¿½ï¿½Öï¿½--------///////////////////////

//ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
void RailCamera::GetVec(Vector3 a, Vector3 b) {
	Vector3 yTmpVec = { 0, 1, 0 };
	Vector3 frontTmp = { 0, 0, 0 };
	Vector3 a_ = { a.x,a.y,a.z };
	Vector3 b_ = { b.x,b.y,b.z };

	//Yï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	yTmpVec.normalize();
	//ï¿½ï¿½ï¿½Ê‰ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	frontTmp = b_ - a_;
	frontTmp.normalize();
	//ï¿½Eï¿½xï¿½Nï¿½gï¿½ï¿½
	rightVec = yTmpVec.cross(frontTmp);
	rightVec.normalize();
	//ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	leftVec = frontTmp.cross(yTmpVec);
	leftVec.normalize();
	//ï¿½ï¿½ï¿½Êƒxï¿½Nï¿½gï¿½ï¿½(Yï¿½ï¿½ï¿½Wï¿½ï¿½0ï¿½É‚ï¿½ï¿½ï¿½)
	frontVec = rightVec.cross(yTmpVec);
	frontVec.normalize();
}

void RailCamera::SetPlayer(Player* player_) {
	//ï¿½eï¿½qï¿½\ï¿½ï¿½ï¿½ÌƒZï¿½bï¿½g
	player_->worldTransform_.SetParent3d(&camera->worldTransform_);
	//ï¿½gï¿½ï¿½ï¿½]ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½
	player_->SetPosition(Vector3(0, 0, -1.5f));
	player_->SetScale(Vector3(0.3f, 0.3f, 0.3f));
}

void RailCamera::SetEye(Vector3 view) {
	this->viewProjection->eye = view;
	viewProjection->UpdateMatrix();
}

void RailCamera::SetTarget(Vector3 target_)
{
	this->viewProjection->target = target_;
	viewProjection->UpdateMatrix();
}

void RailCamera::ShakeCamera(float x, float y) {

	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½u
	std::random_device seed_gen;
	std::mt19937_64 engine(seed_gen());
	std::uniform_real_distribution<float>dist(x, y);
	std::uniform_real_distribution<float>dist2(x, y);


	viewProjection->eye = viewProjection->eye + Vector3(dist(engine), dist2(engine), dist2(engine));
	viewProjection->UpdateMatrix();
}

============================================================
File Path: engine/3d/RailCamera.h
============================================================
#pragma once
#include "ViewProjection.h"
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "input.h"
#include "Spline.h"
#include "Player.h"

class RailCamera {
public:
	//ï¿½Cï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½X
	RailCamera();
	~RailCamera();
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize(Player* player_);
	//ï¿½Xï¿½V
	void Update(Player* player_, std::vector<Vector3>& point);
	void ViewUpdate();

	void ShakeCamera(float x, float y);

	void TitleR(Player* player_);
	void RailReset();

	//Setter
	void SetPlayer(Player* player_);
	void SetEye(Vector3 view);
	void SetTarget(Vector3 target_);
	void SetOnRail(bool onrail) { OnRail = onrail; }

	//ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	void GetVec(Vector3 a, Vector3 b);

	//Getter
	ViewProjection* GetView() { return viewProjection; }
	bool GetIsEnd() { return isEnd; }
	bool GetOnRail() { return OnRail; }
	Vector3 GetFrontVec() { return frontVec; }
	Object3d* GetCamera() { return camera; }
	Vector3 GetCameraPos() { return camera->worldTransform_.position_; }
	float GetPasPoint() { return splineCam.GetT(); }
private:
	Input* input_ = nullptr;
	ViewProjection* viewProjection = nullptr;
	Object3d* camera = nullptr;
	Input* input = nullptr;

	//ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½
	Spline spline_;
	Spline splineCam;

	Vector3 rightVec = { 0, 0, 0 };
	Vector3 leftVec = { 0, 0, 0 };
	Vector3 frontVec = { 0,0,0 };
	Vector3 oldCamera = { 0,0,0 };

	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½fï¿½Bï¿½ï¿½ï¿½C
	Vector3 playerMoveVel;
	Vector3 cameraDelay;

	//tmp
	Vector3 eyeTmp{};
	Vector3 targetTmp{};

	bool isEnd;
	bool OnRail;
};



============================================================
File Path: engine/3d/ViewProjection.cpp
============================================================
#include "ViewProjection.h"
#include <d3dx12.h>
#include <cassert>
#include "WinApp.h"

Microsoft::WRL::ComPtr<ID3D12Device> ViewProjection::device_ = nullptr;

void ViewProjection::StaticInitialize(ID3D12Device* device)
{
	assert(device);
	device_ = device;
}

void ViewProjection::Initialize()
{
	CreateConstBuffer();
	Map();
	UpdateMatrix();
}

void ViewProjection::SetEye(Vector3 eye_)
{
	eye = eye_;
	UpdateMatrix();
}

void ViewProjection::SetTarget(Vector3 target_)
{
	target = target_;
	UpdateMatrix();
}

void ViewProjection::CreateConstBuffer()
{
	HRESULT result;

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataViewProjection) + 0xff) & ~0xff);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device_->CreateCommittedResource(
		&heapProps, // ï¿½Aï¿½bï¿½vï¿½ï¿½ï¿½[ï¿½hï¿½Â”\
		D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));
}

void ViewProjection::Map()
{
	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Æ‚Ìƒfï¿½[ï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½N
	HRESULT result = constBuff->Map(0, nullptr, (void**)&constMap);
	assert(SUCCEEDED(result));
}

void ViewProjection::UpdateMatrix()
{
	// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½Ìì¬
	matView.ViewMat(eye, target, up);
	// ï¿½Ë‰eï¿½sï¿½ï¿½Ìì¬
	matProjection.ProjectionMat(fovAngleY, aspectRatio, nearZ, farZ);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	constMap->view = matView;
	constMap->projection = matProjection;
	constMap->cameraPos = eye;
}

============================================================
File Path: engine/3d/ViewProjection.h
============================================================
#pragma once
#include"Vector3.h"
#include "Vector4.h"
#include"Matrix4.h"
#include "WinApp.h"
#include<d3d12.h>
#include<wrl.h>

class ViewProjection
{
public:// ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X
	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½pï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½
	struct ConstBufferDataViewProjection {
		Matrix4 view;       // ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½h ï¿½ï¿½ ï¿½rï¿½ï¿½ï¿½[ï¿½ÏŠï¿½ï¿½sï¿½ï¿½
		Matrix4 projection; // ï¿½rï¿½ï¿½ï¿½[ ï¿½ï¿½ ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½ÏŠï¿½ï¿½sï¿½ï¿½
		Vector3 cameraPos;  // ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½iï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Wï¿½j
	};
public:// ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	static void StaticInitialize(ID3D12Device* device);

	/// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize();

	void SetEye(Vector3 eye_);
	Vector3 GetEye() { return eye; }
	void SetTarget(Vector3 terget_);
	Vector3 GetTarget() { return target; }
	Matrix4 GetMatView() { return matView; }
	Matrix4 GetMatProjection() { return matProjection; }


	/// ï¿½sï¿½ï¿½ï¿½ï¿½Xï¿½Vï¿½ï¿½ï¿½ï¿½
	void UpdateMatrix();

	// ï¿½oï¿½bï¿½tï¿½@ï¿½ÌƒQï¿½bï¿½^ï¿½[
	ID3D12Resource* GetBuff() { return constBuff.Get(); }


private:// ï¿½vï¿½ï¿½ï¿½Cï¿½xï¿½[ï¿½gï¿½Öï¿½
	// ï¿½~ï¿½ï¿½ï¿½ï¿½
	const float PI = 3.141592f;

	/// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	void CreateConstBuffer();

	/// ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	void Map();

	// ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½çƒ‰ï¿½Wï¿½Aï¿½ï¿½ï¿½É•ÏŠï¿½
	float ToRadian(float angle) { return angle * (PI / 180); }


public:// ï¿½pï¿½uï¿½ï¿½ï¿½bï¿½Nï¿½Ïï¿½
#pragma region ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½ÌÝ’ï¿½
	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½W
	Vector3 eye = { 0, 5, -10.0f };
	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½W
	Vector3 target = { 0, 0, 0 };
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	Vector3 up = { 0, 1, 0 };
#pragma endregion

#pragma region ï¿½Ë‰eï¿½sï¿½ï¿½ÌÝ’ï¿½
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½p
	float fovAngleY = ToRadian(45.0f);
	// ï¿½rï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½ÌƒAï¿½Xï¿½yï¿½Nï¿½gï¿½ï¿½
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	// ï¿½[ï¿½xï¿½ï¿½ï¿½Eï¿½iï¿½ï¿½Oï¿½ï¿½ï¿½j
	float nearZ = 0.1f;
	// ï¿½[ï¿½xï¿½ï¿½ï¿½Eï¿½iï¿½ï¿½ï¿½ï¿½ï¿½j
	float farZ = 1000.0f;
#pragma endregion

	// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½
	Matrix4 matView;
	// ï¿½Ë‰eï¿½sï¿½ï¿½
	Matrix4 matProjection;

private:// ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½

	// ï¿½fï¿½oï¿½Cï¿½Xï¿½iï¿½Ø‚ï¿½Ä‚ï¿½ï¿½ï¿½j
	static Microsoft::WRL::ComPtr<ID3D12Device> device_;

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@
	Microsoft::WRL::ComPtr<ID3D12Resource> constBuff;

	// ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½Oï¿½Ï‚ÝƒAï¿½hï¿½ï¿½ï¿½X
	ConstBufferDataViewProjection* constMap = nullptr;

};



============================================================
File Path: engine/3d/WorldTransform.cpp
============================================================
#include "WorldTransform.h"
#include<cassert>
#include <d3dx12.h>

Microsoft::WRL::ComPtr<ID3D12Device> WorldTransform::device_ = nullptr;

void WorldTransform::StaticInitialize(ID3D12Device* device)
{
	assert(device);
	device_ = device;
}

void WorldTransform::Initialize()
{
	CreateConstBuffer();
	Map();
	UpdateMatrix();
}

void WorldTransform::CreateConstBuffer()
{
	assert(device_);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB0) + 0xff) & ~0xff);

	HRESULT result;

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device_->CreateCommittedResource(
		&heapProps, // ï¿½Aï¿½bï¿½vï¿½ï¿½ï¿½[ï¿½hï¿½Â”\
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB0));

	assert(SUCCEEDED(result));
}

void WorldTransform::Map()
{
	//ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìƒ}ï¿½bï¿½sï¿½ï¿½ï¿½O
	HRESULT result = constBuffB0->Map(0, nullptr, (void**)&constMap);//ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½O
	assert(SUCCEEDED(result));
}

void WorldTransform::UpdateMatrix()
{

	Matrix4 matScale, matRot, matTrans;
	Matrix4 matRotX, matRotY, matRotZ;

	//ï¿½eï¿½sï¿½ï¿½vï¿½Z
	matScale = Matrix4::identity();
	matScale.scale(scale_);
	matRot = Matrix4::identity();
	matRot *= matRotZ.rotateZ(ToRadian(rotation_.z));
	matRot *= matRotX.rotateX(ToRadian(rotation_.x));
	matRot *= matRotY.rotateY(ToRadian(rotation_.y));
	matTrans = Matrix4::identity();
	matTrans.translate(position_);

	//ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½sï¿½ï¿½Ìï¿½ï¿½ï¿½
	matWorld_ = Matrix4::identity();
	matWorld_ *= matScale;
	matWorld_ *= matRot;
	matWorld_ *= matTrans;

	//ï¿½eï¿½qï¿½\ï¿½ï¿½
	if (parent_ != nullptr) 
	{
		matWorld_ *= parent_->matWorld_;
	}

	//ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½É“]ï¿½ï¿½
	constMap->matWorld = matWorld_;
}


============================================================
File Path: engine/3d/WorldTransform.h
============================================================
#pragma once
#include"Vector3.h"
#include "Vector4.h"
#include"Matrix4.h"
#include<d3d12.h>
#include<wrl.h>

class WorldTransform
{
private:
	// Microsoft::WRL::ï¿½ï¿½ï¿½È—ï¿½
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;


public:// ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X
	//ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½pï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½
	struct ConstBufferDataB0 {
		Matrix4 matWorld;// ï¿½sï¿½ï¿½
	};
public:// ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	static void StaticInitialize(ID3D12Device* device);

	/// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize();

	/// ï¿½sï¿½ï¿½ï¿½ï¿½Xï¿½Vï¿½ï¿½ï¿½ï¿½
	void UpdateMatrix();

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½ÌƒQï¿½bï¿½^ï¿½[
	ID3D12Resource* GetBuff() { return constBuffB0.Get(); }

	/// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	void CreateConstBuffer();

	/// ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	void Map();

	const Vector3& GetPosition()const { return position_; }

	// ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½çƒ‰ï¿½Wï¿½Aï¿½ï¿½ï¿½É•ÏŠï¿½
	float ToRadian(float angle) { return angle * (PI / 180); }

	void SetParent3d(WorldTransform* parent) { this->parent_ = parent; }

public:// ï¿½pï¿½uï¿½ï¿½ï¿½bï¿½Nï¿½Ïï¿½
	// ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½Xï¿½Pï¿½[ï¿½ï¿½
	Vector3 scale_ = { 1.0f, 1.0f, 1.0f };

	// X,Y,Zï¿½ï¿½ï¿½ï¿½ï¿½Ìƒï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½ï¿½]ï¿½p
	Vector3 rotation_ = { 0, 0, 0 };

	// ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½W
	Vector3 position_ = { 0, 0, 0 };

	// ï¿½F
	Vector4 color_ = { 1,1,1,1 };

	// ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½ÏŠï¿½ï¿½sï¿½ï¿½
	Matrix4 matWorld_;

	// ï¿½eï¿½Æ‚È‚éƒï¿½[ï¿½ï¿½ï¿½hï¿½ÏŠï¿½ï¿½Ö‚Ìƒ|ï¿½Cï¿½ï¿½ï¿½^
	const WorldTransform* parent_ = nullptr;

	// ï¿½~ï¿½ï¿½ï¿½ï¿½
	const float PI = 3.141592f;

private:// ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	// ï¿½fï¿½oï¿½Cï¿½X
	static ComPtr<ID3D12Device> device_;

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> constBuffB0;

	// ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½Oï¿½Ï‚ÝƒAï¿½hï¿½ï¿½ï¿½X
	ConstBufferDataB0* constMap = nullptr;
};



============================================================
File Path: engine/3d/XMViewProjection.cpp
============================================================
#include "XMViewProjection.h"
#include "WinApp.h"

using namespace DirectX;
XMViewProjection::XMViewProjection()
{
	// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½Ìï¿½ï¿½ï¿½
	UpdateViewMatrix();

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½eï¿½É‚ï¿½ï¿½Ë‰eï¿½sï¿½ï¿½Ìï¿½ï¿½ï¿½
	UpdateProjectionMatrix();

	matViewProjection_ = matView_ * matProjection_;

}

XMViewProjection::~XMViewProjection()
{
}

void XMViewProjection::Update()
{
	// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½Ìï¿½ï¿½ï¿½
	UpdateViewMatrix();

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½eï¿½É‚ï¿½ï¿½Ë‰eï¿½sï¿½ï¿½Ìï¿½ï¿½ï¿½
	UpdateProjectionMatrix();

	matViewProjection_ = matView_ * matProjection_;
}

void XMViewProjection::UpdateViewMatrix()
{
	// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½ÌXï¿½V
	matView_ = XMMatrixLookAtLH(XMLoadFloat3(&eye_), XMLoadFloat3(&target_), XMLoadFloat3(&up_));
	//ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½W
	XMVECTOR eyePosition = XMLoadFloat3(&eye_);
	//ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½W
	XMVECTOR targetPosition = XMLoadFloat3(&target_);
	//(ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½
	XMVECTOR upVector = XMLoadFloat3(&up_);

	//ï¿½Jï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½)
	XMVECTOR cameraAxisZ = XMVectorSubtract(targetPosition, eyePosition);
	//0ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ÆŒï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ü‚ï¿½È‚ï¿½ï¿½Ì‚Åï¿½ï¿½O
	assert(!XMVector3Equal(cameraAxisZ, XMVectorZero()));
	assert(!XMVector3IsInfinite(cameraAxisZ));
	assert(!XMVector3Equal(upVector, XMVectorZero()));
	assert(!XMVector3IsInfinite(upVector));

	//ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ð³‹Kï¿½ï¿½
	cameraAxisZ = XMVector3Normalize(cameraAxisZ);

	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½ï¿½(ï¿½Eï¿½ï¿½ï¿½ï¿½)
	XMVECTOR cameraAxisX;
	//Xï¿½ï¿½ï¿½Íï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ÌŠOï¿½Ï‚ÅŒï¿½ï¿½Ü‚ï¿½
	cameraAxisX = XMVector3Cross(upVector, cameraAxisZ);
	//ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ð³‹Kï¿½ï¿½
	cameraAxisX = XMVector3Normalize(cameraAxisX);

	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½)
	XMVECTOR cameraAxisY;
	//Yï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ÌŠOï¿½Ï‚ÅŒï¿½ï¿½Ü‚ï¿½
	cameraAxisY = XMVector3Cross(cameraAxisZ, cameraAxisX);

	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½sï¿½ï¿½
	XMMATRIX matCameraRot;
	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Wï¿½nï¿½Ì•ÏŠï¿½ï¿½sï¿½ï¿½
	matCameraRot.r[0] = cameraAxisX;
	matCameraRot.r[1] = cameraAxisY;
	matCameraRot.r[2] = cameraAxisZ;
	matCameraRot.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);

	//ï¿½]ï¿½uï¿½É‚ï¿½ï¿½tï¿½sï¿½ï¿½(ï¿½tï¿½ï¿½])ï¿½ï¿½ï¿½vï¿½Z
	matView_ = XMMatrixTranspose(matCameraRot);

	//ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Wï¿½ï¿½-1ï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½W
	XMVECTOR reverseEyePosition = XMVectorNegate(eyePosition);
	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ÌˆÊ’uï¿½ï¿½ï¿½çƒï¿½[ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½_ï¿½Ö‚Ìƒxï¿½Nï¿½gï¿½ï¿½(ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½n)
	XMVECTOR tX = XMVector3Dot(cameraAxisX, reverseEyePosition);	//Xï¿½ï¿½ï¿½ï¿½
	XMVECTOR tY = XMVector3Dot(cameraAxisY, reverseEyePosition);	//Yï¿½ï¿½ï¿½ï¿½
	XMVECTOR tZ = XMVector3Dot(cameraAxisZ, reverseEyePosition);	//Zï¿½ï¿½ï¿½ï¿½
	//ï¿½ï¿½Â‚Ìƒxï¿½Nï¿½gï¿½ï¿½ï¿½É‚Ü‚Æ‚ß‚ï¿½
	XMVECTOR translation = XMVectorSet(tX.m128_f32[0], tY.m128_f32[1], tZ.m128_f32[2], 1.0f);

	//ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½É•ï¿½ï¿½sï¿½Ú“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ý’ï¿½
	matView_.r[3] = translation;

#pragma region ï¿½Sï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½ÌŒvï¿½Z
	//ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½
	matBillboard_.r[0] = cameraAxisX;
	matBillboard_.r[1] = cameraAxisY;
	matBillboard_.r[2] = cameraAxisZ;
	matBillboard_.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);
#pragma endregion

#pragma region Yï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½ÌŒvï¿½Z
	//ï¿½Jï¿½ï¿½ï¿½ï¿½X,Y,Zï¿½ï¿½
	XMVECTOR yBillCameraAxisX, yBillCameraAxisY, yBillCameraAxisZ;

	//Xï¿½ï¿½ï¿½Í‹ï¿½ï¿½ï¿½
	yBillCameraAxisX = cameraAxisX;
	//Yï¿½ï¿½ï¿½Íƒï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Wï¿½nï¿½ï¿½Yï¿½ï¿½
	yBillCameraAxisY = XMVector3Normalize(upVector);
	//Zï¿½ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½ÌŠOï¿½Ï‚ÅŒï¿½ï¿½Ü‚ï¿½
	yBillCameraAxisZ = XMVector3Cross(yBillCameraAxisX, yBillCameraAxisY);

	//Yï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½
	matBillboardY_.r[0] = yBillCameraAxisX;
	matBillboardY_.r[1] = yBillCameraAxisY;
	matBillboardY_.r[2] = yBillCameraAxisZ;
	matBillboardY_.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);

#pragma endregion

}
void XMViewProjection::UpdateProjectionMatrix()
{
	matProjection_ = XMMatrixPerspectiveFovLH(
		XMConvertToRadians(45.0f),
		(float)WinApp::window_width / WinApp::window_height,
		0.1f, 1000.0f
	);
}
void XMViewProjection::CameraMoveVector(const XMFLOAT3& move)
{
	XMFLOAT3 eye_moved = eye_;
	XMFLOAT3 target_moved = target_;

	eye_moved.x += move.x;
	eye_moved.y += move.y;
	eye_moved.z += move.z;

	target_moved.x += move.x;
	target_moved.y += move.y;
	target_moved.z += move.z;

	SetEye(eye_moved);
	SetTarget(target_moved);
}

void XMViewProjection::CameraMoveVectorEye(const XMFLOAT3& move)
{
	XMFLOAT3 eye_moved = eye_;

	eye_moved.x += move.x;
	eye_moved.y += move.y;
	eye_moved.z += move.z;

	SetEye(eye_moved);
}



void XMViewProjection::SetEye(const XMFLOAT3& eye)
{
	this->eye_ = eye;
}

void XMViewProjection::SetTarget(const XMFLOAT3& target) {
	this->target_ = target;
}

void XMViewProjection::SetUp(const XMFLOAT3& up)
{
	this->up_ = up;
}

============================================================
File Path: engine/3d/XMViewProjection.h
============================================================
#pragma once
#include <DirectXMath.h>
#include <wrl.h>

class XMViewProjection
{
private:
	// Microsoft::WRL::ï¿½ï¿½ï¿½È—ï¿½
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::ï¿½ï¿½ï¿½È—ï¿½
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMMATRIX = DirectX::XMMATRIX;
public:
	XMViewProjection();
	~XMViewProjection();
	//ï¿½Xï¿½V
	void Update();
	//ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½Xï¿½V
	void UpdateViewMatrix();
	//ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½Xï¿½V
	void UpdateProjectionMatrix();
	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Ú“ï¿½
	void CameraMoveVector(const XMFLOAT3& move);
	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Ú“ï¿½
	void CameraMoveVectorEye(const XMFLOAT3& move);

protected:
	// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½
	XMMATRIX matView_ = {};
	// ï¿½Ë‰eï¿½sï¿½ï¿½
	XMMATRIX matProjection_ = {};

	XMMATRIX matViewProjection_ = {};

	// ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½
	XMMATRIX matBillboard_ = {};
	// Yï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½
	XMMATRIX matBillboardY_ = {};
	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½W
	XMFLOAT3 eye_ = { 0.0f, 0.0f, -100.0f };
	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½W
	XMFLOAT3 target_ = { 0.0f,0.0f,0.0f };
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	XMFLOAT3 up_ = { 0.0f,1.0f,0.0f };

public://ï¿½Aï¿½Nï¿½Zï¿½bï¿½T
	//ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½
	const XMMATRIX& GetMatView() { return matView_; }

	//ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½
	const XMMATRIX& GetMatProjection() { return matProjection_; }

	const XMMATRIX& GetMatViewProjection() { return matViewProjection_; }

	//ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½
	const XMMATRIX& GetMatBillboard() { return matBillboard_; }
	const XMMATRIX& GetMatBillboardY() { return matBillboardY_; }

	//ï¿½ï¿½ï¿½_
	const XMFLOAT3& GetEye() { return eye_; }
	void SetEye(const XMFLOAT3& eye);

	//ï¿½ï¿½ï¿½ï¿½ï¿½_
	const XMFLOAT3& GetTarget() { return target_; }
	void SetTarget(const XMFLOAT3& target);

	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	const XMFLOAT3& GetUp() { return up_; }
	void SetUp(const XMFLOAT3& up);
};


============================================================
File Path: engine/base/DirectXCommon.cpp
============================================================
#include "DirectXCommon.h"
#include <vector>
#include <cassert>
#include <vector>
#include <string>

#pragma comment(lib, "d3d12.lib")
#pragma comment(lib, "dxgi.lib")

using namespace Microsoft::WRL;

DirectXCommon* DirectXCommon::GetInstance() 
{
	static DirectXCommon instance;

	return &instance;
}

void DirectXCommon::Initialize(WinApp* winApp) 
{
	// NULLï¿½ï¿½ï¿½o
	assert(winApp);

	// ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½É‹Lï¿½^
	this->winApp = winApp;

	// FPSï¿½Å’è‰ï¿½ï¿½ï¿½ï¿½
	fpsFixed = new FPSFixed();
	fpsFixed->InitializeFixFPS();
	// ï¿½fï¿½oï¿½Cï¿½Xï¿½Ìï¿½ï¿½ï¿½
	InitializeDevice();
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Ö˜Aï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	InitializeCommand();
	// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½[ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	InitializeSwapchain();
	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½rï¿½ï¿½ï¿½[ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	InitializeRenderTargetView();
	// ï¿½[ï¿½xï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	InitializeDepthBuffer();
	// ï¿½tï¿½Fï¿½ï¿½ï¿½Xï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	InitializeFence();
}

void DirectXCommon::InitializeDevice()
{

#ifdef _DEBUG
	// ï¿½fï¿½oï¿½bï¿½Nï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Iï¿½ï¿½ï¿½ï¿½
	ID3D12Debug1* debugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {
		debugController->EnableDebugLayer();
		debugController->SetEnableGPUBasedValidation(TRUE);
	}

#endif

	// DXGIï¿½tï¿½@ï¿½Nï¿½gï¿½ï¿½ï¿½[ï¿½Ìï¿½ï¿½ï¿½
	result = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));
	assert(SUCCEEDED(result));

	// ï¿½Aï¿½_ï¿½vï¿½^ï¿½[ï¿½Ì—ñ‹“—p
	std::vector<IDXGIAdapter4*> adapters;
	// ï¿½ï¿½ï¿½ï¿½ï¿½É“ï¿½ï¿½ï¿½Ì–ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½ÂƒAï¿½_ï¿½vï¿½^ï¿½[ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	IDXGIAdapter4* tmpAdapter = nullptr;

	// ï¿½pï¿½tï¿½Hï¿½[ï¿½}ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½ï¿½ç‡ï¿½ÉAï¿½Sï¿½Ä‚ÌƒAï¿½_ï¿½vï¿½^ï¿½[ï¿½ï¿½ñ‹“‚ï¿½ï¿½ï¿½
	for (UINT i = 0;
		dxgiFactory->EnumAdapterByGpuPreference(i,
			DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE,
			IID_PPV_ARGS(&tmpAdapter)) != DXGI_ERROR_NOT_FOUND;
		i++) {
		// ï¿½ï¿½ï¿½Iï¿½zï¿½ï¿½É’Ç‰ï¿½ï¿½ï¿½ï¿½ï¿½
		adapters.push_back(tmpAdapter);
	}

	// ï¿½Ã“ï¿½ï¿½ÈƒAï¿½_ï¿½vï¿½^ï¿½[ï¿½ï¿½Iï¿½Ê‚ï¿½ï¿½ï¿½
	for (size_t i = 0; i < adapters.size(); i++) {
		DXGI_ADAPTER_DESC3 adapterDesc;
		// ï¿½Aï¿½_ï¿½vï¿½^ï¿½[ï¿½Ìï¿½ï¿½ï¿½ï¿½æ“¾ï¿½ï¿½ï¿½ï¿½
		adapters[i]->GetDesc3(&adapterDesc);

		// ï¿½\ï¿½tï¿½gï¿½Eï¿½Fï¿½Aï¿½fï¿½oï¿½Cï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE)) {
			// ï¿½fï¿½oï¿½Cï¿½Xï¿½ï¿½ï¿½Ì—pï¿½ï¿½ï¿½Äƒï¿½ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
			tmpAdapter = adapters[i];
			break;
		}
	}

	// ï¿½Î‰ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½Ì”zï¿½ï¿½
	D3D_FEATURE_LEVEL levels[] = {
		D3D_FEATURE_LEVEL_12_1,
		D3D_FEATURE_LEVEL_12_0,
		D3D_FEATURE_LEVEL_11_1,
		D3D_FEATURE_LEVEL_11_0,
	};

	D3D_FEATURE_LEVEL featureLevel;

	for (size_t i = 0; i < _countof(levels); i++) {
		// ï¿½Ì—pï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½_ï¿½vï¿½^ï¿½[ï¿½Åƒfï¿½oï¿½Cï¿½Xï¿½ð¶ï¿½
		result = D3D12CreateDevice(tmpAdapter, levels[i],
			IID_PPV_ARGS(&device));
		if (result == S_OK) {
			// ï¿½fï¿½oï¿½Cï¿½Xï¿½ð¶ï¿½ï¿½Å‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Åƒï¿½ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
			featureLevel = levels[i];
			break;
		}
	}

#ifdef _DEBUG
	ComPtr<ID3D12InfoQueue> infoQueue;
	if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true); // ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ÉŽ~ï¿½Ü‚ï¿½

		// ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[
		D3D12_MESSAGE_ID denyIds[] = {
			/*
			* Windows11ï¿½Å‚ï¿½DXGIï¿½fï¿½oï¿½bï¿½Nï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½[ï¿½ï¿½DX12ï¿½fï¿½oï¿½bï¿½Nï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½[ï¿½Ì‘ï¿½ï¿½Ýï¿½pï¿½oï¿½Oï¿½É‚ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½bï¿½Zï¿½[ï¿½W
			* https://stackoverflow.com/questions/69805245/directx-12-application-is-crashing-in-windows-11
			*/
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE
		};
		// ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;
		// ï¿½wï¿½è‚µï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½Ì•\ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½
		infoQueue->PushStorageFilter(&filter);

		//infoQueue->Release();
	}
#endif
}

void DirectXCommon::InitializeCommand()
{
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Aï¿½ï¿½ï¿½Pï¿½[ï¿½^ï¿½[ï¿½ð¶ï¿½
	result = device->CreateCommandAllocator(
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		IID_PPV_ARGS(&commandAllocator));
	assert(SUCCEEDED(result));

	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ð¶ï¿½
	result = device->CreateCommandList(0,
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		commandAllocator.Get(), nullptr,
		IID_PPV_ARGS(&commandList));
	assert(SUCCEEDED(result));

	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Lï¿½ï¿½ï¿½[ï¿½ÌÝ’ï¿½
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};

	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Lï¿½ï¿½ï¿½[ï¿½ð¶ï¿½
	result = device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&commandQueue));
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeSwapchain()
{
	// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½[ï¿½ï¿½ï¿½ÌÝ’ï¿½
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
	swapChainDesc.Width = 1280;
	swapChainDesc.Height = 720;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//ï¿½Fï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	swapChainDesc.SampleDesc.Count = 1;//ï¿½}ï¿½ï¿½ï¿½`ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½
	swapChainDesc.BufferUsage = DXGI_USAGE_BACK_BUFFER;//ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@ï¿½p
	swapChainDesc.BufferCount = 2;//ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½2ï¿½Â‚ÉÝ’ï¿½
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;// ï¿½tï¿½ï¿½ï¿½bï¿½vï¿½pï¿½Í”jï¿½ï¿½
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// IDXGISwapChain1ï¿½ï¿½Comptrï¿½ï¿½pï¿½ï¿½
	ComPtr<IDXGISwapChain1> swapChain1;

	// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½[ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	result = dxgiFactory->CreateSwapChainForHwnd(
		commandQueue.Get(), winApp->GetHwnd(), &swapChainDesc, nullptr, nullptr,
		&swapChain1
	);
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½IDXGISwapChain1ï¿½ÌƒIï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½IDXGISwapChain4ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½
	swapChain1.As(&swapChain);
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeRenderTargetView()
{
	DXGI_SWAP_CHAIN_DESC swcDesc = {};
    result = swapChain->GetDesc(&swcDesc);
    assert(SUCCEEDED(result));

	// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½[ï¿½ï¿½ï¿½ÌÝ’ï¿½
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
	swapChainDesc.Width = 1280;
	swapChainDesc.Height = 720;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;// ï¿½Fï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	swapChainDesc.SampleDesc.Count = 1;// ï¿½}ï¿½ï¿½ï¿½`ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½
	swapChainDesc.BufferUsage = DXGI_USAGE_BACK_BUFFER;// ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@ï¿½p
	swapChainDesc.BufferCount = 2;// ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½2ï¿½Â‚ÉÝ’ï¿½
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;// ï¿½tï¿½ï¿½ï¿½bï¿½vï¿½pï¿½Í”jï¿½ï¿½
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ÌÝ’ï¿½
	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc{};
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;//ï¿½ï¿½ï¿½ï¿½ï¿½Qï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[
	rtvHeapDesc.NumDescriptors = swapChainDesc.BufferCount;//ï¿½ï¿½ï¿½\ï¿½ï¿½2ï¿½ï¿½

	rtvHD = device->GetDescriptorHandleIncrementSize(rtvHeapDesc.Type);

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìï¿½ï¿½ï¿½
	device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&rtvHeap));

	// ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@
	backBuffers.resize(swapChainDesc.BufferCount);

	// ï¿½ï¿½ï¿½\ï¿½ï¿½2ï¿½Â•ï¿½
	for (int i = 0; i < 2; i++) {
		// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½[ï¿½ï¿½ï¿½Ì‘Sï¿½Ä‚Ìƒoï¿½bï¿½tï¿½@ï¿½É‚Â‚ï¿½ï¿½Äï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		for (size_t i = 0; i < backBuffers.size(); i++) {
			// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½æ“¾
			swapChain->GetBuffer((UINT)i, IID_PPV_ARGS(&backBuffers[i]));
			// ï¿½fï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½æ“¾
			D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = rtvHeap->GetCPUDescriptorHandleForHeapStart();
			// ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ÅƒAï¿½hï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
			rtvHandle.ptr += i * device->GetDescriptorHandleIncrementSize(rtvHeapDesc.Type);
			// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[ï¿½ÌÝ’ï¿½
			D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
			// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ÌŒvï¿½Zï¿½ï¿½ï¿½Ê‚ï¿½SRGBï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½Äï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
			rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
			rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
			// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[ï¿½Ìï¿½ï¿½ï¿½
			device->CreateRenderTargetView(backBuffers[i].Get(), &rtvDesc, rtvHandle);
		}
	}
}

void DirectXCommon::InitializeDepthBuffer()
{
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	D3D12_RESOURCE_DESC depthResourceDesc{};
	depthResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	depthResourceDesc.Width = WinApp::window_width;// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½Éï¿½ï¿½í‚¹ï¿½ï¿½
	depthResourceDesc.Height = WinApp::window_height;// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½Éï¿½ï¿½í‚¹ï¿½ï¿½
	depthResourceDesc.DepthOrArraySize = 1;
	depthResourceDesc.Format = DXGI_FORMAT_D32_FLOAT;//ï¿½[ï¿½xï¿½tï¿½Hï¿½[ï¿½}ï¿½bï¿½g
	depthResourceDesc.SampleDesc.Count = 1;
	depthResourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;//ï¿½eï¿½vï¿½Xï¿½Xï¿½eï¿½ï¿½ï¿½Vï¿½ï¿½

	// ï¿½[ï¿½xï¿½lï¿½pï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	D3D12_HEAP_PROPERTIES depthHeapProp{};
	depthHeapProp.Type = D3D12_HEAP_TYPE_DEFAULT;
	// ï¿½[ï¿½xï¿½lï¿½ÌƒNï¿½ï¿½ï¿½Aï¿½Ý’ï¿½
	D3D12_CLEAR_VALUE depthClearValue{};//ï¿½[ï¿½xï¿½l1.0f(ï¿½Å‘ï¿½l)ï¿½ÅƒNï¿½ï¿½ï¿½A
	depthClearValue.Format = DXGI_FORMAT_D32_FLOAT; //ï¿½[ï¿½xï¿½lï¿½tï¿½Hï¿½[ï¿½}ï¿½bï¿½g
	depthClearValue.DepthStencil.Depth = 1.0f;

	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	ID3D12Resource* depthBuff = nullptr;
	result = device->CreateCommittedResource(
		&depthHeapProp,
		D3D12_HEAP_FLAG_NONE,
		&depthResourceDesc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&depthClearValue,
		IID_PPV_ARGS(&depthBuff));

	// ï¿½[ï¿½xï¿½rï¿½ï¿½ï¿½[ï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ì¬
	D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc{};
	dsvHeapDesc.NumDescriptors = 1;//ï¿½[ï¿½xï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½1ï¿½ï¿½
	dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	/*ID3D12DescriptorHeap* dsvHeap = nullptr;*/
	result = device->CreateDescriptorHeap(&dsvHeapDesc, IID_PPV_ARGS(&dsvHeap));

	// ï¿½[ï¿½xï¿½rï¿½ï¿½ï¿½[ï¿½ì¬
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	device->CreateDepthStencilView(
		depthBuff,
		&dsvDesc,
		dsvHeap->GetCPUDescriptorHandleForHeapStart());
}

void DirectXCommon::InitializeFence()
{
	result = device->CreateFence(fenceVal, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence));
}

void DirectXCommon::PreDraw()
{
	// ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@ï¿½Ì”Ôï¿½ï¿½æ“¾(ï¿½Qï¿½Â‚È‚Ì‚ï¿½0ï¿½Ô‚ï¿½1ï¿½ï¿½)
	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	// 1.ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½oï¿½ï¿½ï¿½Aï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ý‰Â”\ï¿½É•ÏX
	D3D12_RESOURCE_BARRIER barrierDesc{};
	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();// ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½wï¿½ï¿½
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;// ï¿½\ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;// ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½
	commandList->ResourceBarrier(1, &barrierDesc);
	//commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(backBuffers[bbIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

	// 2.ï¿½`ï¿½ï¿½ï¿½Ì•ÏX
	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½rï¿½ï¿½ï¿½[ï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle =
		CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeap->GetCPUDescriptorHandleForHeapStart(), bbIndex, rtvHD);
	/*rtvHandle.ptr += bbIndex * rtvH;*/
	// ï¿½[ï¿½xï¿½Xï¿½eï¿½ï¿½ï¿½Vï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[ï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle = 
		CD3DX12_CPU_DESCRIPTOR_HANDLE(dsvHeap->GetCPUDescriptorHandleForHeapStart());
	// ï¿½`ï¿½ï¿½ï¿½wï¿½ï¿½
	commandList->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);

	// 3.ï¿½`ï¿½ï¿½Nï¿½ï¿½ï¿½Aï¿½@ï¿½@ï¿½@ï¿½@ï¿½@
	// ï¿½ï¿½Ê‚ï¿½hï¿½ï¿½Â‚Ô‚ï¿½ï¿½F    R    G      B     A
	FLOAT clearcolor[] = { 0.1f, 0.25f, 0.5f, 0.0f };// ï¿½Â‚ï¿½ï¿½Û‚ï¿½ï¿½F
	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½Nï¿½ï¿½ï¿½A
	commandList->ClearRenderTargetView(rtvHandle, clearcolor, 0, nullptr);
	// ï¿½kï¿½xï¿½oï¿½bï¿½tï¿½@ï¿½Nï¿½ï¿½ï¿½A
	commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

	bool ï¿½Lï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½(uint8_t ï¿½Lï¿½[ï¿½Ôï¿½);
	bool ï¿½Lï¿½[ï¿½ð—£‚ï¿½ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½(uint8_t ï¿½Lï¿½[ï¿½Ôï¿½);
	bool ï¿½Lï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½uï¿½Ô‚ï¿½(uint8_t ï¿½Lï¿½[ï¿½Ôï¿½);
	bool ï¿½Lï¿½[ï¿½ð—£‚ï¿½ï¿½ï¿½ï¿½uï¿½Ô‚ï¿½(uint8_t ï¿½Lï¿½[ï¿½Ôï¿½);

	//4.ï¿½`ï¿½ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Í‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	// ï¿½rï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½Ý’ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	D3D12_VIEWPORT viewport{};
	viewport.Width = WinApp::window_width;
	viewport.Height = WinApp::window_height;
	viewport.TopLeftX = 0;
	viewport.TopLeftY = 0;
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;
	// ï¿½rï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½Ý’ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Aï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ÉÏ‚ï¿½
	commandList->RSSetViewports(1, &viewport);
	//commandList->RSSetViewports(1, &CD3DX12_VIEWPORT(0.0f, 0.0f, WinApp::window_width, WinApp::window_height));

	// ï¿½Vï¿½Uï¿½[ï¿½ï¿½`
	D3D12_RECT scissorRect{};
	scissorRect.left = 0;// ï¿½Ø‚è”²ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½
	scissorRect.right = scissorRect.left + WinApp::window_width;// ï¿½Ø‚è”²ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½E
	scissorRect.top = 0;// ï¿½Ø‚è”²ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½
	scissorRect.bottom = scissorRect.top + WinApp::window_height;// ï¿½Ø‚è”²ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½
	// ï¿½Vï¿½Uï¿½[ï¿½ï¿½`ï¿½Ý’ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Aï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ÉÏ‚ï¿½
	commandList->RSSetScissorRects(1, &scissorRect);
	//commandList->RSSetScissorRects(1, &CD3DX12_RECT(0, 0, WinApp::window_width, WinApp::window_height));
}

void DirectXCommon::PostDraw()
{
	// ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@ï¿½Ì”Ôï¿½ï¿½æ“¾(ï¿½Qï¿½Â‚È‚Ì‚ï¿½0ï¿½Ô‚ï¿½1ï¿½ï¿½)
	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	// 5.ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½oï¿½ï¿½ï¿½Aï¿½ï¿½ß‚ï¿½
	D3D12_RESOURCE_BARRIER barrierDesc{};
	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();// ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½wï¿½ï¿½
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET; // ï¿½\ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT; // ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½
	commandList->ResourceBarrier(1, &barrierDesc);

	// ï¿½ï¿½ï¿½ß‚ÌƒNï¿½ï¿½ï¿½[ï¿½Y
	result = commandList->Close();
	assert(SUCCEEDED(result));

	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ÌŽï¿½ï¿½s
	ID3D12CommandList* commandLists[] = { commandList.Get()};
	commandQueue->ExecuteCommandLists(1, commandLists);

	// ï¿½ï¿½Ê‚É•\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½bï¿½v(ï¿½ï¿½ï¿½\ï¿½Ì“ï¿½ï¿½ï¿½Ö‚ï¿½)
	result = swapChain->Present(1, 0);
	assert(SUCCEEDED(result));

	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ÌŽï¿½ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	commandQueue->Signal(fence.Get(), ++fenceVal);
	if (fence->GetCompletedValue() != fenceVal) {
		HANDLE event = CreateEvent(nullptr, false, false, nullptr);
		fence->SetEventOnCompletion(fenceVal, event);
		WaitForSingleObject(event, INFINITE);
		CloseHandle(event);
	}

	// FPSï¿½Å’ï¿½
	fpsFixed->UpdateFixFPS();

	// ï¿½Lï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½A
	result = commandAllocator->Reset();
	assert(SUCCEEDED(result));

	// ï¿½Ä‚ÑƒRï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ð’™‚ß‚é€ï¿½ï¿½
	result = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(result));
}

void DirectXCommon::fpsFixedFinalize()
{
	safe_delete(fpsFixed);
}


============================================================
File Path: engine/base/DirectXCommon.h
============================================================
#pragma once 
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>
#include <d3dx12.h>
#include <chrono>
#include <thread>

#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)

#include "WinApp.h"
#include "FPSFixed.h"

using namespace Microsoft::WRL;

// DirectXï¿½ï¿½ï¿½
class DirectXCommon final
{
public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize(WinApp* winApp);
	// ï¿½fï¿½oï¿½Cï¿½Xï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeDevice();
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Ö˜Aï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeCommand();
	// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½[ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeSwapchain();
	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½rï¿½ï¿½ï¿½[ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeRenderTargetView();
	// ï¿½[ï¿½xï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeDepthBuffer();
	// ï¿½tï¿½Fï¿½ï¿½ï¿½Xï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeFence();
	// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	void PreDraw();
	// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	void PostDraw();
	// ï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void fpsFixedFinalize();

private: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	template <class T>
	inline void safe_delete(T*& p) {
		delete p;
		p = nullptr;
	}

public:
	static DirectXCommon* GetInstance();

private:
	DirectXCommon() = default;
	~DirectXCommon() = default;
	DirectXCommon(const DirectXCommon&) = delete;
	DirectXCommon& operator=(const DirectXCommon&) = delete;
	

public: // Getter
	// ï¿½fï¿½oï¿½Cï¿½Xï¿½ÌŽæ“¾
	ID3D12Device* GetDevice() const { return device.Get(); }
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½æ“¾
	ID3D12GraphicsCommandList* GetCommandList() const { return commandList.Get(); }
	// ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½ï¿½æ“¾
	size_t GetBackBufferCount() const { return backBuffers.size(); }

private: 
	// WindowsAPI
	WinApp* winApp = nullptr;
	// FPS
	FPSFixed* fpsFixed = nullptr;

	HRESULT result;
	// DirectX12ï¿½fï¿½oï¿½Cï¿½X
	ComPtr<ID3D12Device> device;
	// DXGIï¿½tï¿½@ï¿½Nï¿½gï¿½ï¿½
	ComPtr<IDXGIFactory7> dxgiFactory;
	// ï¿½Xï¿½ï¿½ï¿½bï¿½vï¿½`ï¿½Fï¿½Cï¿½ï¿½
	ComPtr<IDXGISwapChain4> swapChain;
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Aï¿½ï¿½ï¿½Pï¿½[ï¿½^
	ComPtr<ID3D12CommandAllocator> commandAllocator;
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½g
	ComPtr<ID3D12GraphicsCommandList> commandList;
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½Lï¿½ï¿½ï¿½[
	ComPtr<ID3D12CommandQueue> commandQueue;
	ComPtr<ID3D12DescriptorHeap> rtvHeap;
	ComPtr<ID3D12DescriptorHeap> dsvHeap;


	//ï¿½oï¿½bï¿½Nï¿½oï¿½bï¿½tï¿½@
	std::vector<ComPtr<ID3D12Resource>> backBuffers;
	// ï¿½tï¿½Fï¿½ï¿½ï¿½Xï¿½Ìï¿½ï¿½ï¿½
	ComPtr<ID3D12Fence> fence;

	UINT rtvHD;
	UINT64 fenceVal = 0;
};

============================================================
File Path: engine/base/FPSFixed.cpp
============================================================
#include "FPSFixed.h"

void FPSFixed::InitializeFixFPS() {
	// ï¿½ï¿½ï¿½ÝŽï¿½ï¿½Ô‚ï¿½ï¿½Lï¿½^ï¿½ï¿½ï¿½ï¿½
	reference_ = std::chrono::steady_clock::now();
}

void FPSFixed::UpdateFixFPS() {
	// 1/60ï¿½bï¿½Ò‚ï¿½ï¿½ï¿½ï¿½ï¿½ÌŽï¿½ï¿½ï¿½
	const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 105.0f));
	// 1/60ï¿½bï¿½ï¿½ï¿½í‚¸ï¿½ï¿½ï¿½É’Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 100.0f));

	// ï¿½ï¿½ï¿½Ý‚ÌŽï¿½ï¿½Ô‚ï¿½ï¿½æ“¾ï¿½ï¿½ï¿½ï¿½
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
	// ï¿½Oï¿½ï¿½Lï¿½^ï¿½ï¿½ï¿½ï¿½ÌŒoï¿½ßŽï¿½ï¿½Ô‚ï¿½ï¿½æ“¾ï¿½ï¿½ï¿½ï¿½
	std::chrono::microseconds elapsed =
		std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

	// 1/60ï¿½b(ï¿½ï¿½ï¿½í‚¸ï¿½ï¿½ï¿½É’Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½)ï¿½oï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½ê‡
	if (elapsed < kMinCheckTime) {
		// 1/60ï¿½bï¿½oï¿½ß‚ï¿½ï¿½ï¿½Ü‚Å”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½[ï¿½vï¿½ï¿½ï¿½Jï¿½ï¿½Ô‚ï¿½
		while (std::chrono::steady_clock::now() - reference_ < kMinTime) {
			// 1ï¿½}ï¿½Cï¿½Nï¿½ï¿½ï¿½bï¿½Xï¿½ï¿½ï¿½[ï¿½v
			std::this_thread::sleep_for(std::chrono::microseconds(1));
		}
	}
	// ï¿½ï¿½ï¿½Ý‚ÌŽï¿½ï¿½Ô‚ï¿½ï¿½Lï¿½^ï¿½ï¿½ï¿½ï¿½
	reference_ = std::chrono::steady_clock::now();
}

============================================================
File Path: engine/base/FPSFixed.h
============================================================
#pragma once

#include <chrono>
#include <thread>

class FPSFixed 
{
public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// FPSï¿½Å’è‰ï¿½ï¿½ï¿½ï¿½
	void InitializeFixFPS();
	// FPSï¿½Å’ï¿½Xï¿½V
	void UpdateFixFPS();

	// ï¿½Lï¿½^ï¿½ï¿½ï¿½ï¿½(FPSï¿½Å’ï¿½p)
	std::chrono::steady_clock::time_point reference_;
};

============================================================
File Path: engine/base/Input.cpp
============================================================
#include "Input.h"
#include <cassert>

#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")

//using namespace Microsoft::WRL;

Input* Input::GetInstance()
{
	static Input instance;

	return &instance;
}

void Input::Initialize(WinApp* winApp)
{
	// ï¿½Ø‚ï¿½Ä‚ï¿½ï¿½ï¿½WinAppï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½Lï¿½^
	this->winApp = winApp;

	HRESULT result;

	// DirectInputï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½ï¿½
	/*ComPtr<IDirectInput8> directInput = nullptr;*/
	result = DirectInput8Create(winApp->GetHInstance(), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&directInput, nullptr);
	assert(SUCCEEDED(result));

	// ï¿½Lï¿½[ï¿½{ï¿½[ï¿½hï¿½fï¿½oï¿½Cï¿½Xï¿½Ìï¿½ï¿½ï¿½
	//ComPtr<IDirectInputDevice8> keyboard = nullptr;
	result = directInput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));

	// ï¿½ï¿½ï¿½Íƒfï¿½[ï¿½^ï¿½`ï¿½ï¿½ï¿½ÌƒZï¿½bï¿½g
	result = keyboard->SetDataFormat(&c_dfDIKeyboard); // ï¿½Wï¿½ï¿½ï¿½`ï¿½ï¿½
	assert(SUCCEEDED(result));

	// ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½äƒŒï¿½xï¿½ï¿½ï¿½ÌƒZï¿½bï¿½g
	result = keyboard->SetCooperativeLevel(winApp->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));

	//ï¿½}ï¿½Eï¿½Xï¿½fï¿½oï¿½Cï¿½Xï¿½ÌƒZï¿½bï¿½g
	result = directInput->CreateDevice(GUID_SysMouse, &mouse, NULL);
	assert(SUCCEEDED(result));

	// ï¿½ï¿½ï¿½Íƒfï¿½[ï¿½^ï¿½`ï¿½ï¿½ï¿½ÌƒZï¿½bï¿½g
	result = mouse->SetDataFormat(&c_dfDIMouse); // ï¿½Wï¿½ï¿½ï¿½`ï¿½ï¿½
	assert(SUCCEEDED(result));
	
	// ï¿½rï¿½ï¿½ï¿½ï¿½ï¿½äƒŒï¿½xï¿½ï¿½ï¿½ÌƒZï¿½bï¿½g
	result = keyboard->SetCooperativeLevel(winApp->GetHwnd(), DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
	assert(SUCCEEDED(result));

	//ï¿½fï¿½oï¿½Cï¿½Xï¿½ÌÝ’ï¿½
	DIPROPDWORD diprop;
	diprop.diph.dwSize = sizeof(diprop);
	diprop.diph.dwHeaderSize = sizeof(diprop.diph);
	diprop.diph.dwObj = 0;
	diprop.diph.dwHow = DIPH_DEVICE;
	diprop.dwData = DIPROPAXISMODE_REL;

	result = mouse->SetProperty(DIPROP_AXISMODE, &diprop.diph);
	assert(SUCCEEDED(result));
	//ï¿½}ï¿½Eï¿½Xï¿½Jï¿½[ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½
	ShowCursor(FALSE);
}

void Input::Update()
{
	HRESULT result;

	// ï¿½Oï¿½ï¿½ÌƒLï¿½[ï¿½ï¿½ï¿½Í‚ï¿½ÛŽï¿½
	memcpy(keyPre, key, sizeof(key));

	// ï¿½Lï¿½[ï¿½{ï¿½[ï¿½hï¿½ï¿½ï¿½ÌŽæ“¾ï¿½Jï¿½n
	result = keyboard->Acquire();

	// ï¿½Sï¿½Lï¿½[ï¿½Ì“ï¿½ï¿½Íï¿½Ô‚ï¿½ï¿½æ“¾ï¿½ï¿½ï¿½ï¿½
	/*BYTE key[256] = {};*/
	result = keyboard->GetDeviceState(sizeof(key), key);

	//ï¿½}ï¿½Eï¿½Xï¿½ï¿½ï¿½ï¿½Jï¿½n
	memcpy(&mouseState_bak, &mouseState, sizeof(mouseState_bak));
	mouse->Acquire();

	result = mouse->GetDeviceState(sizeof(DIMOUSESTATE), &mouseState);
}

//ï¿½}ï¿½Eï¿½Xï¿½ï¿½
bool Input::PushMouseLeft()
{
	if (mouseState.rgbButtons[0] != 0) {
		return true;
	}
	return false;
}

bool Input::TriggerMouseLeft()
{
	if (mouseState.rgbButtons[0] > 0 && mouseState_bak.rgbButtons[0] == 0) {
		return true;
	}
	return false;
}

bool Input::PushMouseRight()
{
	if (mouseState.rgbButtons[1] > 0) {
		return true;
	}
	return false;
}

bool Input::TriggerMouseRight()
{
	if (mouseState.rgbButtons[1] > 0 && mouseState_bak.rgbButtons[1] == 0) {
		return true;
	}
	return false;
}

Vector3 Input::GetMousePos()
{
	POINT p;
	GetCursorPos(&p);
	ScreenToClient(winApp->GetHwnd(), &p);

	//zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½Å•Ô‚ï¿½
	return Vector3((float)p.x,(float)p.y,0.0f);
}

Vector3 Input::GetMouseVelo()
{
	return Vector3((float)mouseState.lX - mouseState_bak.lX,(float)mouseState.lY - mouseState_bak.lY,0);
}

void Input::SetMousePos(Vector2 pos)
{
	POINT p{ (long)pos.x,(long)pos.y };
	SetCursorPos(p.x,p.y);
}

bool Input::PushKey(BYTE keyNumber) 
{
	// ï¿½wï¿½ï¿½Lï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ï¿½trueï¿½ï¿½Ô‚ï¿½
	if (key[keyNumber]) {
		return true;
	}
	// ï¿½ï¿½ï¿½ï¿½ï¿½Å‚Í‚È‚ï¿½ï¿½ï¿½ï¿½falseï¿½ï¿½Ô‚ï¿½
	return false;
}

bool Input::TriggerKey(BYTE keyNumber)
{
	if (key[keyNumber] && keyPre[keyNumber] == false) {
		return true;
	}
	
	return false;
}

bool Input::AnyKey()
{
	for (int i = 0; i < sizeof(key); i++) {
		if (key[i] && keyPre[i] == false) {
			return true;
		}
	}

	return false;
}


============================================================
File Path: engine/base/Input.h
============================================================
#pragma once
#include <windows.h>
#include <wrl.h>
#include <dinput.h>
#include "WinApp.h"
#include <dwrite.h>
#include <wchar.h>
#include <wrl/client.h>
#include <random>
#include <xinput.h>
#include "Vector3.h"
#include "Vector2.h"

#pragma comment(lib,"d3d11.lib")
#pragma comment(lib,"d2d1.lib")
#pragma comment(lib,"dwrite.lib")
#pragma comment (lib, "xinput.lib")

#define MaxCountrollers 4  
#define MaxVibration 65535
//#define DIRECTINPUT_VERSION 0x0800 // DirectInputï¿½Ìƒoï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½

// ï¿½ï¿½ï¿½ï¿½
class Input final
{
public:
	static Input* GetInstance();

public:
	struct CountrolerState
	{
		XINPUT_STATE state; // ï¿½Rï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½[ï¿½Ìï¿½Ô‚ÌŽæ“¾
		XINPUT_VIBRATION vibration;  // ï¿½oï¿½Cï¿½uï¿½ï¿½ï¿½[ï¿½Vï¿½ï¿½ï¿½ï¿½
		//bool Connected;
	};
	/*CountrolerState GamePad;*/

public:
	// namespace
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize(WinApp* winApp);

	// ï¿½Xï¿½V
	void Update();

	//ï¿½}ï¿½Eï¿½X
	bool PushMouseLeft();
	bool TriggerMouseLeft();
	bool PushMouseRight();
	bool TriggerMouseRight();
	//ï¿½ï¿½ï¿½W
	Vector3 GetMousePos();
	Vector3 GetMouseVelo();

	void SetMousePos(Vector2 pos);

	/// <summary>
	/// ï¿½Lï¿½[ï¿½Ì‰ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	/// </summary>
	/// <param name = "keyNumber">ï¿½Lï¿½[ï¿½Ôï¿½(DIK_0 ï¿½ï¿½)</param>
	/// <returns>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½é‚©</returns>
	bool PushKey(BYTE keyNumber);

	/// <summary>
	/// ï¿½Lï¿½[ï¿½Ìƒgï¿½ï¿½ï¿½Kï¿½[ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	/// </summary>
	/// </param name="keyNumber">ï¿½Lï¿½[ï¿½Ôï¿½( DIK_0 ï¿½ï¿½)</param>
	/// <reutrns>ï¿½gï¿½ï¿½ï¿½Kï¿½[ï¿½ï¿½</params>
	bool TriggerKey(BYTE keyNumber);
	bool AnyKey();

private:
	Input() = default;
	~Input() = default;
	Input(const Input&) = delete;
	Input& operator=(const Input&) = delete;

private: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	// ï¿½Lï¿½[ï¿½{ï¿½[ï¿½hï¿½Ìƒfï¿½oï¿½Cï¿½X
	ComPtr<IDirectInputDevice8> keyboard;
	//ï¿½}ï¿½Eï¿½Xï¿½Ìƒfï¿½oï¿½Cï¿½X
	ComPtr<IDirectInputDevice8> mouse;
	// DirectInputï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½X
	ComPtr<IDirectInput8> directInput;
	// ï¿½Sï¿½Lï¿½[ï¿½Ìï¿½ï¿½
	BYTE key[256] = {};
	// ï¿½Oï¿½ï¿½Ì‘Sï¿½Lï¿½[ï¿½Ìï¿½ï¿½
	BYTE keyPre[256] = {};
	//ï¿½}ï¿½Eï¿½Xï¿½Ìï¿½ï¿½
	DIMOUSESTATE mouseState = {};
	DIMOUSESTATE mouseState_bak = {};	// ï¿½}ï¿½Eï¿½Xï¿½ï¿½ï¿½(ï¿½Ï‰ï¿½ï¿½ï¿½ï¿½mï¿½p)
	// WindowsAPI
	WinApp* winApp = nullptr;
};

============================================================
File Path: engine/base/JsonLoader.cpp
============================================================
#include "JsonLoader.h"

#pragma warning(push)
#pragma	warning(disable:4281)
#include <json.hpp>
#pragma warning(pop)
#include <fstream>
#include <cassert>

const std::string JsonLoader::kDefaultBaseDirectory = "Resources/levels/";
const std::string JsonLoader::kExtension = ".json";

//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
LevelData* JsonLoader::LoadFile(const std::string& fileName) {
	// ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½Äƒtï¿½ï¿½ï¿½pï¿½Xï¿½ð“¾‚ï¿½
	const std::string fullpath = kDefaultBaseDirectory + fileName + kExtension;

	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½
	std::ifstream file;

	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½
	file.open(fullpath);
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Iï¿½[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	if (file.fail()) {
		assert(0);
	}

	// JSONï¿½ï¿½ï¿½ï¿½ï¿½ñ‚©‚ï¿½ð“€‚ï¿½ï¿½ï¿½ï¿½fï¿½[ï¿½^
	nlohmann::json deserialized;

	// ï¿½ï¿½
	file >> deserialized;

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	assert(deserialized.is_object());
	assert(deserialized.contains("name"));
	assert(deserialized["name"].is_string());

	// "name"ï¿½ð•¶Žï¿½ï¿½ï¿½Æ‚ï¿½ï¿½ÄŽæ“¾
	std::string name = deserialized["name"].get<std::string>();
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	assert(name.compare("scene") == 0);

	// ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½iï¿½[ï¿½pï¿½Cï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½ð¶ï¿½
	LevelData* levelData = new LevelData();

	// "objects"ï¿½Ì‘Sï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ð‘–ï¿½
	for (nlohmann::json& object : deserialized["objects"]) {
		assert(object.contains("type"));

		// ï¿½ï¿½Ê‚ï¿½ï¿½æ“¾
		std::string type = object["type"].get<std::string>();

		// MESH
		if (type.compare("MESH") == 0) {
			// ï¿½vï¿½fï¿½Ç‰ï¿½
			levelData->objects.emplace_back(LevelData::ObjectData{});
			// ï¿½ï¿½ï¿½Ç‰ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vï¿½fï¿½ÌŽQï¿½Æ‚ð“¾‚ï¿½
			LevelData::ObjectData& objectData = levelData->objects.back();

			if (object.contains("file_name")) {
				// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
				objectData.fileName = object["file_name"];
			}

			// ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½tï¿½Hï¿½[ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½Ç‚Ýï¿½ï¿½ï¿½
			nlohmann::json& transform = object["transform"];
			// ï¿½ï¿½ï¿½sï¿½Ú“ï¿½
			objectData.translation.x = (float)transform["translation"][1];
			objectData.translation.y = (float)transform["translation"][2];
			objectData.translation.z = (float)transform["translation"][0] * -1;
			objectData.translation.w = 1.0f;
			// ï¿½ï¿½]ï¿½p
			objectData.rotation.x = (float)transform["rotation"][1] * -1;
			objectData.rotation.y = (float)transform["rotation"][2] * -1;
			objectData.rotation.z = (float)transform["rotation"][0];
			objectData.rotation.w = 0.0f;
			// ï¿½Xï¿½Pï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½O
			objectData.scaling.x = (float)transform["scaling"][1];
			objectData.scaling.y = (float)transform["scaling"][2];
			objectData.scaling.z = (float)transform["scaling"][0];
			objectData.scaling.w = 0.0f;

			// TODO: ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Ìƒpï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½Ç‚Ýï¿½ï¿½ï¿½
		}

		// TODO: ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‹Aï¿½Öï¿½ï¿½É‚Ü‚Æ‚ßAï¿½Ä‹Aï¿½Äoï¿½ÅŽ}ï¿½ð‘–ï¿½ï¿½ï¿½ï¿½ï¿½
		if (object.contains("children")) {

		}
	}

	return levelData;
}

============================================================
File Path: engine/base/JsonLoader.h
============================================================
#pragma once
#include "Vector4.h"
#pragma warning(push)
#pragma	warning(disable:4282)
#pragma	warning(disable:4283)
#pragma	warning(disable:4285)
#include <json.hpp>
#pragma warning(pop)
#include <string>
#include <vector>
#include "Matrix4.h"

// ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½fï¿½[ï¿½^
struct LevelData {

	struct ObjectData {
		// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		std::string fileName;
		// ï¿½ï¿½ï¿½sï¿½Ú“ï¿½
		Vector4 translation;
		// ï¿½ï¿½]ï¿½p
		Vector4 rotation;
		// ï¿½Xï¿½Pï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½O
		Vector4 scaling;
	};

	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½zï¿½ï¿½
	std::vector<ObjectData> objects;
};

class JsonLoader {
public:
	//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	LevelData* LoadFile(const std::string& fileName);
public:
	// ï¿½fï¿½tï¿½Hï¿½ï¿½ï¿½gï¿½Ì“Ç‚Ýï¿½ï¿½Ýƒfï¿½Bï¿½ï¿½ï¿½Nï¿½gï¿½ï¿½
	static const std::string kDefaultBaseDirectory;
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½q
	static const std::string kExtension;

};

============================================================
File Path: engine/base/WinApp.cpp
============================================================
#include "WinApp.h"

WinApp* WinApp::GetInstance() 
{
	static WinApp instance;

	return &instance;
}

LRESULT WinApp::WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{

	// ï¿½ï¿½ï¿½bï¿½Zï¿½[ï¿½Wï¿½Å•ï¿½ï¿½ï¿½
	switch (msg) {
	case WM_DESTROY: // ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½ï¿½ï¿½jï¿½ï¿½ï¿½ï¿½ï¿½ê‚½
		PostQuitMessage(0); // OSï¿½É‘Î‚ï¿½ï¿½ÄAï¿½Aï¿½vï¿½ï¿½ï¿½ÌIï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½
		return 0;
	}
	return DefWindowProc(hwnd, msg, wparam, lparam); // ï¿½Wï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½
}

void WinApp::Initialize()
{
	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½Nï¿½ï¿½ï¿½Xï¿½ÌÝ’ï¿½
	//WNDCLASSEX w{};
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.lpfnWndProc = (WNDPROC)WindowProc;    // ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½vï¿½ï¿½ï¿½Vï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½Ý’ï¿½
	wc.lpszClassName = L"DirectXGame";       // ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Nï¿½ï¿½ï¿½Xï¿½ï¿½
	wc.hInstance = GetModuleHandle(nullptr); // ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½nï¿½ï¿½ï¿½hï¿½ï¿½
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);// ï¿½Jï¿½[ï¿½\ï¿½ï¿½ï¿½wï¿½ï¿½

	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Nï¿½ï¿½ï¿½Xï¿½ï¿½OSï¿½É“oï¿½^ï¿½ï¿½ï¿½ï¿½
	RegisterClassEx(&wc);
	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Tï¿½Cï¿½Y{Xï¿½ï¿½ï¿½Wï¿½@Yï¿½ï¿½ï¿½Wï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½cï¿½ï¿½}
	RECT wrc = { 0, 0, window_width, window_height };
	// ï¿½ï¿½ï¿½ï¿½ï¿½ÅƒTï¿½Cï¿½Yï¿½ï¿½â³ï¿½ï¿½ï¿½ï¿½
	AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);

	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Ìï¿½ï¿½ï¿½
	hwnd = CreateWindow(wc.lpszClassName, // ï¿½Nï¿½ï¿½ï¿½Xï¿½ï¿½
		L"DirectXGame",       // ï¿½^ï¿½Cï¿½gï¿½ï¿½ï¿½oï¿½[ï¿½Ì•ï¿½ï¿½ï¿½
		WS_OVERLAPPEDWINDOW,  // ï¿½Wï¿½ï¿½ï¿½Iï¿½ÈƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½Xï¿½^ï¿½Cï¿½ï¿½
		CW_USEDEFAULT,        // ï¿½Wï¿½ï¿½Xï¿½ï¿½ï¿½W (05ï¿½É”Cï¿½ï¿½ï¿½ï¿½)
		CW_USEDEFAULT,        // ï¿½Wï¿½ï¿½Yï¿½ï¿½ï¿½W (05ï¿½É”Cï¿½ï¿½ï¿½ï¿½)
		wrc.right - wrc.left, // ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½ï¿½ï¿½ï¿½
		wrc.bottom - wrc.top, // ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½cï¿½ï¿½
		nullptr,
		nullptr,
		wc.hInstance,
		nullptr);

	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½Ô‚É‚ï¿½ï¿½ï¿½
	ShowWindow(hwnd, SW_SHOW);

}

void WinApp::Finalize()
{
	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½Nï¿½ï¿½ï¿½Xï¿½ï¿½oï¿½^ï¿½ï¿½ï¿½ï¿½
	UnregisterClass(wc.lpszClassName, wc.hInstance);
}

bool WinApp::ProcessMessage()
{
	MSG msg{};// ï¿½ï¿½ï¿½bï¿½Zï¿½[ï¿½W

	if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg); //ï¿½Lï¿½[ï¿½ï¿½ï¿½Íƒï¿½ï¿½bï¿½Zï¿½[ï¿½Wï¿½Ìï¿½ï¿½ï¿½
		DispatchMessage(&msg);  //ï¿½vï¿½ï¿½ï¿½Vï¿½[ï¿½Wï¿½ï¿½ï¿½[ï¿½Éƒï¿½ï¿½bï¿½Zï¿½[ï¿½Wï¿½ð‘—‚ï¿½
	}

	if (msg.message == WM_QUIT) {
		return true;
	}

	return false;
}


============================================================
File Path: engine/base/WinApp.h
============================================================
#pragma once
#include <Windows.h>

// WindowsAPI
class WinApp final
{
public: // ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	static LRESULT WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// WindowsAPIï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize();

	// ï¿½Iï¿½ï¿½
	void Finalize();

	// getter
	HWND GetHwnd() const { return hwnd; }
	HINSTANCE GetHInstance() const { return wc.hInstance; }

	// ï¿½ï¿½ï¿½bï¿½Zï¿½[ï¿½Wï¿½Ìï¿½ï¿½ï¿½
	bool ProcessMessage();

public:
	static WinApp* GetInstance();

private:
	WinApp() = default;
	~WinApp() = default;
	WinApp(const WinApp&) = delete;
	WinApp& operator=(const WinApp&) = delete;

public: // ï¿½è”
	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½ï¿½ï¿½ï¿½
	static const int window_width = 1280;
	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½cï¿½ï¿½
	static const int window_height = 720;

private:
	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½nï¿½ï¿½ï¿½hï¿½ï¿½
	HWND hwnd = nullptr;
	// ï¿½Eï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½Nï¿½ï¿½ï¿½Xï¿½ÌÝ’ï¿½
	WNDCLASSEX wc{};
};

============================================================
File Path: engine/collision/BaseCollider.h
============================================================
#pragma once

#include "CollisionTypes.h"
#include "Object3d.h"
#include "CollisionInfo.h"

//ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½X
class BaseCollider
{
public:
	BaseCollider() = default;
	//ï¿½ï¿½ï¿½zï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	virtual ~BaseCollider() = default;

	inline void SetObject(Object3d* object)
	{
		this->object3d = object;
		collname = object->GetName();
	}
	inline Object3d* GetObject3d()
	{
		return object3d;
	}
	void SetName(const char* name_) {
		this->collname = name_;
	}
	const char* GetName() {
		return collname;
	}

	//ï¿½Xï¿½V
	virtual void Update() = 0;

	//ï¿½`ï¿½ï¿½^ï¿½Cï¿½vï¿½æ“¾
	inline CollisionShapeType GetShapeType()
	{
		return shapeType;
	}

	//ï¿½Õ“ËŽï¿½ï¿½Rï¿½[ï¿½ï¿½ï¿½oï¿½bï¿½Nï¿½Öï¿½
	inline void OnCollision(const CollisionInfo& info)
	{
		object3d->OnCollision(info);
	}

	//ï¿½Õ“ËŽï¿½ï¿½Rï¿½[ï¿½ï¿½ï¿½oï¿½bï¿½Nï¿½Öï¿½
	inline void OffCollision(const CollisionInfo& info)
	{
		object3d->OffCollision(info);
	}

protected:
	Object3d* object3d = nullptr;
	//ï¿½`ï¿½ï¿½^ï¿½Cï¿½v
	CollisionShapeType shapeType = SHAPE_UNKNOWN;
	//ï¿½Õ“Ëï¿½Nï¿½ï¿½ï¿½Xï¿½ï¿½
	const char* collname = nullptr;
};

============================================================
File Path: engine/collision/Collision.cpp
============================================================
#include "Collision.h"
using namespace DirectX;


bool Collision::CheckSphere2Sphere(const Sphere& sphereA, const Sphere& sphereB, Vector3* inter, Vector3* reject)
{
	float x = (sphereB.center.x - sphereA.center.x) * (sphereB.center.x - sphereA.center.x);
	float y = (sphereB.center.y - sphereA.center.y) * (sphereB.center.y - sphereA.center.y);
	float z = (sphereB.center.z - sphereA.center.z) * (sphereB.center.z - sphereA.center.z);

	float dist = x + y + z;
	float radius = (sphereA.radius + sphereB.radius) * (sphereA.radius + sphereB.radius);

	if (dist <= radius) {
		if (inter) {
			// Aï¿½Ì”ï¿½ï¿½aï¿½ï¿½0ï¿½ÌŽï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Bï¿½Ì’ï¿½ï¿½S  Bï¿½Ì”ï¿½ï¿½aï¿½ï¿½0ï¿½ÌŽï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½Aï¿½Ì’ï¿½ï¿½S  ï¿½Æ‚È‚ï¿½æ‚¤ï¿½É•ï¿½ï¿½
			float t = sphereB.radius / (sphereA.radius + sphereB.radius);
			*inter = Vector3::lerp(sphereA.center, sphereB.center, t);
		}
		if (reject) {
			float rejectLen = sphereA.radius + sphereB.radius - sqrtf(dist);
			Vector3 center = sphereA.center - sphereB.center;
			*reject = center.normalize();
			*reject *= rejectLen;

		}
		return true;
	}
	return false;
}

bool Collision::CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter)
{
	// ï¿½ï¿½ï¿½Wï¿½nï¿½ÌŒï¿½ï¿½_ï¿½ï¿½ï¿½ç‹…ï¿½Ì’ï¿½ï¿½Sï¿½ï¿½ï¿½Wï¿½Ö‚Ì‹ï¿½ï¿½ï¿½
	Vector3 V;
	float distV = V.dot(sphere.center, plane.normal);
	// ï¿½ï¿½ï¿½Ê‚ÌŒï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½é‚±ï¿½Æ‚ÅAï¿½ï¿½ï¿½Ê‚Æ‹ï¿½ï¿½Ì’ï¿½ï¿½Sï¿½Æ‚Ì‹ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½
	float dist = distV - plane.distance;
	// ï¿½ï¿½ï¿½ï¿½ï¿½Ìï¿½Î’lï¿½ï¿½ï¿½ï¿½ï¿½aï¿½ï¿½ï¿½å‚«ï¿½ï¿½ï¿½ï¿½Î“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½
	if (fabsf(dist) > sphere.radius) return false;

	// ï¿½^ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½vï¿½Z
	if (inter) {
		// ï¿½ï¿½ï¿½Êï¿½ÌÅ‹ßÚ“_ï¿½ï¿½ï¿½Aï¿½^ï¿½ï¿½ï¿½ï¿½_ï¿½Æ‚ï¿½ï¿½ï¿½
		*inter = -dist * plane.normal + sphere.center;
	}

	return true;
}

void Collision::ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest)
{
	// pointï¿½ï¿½p0ï¿½ÌŠOï¿½ï¿½ï¿½Ì’ï¿½ï¿½_ï¿½Ìˆï¿½Ì’ï¿½ï¿½É‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	Vector3 p0_p2 = triangle.p2 - triangle.p0;
	Vector3 p0_pt = point - triangle.p0;

	Vector3 V;
	float d1 = V.dot(p0_p1, p0_pt);
	float d2 = V.dot(p0_p2, p0_pt);

	if (d1 <= 0.0f && d2 <= 0.0f)
	{
		// p0ï¿½ï¿½ï¿½Å‹ß–T
		*closest = triangle.p0;
		return;
	}

	// pointï¿½ï¿½p1ï¿½ÌŠOï¿½ï¿½ï¿½Ì’ï¿½ï¿½_ï¿½Ìˆï¿½Ì’ï¿½ï¿½É‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	Vector3 p1_pt = point - triangle.p1;

	float d3 = V.dot(p0_p1, p1_pt);
	float d4 = V.dot(p0_p2, p1_pt);

	if (d3 >= 0.0f && d4 <= d3)
	{
		// p1ï¿½ï¿½ï¿½Å‹ß–T
		*closest = triangle.p1;
		return;
	}

	// pointï¿½ï¿½p0_p1ï¿½Ì•Ó—Ìˆï¿½Ì’ï¿½ï¿½É‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½Nï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½pointï¿½ï¿½p0_p1ï¿½ï¿½É‘Î‚ï¿½ï¿½ï¿½Ë‰eï¿½ï¿½Ô‚ï¿½
	float vc = d1 * d4 - d3 * d2;
	if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
	{
		float v = d1 / (d1 - d3);
		*closest = triangle.p0 + v * p0_p1;
		return;
	}

	// pointï¿½ï¿½p2ï¿½ÌŠOï¿½ï¿½ï¿½Ì’ï¿½ï¿½_ï¿½Ìˆï¿½Ì’ï¿½ï¿½É‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	Vector3 p2_pt = point - triangle.p2;

	float d5 = V.dot(p0_p1, p2_pt);
	float d6 = V.dot(p0_p2, p2_pt);
	if (d6 >= 0.0f && d5 <= d6)
	{
		*closest = triangle.p2;
		return;
	}

	// pointï¿½ï¿½p0_p2ï¿½Ì•Ó—Ìˆï¿½Ì’ï¿½ï¿½É‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½Nï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½pointï¿½ï¿½p0_p2ï¿½ï¿½É‘Î‚ï¿½ï¿½ï¿½Ë‰eï¿½ï¿½Ô‚ï¿½
	float vb = d5 * d2 - d1 * d6;
	if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
	{
		float w = d2 / (d2 - d6);
		*closest = triangle.p0 + w * p0_p2;
		return;
	}

	// pointï¿½ï¿½p1_p2ï¿½Ì•Ó—Ìˆï¿½Ì’ï¿½ï¿½É‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½Nï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½pointï¿½ï¿½p1_p2ï¿½ï¿½É‘Î‚ï¿½ï¿½ï¿½Ë‰eï¿½ï¿½Ô‚ï¿½
	float va = d3 * d6 - d5 * d4;
	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
	{
		float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
		*closest = triangle.p1 + w * (triangle.p2 - triangle.p1);
		return;
	}

	float denom = 1.0f / (va + vb + vc);
	float v = vb * denom;
	float w = vc * denom;
	*closest = triangle.p0 + p0_p1 * v + p0_p2 * w;
}

bool Collision::CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter, Vector3* reject)
{
	Vector3 p;
	// ï¿½ï¿½ï¿½Ì’ï¿½ï¿½Sï¿½É‘Î‚ï¿½ï¿½ï¿½Å‹ßÚ“_ï¿½Å‚ï¿½ï¿½ï¿½Oï¿½pï¿½`ï¿½ï¿½É‚ï¿½ï¿½ï¿½_pï¿½ï¿½ï¿½ï¿½ï¿½Â‚ï¿½ï¿½ï¿½
	ClosestPtPoint2Triangle(sphere.center, triangle, &p);

	// ï¿½_pï¿½Æ‹ï¿½ï¿½Ì’ï¿½ï¿½Sï¿½Ìï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	Vector3 v = p - sphere.center;
	Vector3 VV;
	// ï¿½ï¿½ï¿½ï¿½ï¿½Ì“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	// ï¿½iï¿½ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½mï¿½Ì“ï¿½ï¿½Ï‚ÍŽOï¿½ï¿½ï¿½ï¿½ï¿½Ì’è—ï¿½Ìƒï¿½ï¿½[ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ÌŽï¿½ï¿½Æˆï¿½vï¿½ï¿½ï¿½ï¿½j
	float vvv = VV.dot(v, v);

	// ï¿½ï¿½ï¿½ÆŽOï¿½pï¿½`ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½aï¿½È‰ï¿½ï¿½È‚ç“–ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½
	if (vvv > sphere.radius * sphere.radius)return false;

	// ï¿½^ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½vï¿½Z
	if (inter) {
		// ï¿½Oï¿½pï¿½`ï¿½ï¿½ÌÅ‹ßÚ“_pï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½_ï¿½Æ‚ï¿½ï¿½ï¿½
		*inter = p;
	}
	// ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½vï¿½Z
	if (reject) {
		float ds = Vector3::dot(sphere.center, triangle.normal);
		float dt = Vector3::dot(triangle.p0, triangle.normal);
		float rejectLen = dt - ds + sphere.radius;
		*reject = triangle.normal * rejectLen;
	}
	return true;
}

bool Collision::CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance, Vector3* inter)
{
	const float epsilon = 1.0e-5f; // ï¿½ë·ï¿½zï¿½ï¿½ï¿½pï¿½Ì”ï¿½ï¿½ï¿½ï¿½È’l
	// ï¿½Ê–@ï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Cï¿½Ì•ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Ì“ï¿½ï¿½ï¿½
	Vector3 V;
	float d1 = V.dot(plane.normal, ray.dir);
	// ï¿½ï¿½ï¿½Ê‚É‚Í“ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½
	if (d1 > -epsilon) { return false; }
	// ï¿½nï¿½_ï¿½ÆŒï¿½ï¿½_ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½Ê‚Ì–@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½j
	// ï¿½Ê–@ï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Cï¿½ÌŽï¿½ï¿½_ï¿½ï¿½ï¿½Wï¿½iï¿½Ê’uï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½jï¿½Ì“ï¿½ï¿½ï¿½
	float d2 = V.dot(plane.normal, ray.start);
	// ï¿½nï¿½_ï¿½Æ•ï¿½ï¿½Ê‚Ì‹ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½Ê‚Ì–@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½j
	float dist = d2 - plane.distance;
	// ï¿½nï¿½_ï¿½Æ•ï¿½ï¿½Ê‚Ì‹ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½j
	float t = dist / -d1;
	// ï¿½ï¿½_ï¿½ï¿½ï¿½nï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½É‚ï¿½ï¿½ï¿½Ì‚ÅAï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½
	if (t < 0)return false;
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	if (distance) { *distance = t; }

	// ï¿½ï¿½_ï¿½ï¿½ï¿½vï¿½Z
	if (inter) { *inter = ray.start + t * ray.dir; }

	return true;
}

bool Collision::CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance, Vector3* inter)
{
	// ï¿½Oï¿½pï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½é•½ï¿½Ê‚ï¿½ï¿½Zï¿½o
	Plane plane;
	Vector3 interPlane;
	Vector3 V;
	plane.normal = triangle.normal;
	plane.distance = V.dot(triangle.normal, triangle.p0);

	// ï¿½ï¿½ï¿½Cï¿½Æ•ï¿½ï¿½Ê‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½ÎAï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½
	if (!CheckRay2Plane(ray, plane, distance, &interPlane)) { return false; }

	// ï¿½ï¿½ï¿½Cï¿½Æ•ï¿½ï¿½Ê‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ï¿½Ì‚ÅAï¿½ï¿½ï¿½ï¿½ï¿½ÆŒï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ü‚ê‚½
	// ï¿½ï¿½ï¿½Cï¿½Æ•ï¿½ï¿½Ê‚ÌŒï¿½_ï¿½ï¿½ï¿½Oï¿½pï¿½`ï¿½Ì“ï¿½ï¿½ï¿½ï¿½É‚ï¿½ï¿½é‚©ï¿½ï¿½ï¿½ï¿½
	const float epsilon = 1.0e-5f;// ï¿½ë·ï¿½zï¿½ï¿½ï¿½pï¿½Ì”ï¿½ï¿½ï¿½ï¿½È’l
	Vector3 m;

	// ï¿½ï¿½p0_p1ï¿½É‚Â‚ï¿½ï¿½ï¿½
	Vector3 pt_p0 = triangle.p0 - interPlane;
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	m = pt_p0.cross(p0_p1);

	// ï¿½Ó‚ÌŠOï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½Î“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½Ì‚Å”ï¿½ï¿½ï¿½ï¿½Å‚ï¿½ï¿½Ø‚ï¿½
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// ï¿½ï¿½p1_p2ï¿½É‚Â‚ï¿½ï¿½ï¿½
	Vector3 pt_p1 = triangle.p1 - interPlane;
	Vector3 p1_p2 = triangle.p2 - triangle.p1;
	m = pt_p1.cross(p1_p2);

	// ï¿½Ó‚ÌŠOï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½Î“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½Ì‚Å”ï¿½ï¿½ï¿½ï¿½Å‚ï¿½ï¿½Ø‚ï¿½
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// ï¿½ï¿½p2_p0ï¿½É‚Â‚ï¿½ï¿½ï¿½
	Vector3 pt_p2 = triangle.p2 - interPlane;
	Vector3 p2_p0 = triangle.p0 - triangle.p2;
	m = pt_p2.cross(p2_p0);

	// ï¿½Ó‚ÌŠOï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½Î“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½Ì‚Å”ï¿½ï¿½ï¿½ï¿½Å‚ï¿½ï¿½Ø‚ï¿½
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// ï¿½ï¿½ï¿½ï¿½ï¿½È‚Ì‚ÅAï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½
	if (inter) {
		*inter = interPlane;
	}

	return true;
}

bool Collision::CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance, Vector3* inter)
{
	Vector3 m = ray.start - sphere.center;
	Vector3 V;
	float b = V.dot(m, ray.dir);
	float c = V.dot(m, m) - sphere.radius * sphere.radius;

	// rayï¿½ÌŽnï¿½_ï¿½ï¿½sphereï¿½ÌŠOï¿½ï¿½ï¿½É‚ï¿½ï¿½ï¿½(c>0)ï¿½Arayï¿½ï¿½sphereï¿½ï¿½ï¿½ç—£ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ê‡(b>0)ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½
	if (c > 0.0f && b > 0.0f) { return false; }

	float discr = b * b - c;

	// ï¿½ï¿½ï¿½Ì”ï¿½ï¿½ÊŽï¿½ï¿½Í—á‚ªï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½Ä‚ï¿½ï¿½é‚±ï¿½Æ‚Éˆï¿½v
	if (discr < 0.0f) { return false; }

	// ï¿½ï¿½ï¿½Cï¿½Í‹ï¿½ï¿½ÆŒï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Åï¿½ï¿½Ì’ltï¿½ï¿½ï¿½vï¿½Z
	float t = -b - sqrtf(discr);

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½ê‡ï¿½Aï¿½ï¿½ï¿½Cï¿½Í‹ï¿½ï¿½Ì“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½nï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½Ì‚Å‚ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ÉƒNï¿½ï¿½ï¿½ï¿½ï¿½v
	if (t < 0)t = 0.0f;
	if (distance) { *distance = t; }

	if (inter) { *inter = ray.start + t * ray.dir; }

	return true;
}


============================================================
File Path: engine/collision/Collision.h
============================================================
#pragma once

#include "CollisionPrimitive.h"

class Collision
{
public:
	//ï¿½ï¿½ï¿½Æ‹ï¿½ï¿½Ì“ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	static bool CheckSphere2Sphere(const Sphere& sphereA, const Sphere& sphereB, Vector3* inter = nullptr, Vector3* reject = nullptr);
	//ï¿½ï¿½ï¿½Æ•ï¿½ï¿½Ê‚Ì“ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	static bool CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter = nullptr);

	//ï¿½_ï¿½ÆŽOï¿½pï¿½`ï¿½ÌÅ‹ß‚ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	static void ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest);

	//ï¿½ï¿½ï¿½Æ–@ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½Oï¿½pï¿½`ï¿½Ì“ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	static bool CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter = nullptr, Vector3* reject = nullptr);

	//ï¿½ï¿½ï¿½Cï¿½Æ•ï¿½ï¿½Ê‚Ì“ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	static bool CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance = nullptr, Vector3* inter = nullptr);

	//ï¿½ï¿½ï¿½Cï¿½Æ–@ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½Oï¿½pï¿½`ï¿½Ì“ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	static bool CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance = nullptr, Vector3* inter = nullptr);

	//ï¿½ï¿½ï¿½Cï¿½Æ‹ï¿½ï¿½Ì“ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	static bool CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance = nullptr, Vector3* inter = nullptr);
};



============================================================
File Path: engine/collision/CollisionInfo.h
============================================================
#pragma once
#include"Vector3.h"

class Object3d;
class BaseCollider;


struct CollisionInfo
{
public:
	CollisionInfo(Object3d* object, BaseCollider* collider, const Vector3& inter) {
		this->object = object;
		this->collider = collider;
		this->inter = inter;
	}

	// ï¿½Õ“Ë‘ï¿½ï¿½ï¿½ÌƒIï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	Object3d* object = nullptr;
	// ï¿½Õ“Ë‘ï¿½ï¿½ï¿½ÌƒRï¿½ï¿½ï¿½Cï¿½_ï¿½[
	BaseCollider* collider = nullptr;
	// ï¿½Õ“Ë“_
	Vector3 inter;

};

============================================================
File Path: engine/collision/CollisionManager.cpp
============================================================
#include "CollisionManager.h"
#include "BaseCollider.h"
#include "Collision.h"

using namespace DirectX;

CollisionManager* CollisionManager::GetInstance()
{
	static CollisionManager instance;
	return &instance;
}

void CollisionManager::CheckAllCollisions()
{
	std::forward_list<BaseCollider*>::iterator itA;
	std::forward_list<BaseCollider*>::iterator itB;

	//ï¿½Sï¿½Ä‚Ì‘gï¿½Ýï¿½ï¿½í‚¹ï¿½É‚Â‚ï¿½ï¿½Ä‘ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	itA = colliders.begin();
	for (; itA != colliders.end(); ++itA)
	{
		itB = itA;
		++itB;
		for (; itB != colliders.end(); ++itB)
		{
			BaseCollider* colA = *itA;
    		BaseCollider* colB = *itB;
			//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½
			colA->GetObject3d()->toCollisionName = colB->GetName();
			colB->GetObject3d()->toCollisionName = colA->GetName();
			

			// ï¿½Æ‚ï¿½ï¿½É‹ï¿½
			if (colA->GetShapeType() == COLLISIONSHAPE_SPHERE &&
				colB->GetShapeType() == COLLISIONSHAPE_SPHERE) {
				Sphere* SphereA = dynamic_cast<Sphere*>(colA);
				Sphere* SphereB = dynamic_cast<Sphere*>(colB);
				Vector3 inter;
				Vector3 reject;
				if (Collision::CheckSphere2Sphere(*SphereA, *SphereB, &inter,&reject)) {
					colA->OnCollision(CollisionInfo(colB->GetObject3d(), colB, inter));
					colB->OnCollision(CollisionInfo(colA->GetObject3d(), colA, inter));
				}
			}
		}
	}
}

bool CollisionManager::Raycast(const Ray& ray, RaycastHit* hitInfo, float maxDistance)
{
	bool result = false;
	//ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½ÌƒCï¿½eï¿½ï¿½ï¿½[ï¿½^
	std::forward_list<BaseCollider*>::iterator it;
	//ï¿½ï¿½ï¿½Ü‚Å‚ÅÅ‚ï¿½ï¿½ß‚ï¿½ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½ï¿½ï¿½Lï¿½^ï¿½ï¿½ï¿½é‚½ï¿½ß‚ÌƒCï¿½eï¿½ï¿½ï¿½[ï¿½^
	std::forward_list<BaseCollider*>::iterator it_hit;
	//ï¿½ï¿½ï¿½Ü‚Å‚ÅÅ‚ï¿½ï¿½ß‚ï¿½ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½^ï¿½ï¿½ï¿½ï¿½Ïï¿½
	float distance = maxDistance;
	//ï¿½ï¿½ï¿½Ü‚Å‚ÅÅ‚ï¿½ï¿½ß‚ï¿½ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Æ‚ÌŒï¿½_ï¿½ï¿½ï¿½Lï¿½^ï¿½ï¿½ï¿½ï¿½Ïï¿½
	Vector3 inter;

	//ï¿½Sï¿½Ä‚ÌƒRï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Æ‘ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	it = colliders.begin();
	for (; it != colliders.end(); ++it)
	{
		BaseCollider* colA = *it;
		//ï¿½ï¿½ï¿½Ìê‡
		if (colA->GetShapeType() == COLLISIONSHAPE_SPHERE)
		{
			Sphere* sphere = dynamic_cast<Sphere*>(colA);
			float tempDistance;
			Vector3 tempInter;
			//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½ï¿½Îï¿½ï¿½O
			if (!Collision::CheckRay2Sphere(ray, *sphere, &tempDistance, &tempInter))continue;
			//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Åï¿½ï¿½oï¿½È‚ï¿½ï¿½ï¿½Îï¿½ï¿½O
			if (tempDistance >= distance)continue;
			//ï¿½ï¿½ï¿½Ü‚Å‚ÅÅ‚ï¿½ï¿½ß‚ï¿½ï¿½Ì‚Å‹Lï¿½^ï¿½ï¿½ï¿½Æ‚ï¿½
			result = true;
			distance = tempDistance;
			inter = tempInter;
			it_hit = it;
			//ï¿½ÅIï¿½Iï¿½É‰ï¿½ï¿½ï¿½ï¿½É“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ï¿½çŒ‹ï¿½Ê‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
			if (result && hitInfo)
			{
				hitInfo->distance = distance;
				hitInfo->inter = inter;
				hitInfo->collider = *it_hit;
				hitInfo->object = hitInfo->collider->GetObject3d();
			}
			return result;
		}
	}
	return false;
}

============================================================
File Path: engine/collision/CollisionManager.h
============================================================
#pragma once
#include "CollisionPrimitive.h"
#include "RaycastHit.h"

#include <forward_list>
#include <d3d12.h>

class BaseCollider;

class CollisionManager
{
public://ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	static CollisionManager* GetInstance();

public://ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	//ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Ì’Ç‰ï¿½
	inline void AddCollider(BaseCollider* collider)
	{
		colliders.push_front(collider);
	}
	//ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Ìíœ
	inline void RemoveCollider(BaseCollider* collider)
	{
		colliders.remove(collider);
	}
	//ï¿½Sï¿½Ä‚ÌÕ“Ëƒ`ï¿½Fï¿½bï¿½N
	void CheckAllCollisions();
	//ï¿½ï¿½ï¿½Cï¿½Lï¿½ï¿½ï¿½Xï¿½g
	bool Raycast(const Ray& ray, RaycastHit* hitInfo = nullptr, float maxDistance = D3D12_FLOAT32_MAX);
private:
	CollisionManager() = default;
	CollisionManager(const CollisionManager&) = delete;
	~CollisionManager() = default;
	CollisionManager& operator = (const CollisionManager&) = delete;
	//ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Ìƒï¿½ï¿½Xï¿½g
	std::forward_list<BaseCollider*>colliders;
};



============================================================
File Path: engine/collision/CollisionPrimitive.cpp
============================================================
#include "CollisionPrimitive.h"

void Triangle::ComputeNormal()
{
	Vector3 p0_p1 = p1 - p0;
	Vector3 p0_p2 = p2 - p0;
	Vector3 V;

	// ï¿½Oï¿½Ï‚É‚ï¿½ï¿½Aï¿½Qï¿½Ó‚Éï¿½ï¿½ï¿½ï¿½Èƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½oï¿½ï¿½ï¿½ï¿½
	normal = p0_p1.cross(p0_p2);
	normal.normalize();
}

============================================================
File Path: engine/collision/CollisionPrimitive.h
============================================================
#pragma once
#pragma once
#include<DirectXMath.h>
#include "Vector3.h"

//ï¿½ï¿½
struct Sphere
{
	//ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½W
	Vector3 center = { 0,0,0 };
	//ï¿½ï¿½ï¿½a
	float radius = 1.0f;
	//ï¿½ï¿½ï¿½W
	Vector3 position = { 0,0,0 };
};
//ï¿½ï¿½ï¿½ï¿½
struct Plane
{
	//ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	Vector3 normal = { 0,1,0 };
	//ï¿½ï¿½ï¿½_(0,0,0)ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½ï¿½
	float distance = 0.0f;
};
//ï¿½ï¿½ï¿½C
struct Ray
{
	//ï¿½nï¿½_ï¿½ï¿½ï¿½W
	Vector3 start = { 0,0,0 };

	//ï¿½ï¿½ï¿½ï¿½
	Vector3 dir = { 1,0,0 };
};

//ï¿½@ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½Oï¿½pï¿½`(ï¿½ï¿½ï¿½vï¿½ï¿½è‚ªï¿½\ï¿½ï¿½)
class Triangle
{
public:
	//ï¿½ï¿½ï¿½_3ï¿½ï¿½
	Vector3 p0;
	Vector3 p1;
	Vector3 p2;
	//ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
	Vector3 normal;

	//ï¿½@ï¿½ï¿½ï¿½ÌŒvï¿½Z
	void ComputeNormal();
};

class CollisionPrimitive
{
public:
};



============================================================
File Path: engine/collision/CollisionTypes.h
============================================================
#pragma once

//ï¿½Õ“Ë”ï¿½ï¿½ï¿½pï¿½ÌŒ^ï¿½ï¿½`

enum CollisionShapeType
{
	SHAPE_UNKNOWN = -1,//ï¿½ï¿½ï¿½Ý’ï¿½

	COLLISIONSHAPE_SPHERE,//ï¿½ï¿½
};

============================================================
File Path: engine/collision/RaycastHit.h
============================================================
#pragma once
#include "BaseCollider.h"
#include <DirectXMath.h>

class Object3d;

//ï¿½ï¿½ï¿½Cï¿½Lï¿½ï¿½ï¿½Xï¿½gï¿½É‚ï¿½ï¿½ï¿½ï¿½ð“¾‚é‚½ï¿½ß‚Ì\ï¿½ï¿½ï¿½ï¿½
struct RaycastHit
{
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½ÌƒIï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	Object3d* object = nullptr;
	//ï¿½Õ“Ë‘ï¿½ï¿½ï¿½ÌƒRï¿½ï¿½ï¿½Cï¿½_ï¿½[
	BaseCollider* collider = nullptr;
	//ï¿½Õ“Ë“_
	Vector3 inter;
	//ï¿½Õ“Ë“_ï¿½Ü‚Å‚Ì‹ï¿½ï¿½ï¿½
	float distance = 0.0f;
};

============================================================
File Path: engine/collision/SphereCollider.cpp
============================================================
#include "SphereCollider.h"

void SphereCollider::Update()
{
	// ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½sï¿½ñ‚©‚ï¿½ï¿½ï¿½Wï¿½ð’Šo
	const Matrix4& matWorld = object3d->worldTransform_.matWorld_;

	const Vector3& position = { matWorld.m[3][0],matWorld.m[3][1] ,matWorld.m[3][2] };

	//Vector4 matVec;
	//matVec.x = matWorld.m[3][0];
	//matVec.y = matWorld.m[3][1];
	//matVec.z = matWorld.m[3][2];
	//matVec.w = matWorld.m[3][3];

	// ï¿½ï¿½ï¿½Ìƒï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½ï¿½ï¿½Xï¿½V
	Sphere::center = position + offset;
	Sphere::radius = radius;
}

============================================================
File Path: engine/collision/SphereCollider.h
============================================================
#pragma once
#include "BaseCollider.h"
#include "CollisionPrimitive.h"

#include "Vector3.h"
#include "Matrix4.h"


class SphereCollider :public BaseCollider, public Sphere
{
private:// ï¿½Gï¿½Cï¿½ï¿½ï¿½Aï¿½X
public:
	SphereCollider(Vector3 offset = { 0,0,0 }, float radius = 1.0f) :offset(offset), radius(radius) {
		// ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½g
		shapeType = COLLISIONSHAPE_SPHERE;
	}

	// ï¿½Xï¿½V
	void Update()override;

	inline const Vector3& GetOffset() { return offset; }

	inline void SetOffset(const Vector3& offset) { this->offset = offset; }

	inline float GetRadius() { return radius; }

	inline void SetRadius(float radius) { this->radius = radius; }

private:
	// ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½ÌƒIï¿½tï¿½Zï¿½bï¿½g
	Vector3 offset;
	// ï¿½ï¿½ï¿½a
	float radius;
};

============================================================
File Path: engine/effect/Particle.cpp
============================================================
#include "Particle.h"
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <Windows.h>
#include <cassert>
#include <sstream>
#include <string>
#include <fstream>
#include <vector>

using namespace DirectX;
using namespace std;

//ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½ÌŽï¿½ï¿½ï¿½
ID3D12Device* Particle::device_ = nullptr;
std::string Particle::defaultTextureDirectoryPath_ = "Resources/";

Particle* Particle::LoadParticleTexture(const std::string& fileName)
{
	//ï¿½Vï¿½ï¿½ï¿½ï¿½Modelï¿½^ï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½Ìƒï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½
	Particle* particle = new Particle();

	//ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ï¿½ï¿½ï¿½
	particle->InitializeDescriptorHeap();

	//OBJï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ìƒfï¿½[ï¿½^ï¿½Ç‚Ýï¿½ï¿½ï¿½
	particle->LoadTexture(fileName);

	//ï¿½Ç‚Ýï¿½ï¿½ñ‚¾ƒfï¿½[ï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ÉŠeï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	particle->CreateBuffers();

	return particle;
}

void Particle::InitializeDescriptorHeap()
{

	HRESULT result = S_FALSE;

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ð¶ï¿½	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½çŒ©ï¿½ï¿½ï¿½ï¿½æ‚¤ï¿½ï¿½
	descHeapDesc.NumDescriptors = 1; // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[1ï¿½ï¿½
	result = device_->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap_));//ï¿½ï¿½ï¿½ï¿½
	if (FAILED(result)) {
		assert(0);
	}

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½Tï¿½Cï¿½Yï¿½ï¿½ï¿½æ“¾
	descriptorHandleIncrementSize_ = device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

void Particle::LoadTexture(const std::string& fileName)
{
	HRESULT result;

	//ï¿½fï¿½Bï¿½ï¿½ï¿½Nï¿½gï¿½ï¿½ï¿½pï¿½Xï¿½Æƒtï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½ï¿½Äƒtï¿½ï¿½ï¿½pï¿½Xï¿½ð“¾‚ï¿½
	std::string fullPath = defaultTextureDirectoryPath_ + fileName;

	//ï¿½ï¿½ï¿½Cï¿½hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Û‚Ì•ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Tï¿½Cï¿½Yï¿½ï¿½ï¿½vï¿½Z
	int filePathBufferSize = MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, nullptr, 0);

	//ï¿½ï¿½ï¿½Cï¿½hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½É•ÏŠï¿½
	std::vector<wchar_t> wfilePath(filePathBufferSize);
	MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, wfilePath.data(), filePathBufferSize);

	//ï¿½æ‘œï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Ì—pï¿½ï¿½
	TexMetadata metadata{};
	ScratchImage scratchImg{};
	//WICï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ìƒï¿½ï¿½[ï¿½h
	result = LoadFromWICFile(
		wfilePath.data(),	//Resourcesï¿½tï¿½Hï¿½ï¿½ï¿½_ï¿½ï¿½texture.png
		WIC_FLAGS_NONE,
		&metadata, scratchImg);

	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	//ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½ï¿½
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result))
	{
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}
	//ï¿½Ç‚Ýï¿½ï¿½ñ‚¾ƒfï¿½Bï¿½tï¿½ï¿½ï¿½[ï¿½Yï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½SRGBï¿½Æ‚ï¿½ï¿½Äˆï¿½ï¿½ï¿½
	metadata.format = MakeSRGB(metadata.format);

	// ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
	D3D12_HEAP_PROPERTIES textureHeapProp{};
	textureHeapProp.Type = D3D12_HEAP_TYPE_CUSTOM;
	textureHeapProp.CPUPageProperty =
		D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
	textureHeapProp.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;
	//ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	D3D12_RESOURCE_DESC textureResourceDesc{};
	textureResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	textureResourceDesc.Format = metadata.format;
	textureResourceDesc.Width = metadata.width;							//ï¿½ï¿½
	textureResourceDesc.Height = (UINT)metadata.height;				//ï¿½ï¿½ï¿½ï¿½
	textureResourceDesc.DepthOrArraySize = (UINT16)metadata.arraySize;
	textureResourceDesc.MipLevels = (UINT16)metadata.mipLevels;
	textureResourceDesc.SampleDesc.Count = 1;

	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device_->CreateCommittedResource(
		&textureHeapProp,
		D3D12_HEAP_FLAG_NONE,
		&textureResourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&texBuff_));
	assert(SUCCEEDED(result));

	for (size_t i = 0; i < metadata.mipLevels; i++)
	{
		//ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½ÄƒCï¿½ï¿½ï¿½[ï¿½Wï¿½ï¿½ï¿½æ“¾
		const Image* img = scratchImg.GetImage(i, 0, 0);
		//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
		result = texBuff_->WriteToSubresource(
			(UINT)i,
			nullptr,							//ï¿½Sï¿½Ìˆï¿½ÖƒRï¿½sï¿½[
			img->pixels,						//ï¿½ï¿½ï¿½fï¿½[ï¿½^ï¿½Aï¿½hï¿½ï¿½ï¿½X
			(UINT)img->rowPitch,				//1ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Tï¿½Cï¿½Y
			(UINT)img->slicePitch				//1ï¿½ï¿½ï¿½Tï¿½Cï¿½Y
		);
		assert(SUCCEEDED(result));
	}


	//SRVï¿½qï¿½[ï¿½vï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	cpuDescHandleSRV_ = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap_->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize_);
	gpuDescHandleSRV_ = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap_->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize_);

	//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½Ý’ï¿½
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};				//ï¿½Ý’ï¿½\ï¿½ï¿½ï¿½ï¿½
	srvDesc.Format = textureResourceDesc.Format;
	srvDesc.Shader4ComponentMapping =
		D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;	//2Dï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
	srvDesc.Texture2D.MipLevels = textureResourceDesc.MipLevels;

	//ï¿½nï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ÌŽwï¿½ï¿½ï¿½Ê’uï¿½ÉƒVï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ì¬
	device_->CreateShaderResourceView(texBuff_.Get(), &srvDesc, cpuDescHandleSRV_);

}

void Particle::CreateBuffers()
{
	HRESULT result = S_FALSE;

	std::vector<VertexPosScale> realVertices;

	UINT sizeVB = static_cast<UINT>(sizeof(vertices_));

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	result = device_->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff_));
	assert(SUCCEEDED(result));

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	VertexPosScale* vertMap = nullptr;
	result = vertBuff_->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		memcpy(vertMap, vertices_, sizeof(vertices_));
		vertBuff_->Unmap(0, nullptr);
	}

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½Ìì¬
	vbView_.BufferLocation = vertBuff_->GetGPUVirtualAddress();
	vbView_.SizeInBytes = sizeof(vertices_);
	vbView_.StrideInBytes = sizeof(vertices_[0]);


}

void Particle::Update()
{
	HRESULT result;
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½ï¿½Sï¿½íœ
	particles_.remove_if([](OneParticle& x) {return x.frame >= x.num_frame; });
	//ï¿½Sï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½Xï¿½V
	for (std::forward_list<OneParticle>::iterator it = particles_.begin();
		it != particles_.end(); it++)
	{
		//ï¿½oï¿½ßƒtï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½Eï¿½ï¿½ï¿½g
		it->frame++;
		//ï¿½ï¿½ï¿½xï¿½É‰ï¿½ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½ï¿½Z
		it->velocity = it->velocity + it->accel;
		//ï¿½ï¿½ï¿½xï¿½É‚ï¿½ï¿½Ú“ï¿½
		it->position = it->position + it->velocity;

		//ï¿½iï¿½sï¿½xï¿½ï¿½0~1ï¿½Ì”ÍˆÍ‚ÉŠï¿½ï¿½Z
		float f = (float)it->frame / it->num_frame;
		//ï¿½Xï¿½Pï¿½[ï¿½ï¿½ï¿½Ìï¿½ï¿½`ï¿½ï¿½ï¿½
		it->scale = (it->e_Scale - it->s_Scale) * f;
		it->scale += it->s_Scale;
	}
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Öƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	VertexPosScale* vertMap = nullptr;
	result = vertBuff_->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result))
	{
		//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½1ï¿½Â‚ï¿½ï¿½Â”ï¿½ï¿½f
		for (std::forward_list<OneParticle>::iterator it = particles_.begin();
			it != particles_.end(); it++)
		{
			//ï¿½ï¿½ï¿½W
			vertMap->pos = it->position;
			//ï¿½Xï¿½Pï¿½[ï¿½ï¿½
			vertMap->scale = it->scale;
			//ï¿½ï¿½ï¿½Ì’ï¿½ï¿½_ï¿½ï¿½
			vertMap++;
		}
		vertBuff_->Unmap(0, nullptr);
	}

}

void Particle::Draw(ID3D12GraphicsCommandList* cmdList)
{
	// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device_);
	assert(cmdList);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ÌÝ’ï¿½
	cmdList->IASetVertexBuffers(0, 1, &vbView_);

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ì”zï¿½ï¿½
	ID3D12DescriptorHeap* ppHeaps[] = { descHeap_.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootDescriptorTable(1, gpuDescHandleSRV_);

	// ï¿½`ï¿½ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	cmdList->DrawInstanced((UINT)std::distance(particles_.begin(), particles_.end()), 1, 0, 0);

}

void Particle::Add(int life, XMFLOAT3 position, XMFLOAT3 velocity, XMFLOAT3 accel, float start_scale, float end_scale)
{
	//ï¿½ï¿½ï¿½Xï¿½gï¿½É—vï¿½fï¿½ï¿½Ç‰ï¿½
	particles_.emplace_front();
	//ï¿½Ç‰ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vï¿½fï¿½ÌŽQï¿½ï¿½
	OneParticle& p = particles_.front();
	//ï¿½lï¿½Zï¿½bï¿½g
	p.position = position;
	p.velocity = velocity;
	p.accel = accel;
	p.num_frame = life;

	p.s_Scale = start_scale;
	p.e_Scale = end_scale;
	p.scale = p.s_Scale;
}

const DirectX::XMFLOAT3 operator+(const DirectX::XMFLOAT3& lhs, const DirectX::XMFLOAT3& rhs)
{
	XMFLOAT3 result;

	result.x = lhs.x + rhs.x;
	result.y = lhs.y + rhs.y;
	result.z = lhs.z + rhs.z;
	return result;
}

============================================================
File Path: engine/effect/Particle.h
============================================================
#pragma once
#include <d3d12.h>
#include <d3dx12.h>
#include <DirectXMath.h>
#include <wrl.h>
#include <forward_list>

class Particle
{
private://ï¿½Gï¿½Cï¿½ï¿½ï¿½Aï¿½X
	// Microsoft::WRL::ï¿½ï¿½ï¿½È—ï¿½
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::ï¿½ï¿½ï¿½È—ï¿½
	using XMFLOAT2 = DirectX::XMFLOAT2;
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMFLOAT4 = DirectX::XMFLOAT4;
	using XMMATRIX = DirectX::XMMATRIX;

public://ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X

	struct VertexPosScale
	{
		XMFLOAT3 pos; // xyzï¿½ï¿½ï¿½W
		float scale;  //ï¿½Xï¿½Pï¿½[ï¿½ï¿½
	};

	//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½ê—±
	struct OneParticle
	{
		//DirectX::ï¿½ï¿½ï¿½È—ï¿½
		using XMFLOAT3 = DirectX::XMFLOAT3;

		//ï¿½ï¿½ï¿½W
		XMFLOAT3 position = {};
		//ï¿½ï¿½ï¿½x
		XMFLOAT3 velocity = {};
		//ï¿½ï¿½ï¿½ï¿½ï¿½x
		XMFLOAT3 accel = {};
		//ï¿½ï¿½ï¿½Ýƒtï¿½ï¿½ï¿½[ï¿½ï¿½
		int frame = 0;
		//ï¿½Iï¿½ï¿½ï¿½tï¿½ï¿½ï¿½[ï¿½ï¿½
		int num_frame = 0;

		//ï¿½Xï¿½Pï¿½[ï¿½ï¿½
		float scale = 1.0f;
		//ï¿½ï¿½ï¿½ï¿½ï¿½l
		float s_Scale = 1.0f;
		//ï¿½ÅIï¿½l
		float e_Scale = 0.0f;
	};

private://ï¿½è”
	static const int vertexCount = 1024;		// ï¿½ï¿½ï¿½_ï¿½ï¿½

public://ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½

	//OBJï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	static Particle* LoadParticleTexture(const std::string& fileName);
	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	void InitializeDescriptorHeap();
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	void LoadTexture(const std::string& fileName);

	//ï¿½eï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	void CreateBuffers();
	//ï¿½Xï¿½V
	void Update();
	// ï¿½`ï¿½ï¿½
	void Draw(ID3D12GraphicsCommandList* cmdList);

	//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½Ì’Ç‰ï¿½
	void Add(int life, XMFLOAT3 position, XMFLOAT3 velocity, XMFLOAT3 accel,
		float start_scale, float end_scale);

private://ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	// ï¿½fï¿½oï¿½Cï¿½X
	static ID3D12Device* device_;
	//ï¿½fï¿½tï¿½Hï¿½ï¿½ï¿½gï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½iï¿½[ï¿½fï¿½Bï¿½ï¿½ï¿½Nï¿½gï¿½ï¿½
	static std::string defaultTextureDirectoryPath_;

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½Tï¿½Cï¿½Y
	UINT descriptorHandleIncrementSize_;
	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½v
	ComPtr<ID3D12DescriptorHeap> descHeap_;
	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> texBuff_;
	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½(CPU)
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuDescHandleSRV_;
	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½(CPU)
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuDescHandleSRV_;
	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> vertBuff_;
	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[
	D3D12_VERTEX_BUFFER_VIEW vbView_;
	//ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^ï¿½zï¿½ï¿½
	VertexPosScale vertices_[vertexCount];

	std::forward_list<OneParticle> particles_;

public://setter
	//ï¿½fï¿½oï¿½Cï¿½X
	static void SetDevice(ID3D12Device* device) { Particle::device_ = device; }

};

const DirectX::XMFLOAT3 operator+(const DirectX::XMFLOAT3& lhs, const DirectX::XMFLOAT3& rhs);

============================================================
File Path: engine/effect/ParticleManager.cpp
============================================================
#include "ParticleManager.h"
#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;

/// ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½ï¿½ÌŽï¿½ï¿½ï¿½
ID3D12Device* ParticleManager::device_ = nullptr;
ID3D12GraphicsCommandList* ParticleManager::cmdList = nullptr;
ComPtr<ID3D12RootSignature> ParticleManager::rootsignature;
ComPtr<ID3D12PipelineState> ParticleManager::pipelinestate;

void ParticleManager::StaticInitialize(ID3D12Device* device)
{
	// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device);

	device_ = device;

	Particle::SetDevice(device_);

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	InitializeGraphicsPipeline();
}

void ParticleManager::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	// PreDrawï¿½ï¿½PostDrawï¿½ï¿½ï¿½yï¿½Aï¿½ÅŒÄ‚Î‚ï¿½Ä‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½ÎƒGï¿½ï¿½ï¿½[
	assert(ParticleManager::cmdList == nullptr);

	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Zï¿½bï¿½g
	ParticleManager::cmdList = cmdList;

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½ÌÝ’ï¿½
	cmdList->SetPipelineState(pipelinestate.Get());
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// ï¿½vï¿½ï¿½ï¿½~ï¿½eï¿½Bï¿½uï¿½`ï¿½ï¿½ï¿½Ý’ï¿½
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_POINTLIST);
}

void ParticleManager::PostDraw()
{
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	ParticleManager::cmdList = nullptr;
}

ParticleManager* ParticleManager::Create()
{
	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½ð¶ï¿½
	ParticleManager* object3d = new ParticleManager();
	if (object3d == nullptr) {
		return nullptr;
	}

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	if (!object3d->Initialize()) {
		delete object3d;
		assert(0);
		return nullptr;
	}

	return object3d;
}

void ParticleManager::InitializeGraphicsPipeline()
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> gsBlob; // ï¿½Wï¿½Iï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> psBlob;	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> errorBlob; // ï¿½Gï¿½ï¿½ï¿½[ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g

	// ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticleVS.hlsl",	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "vs_5_0",	// ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ï¿½Wï¿½Iï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticleGS.hlsl", // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "gs_5_0", // ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Nï¿½pï¿½Ý’ï¿½
		0,
		&gsBlob, &errorBlob
	);
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "/n";
		//ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}
	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticlePS.hlsl",	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "ps_5_0",	// ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½g
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyï¿½ï¿½ï¿½W(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{//ï¿½Xï¿½Pï¿½[ï¿½ï¿½
			"TEXCOORD", 0, DXGI_FORMAT_R32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

	};

	// ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½Xï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ì—ï¿½ï¿½ï¿½ï¿½Ý’ï¿½
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.GS = CD3DX12_SHADER_BYTECODE(gsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½}ï¿½Xï¿½N
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // ï¿½Wï¿½ï¿½ï¿½Ý’ï¿½
	// ï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Cï¿½Uï¿½Xï¿½eï¿½[ï¿½g
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// ï¿½fï¿½vï¿½Xï¿½Xï¿½eï¿½ï¿½ï¿½Vï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½g
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	//ï¿½fï¿½vï¿½Xï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ý‚ï¿½ï¿½ÖŽ~
	gpipeline.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½Ìƒuï¿½ï¿½ï¿½ï¿½ï¿½hï¿½Ý’ï¿½
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAï¿½Sï¿½Ä‚Ìƒ`ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½
	blenddesc.BlendEnable = true;
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	/*blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;*/

	//ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_ONE;
	blenddesc.DestBlend = D3D12_BLEND_ONE;
	//ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½
	/*blenddesc.BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
	blenddesc.SrcBlend = D3D12_BLEND_ONE;
	blenddesc.DestBlend = D3D12_BLEND_ONE;*/

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½hï¿½Xï¿½eï¿½[ï¿½gï¿½ÌÝ’ï¿½
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// ï¿½[ï¿½xï¿½oï¿½bï¿½tï¿½@ï¿½Ìƒtï¿½Hï¿½[ï¿½}ï¿½bï¿½g
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½gï¿½ÌÝ’ï¿½
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// ï¿½}ï¿½`ï¿½ÌŒ`ï¿½ï¿½Ý’ï¿½iï¿½Oï¿½pï¿½`ï¿½j
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;

	gpipeline.NumRenderTargets = 1;	// ï¿½`ï¿½ï¿½ÎÛ‚ï¿½1ï¿½ï¿½
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï¿½`255ï¿½wï¿½ï¿½ï¿½RGBA
	gpipeline.SampleDesc.Count = 1; // 1ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½É‚Â‚ï¿½1ï¿½ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½O

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½W
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 ï¿½ï¿½ï¿½Wï¿½Xï¿½^

	// ï¿½ï¿½ï¿½[ï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^
	#pragma warning(push)
	#pragma warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[2];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// ï¿½Xï¿½^ï¿½eï¿½Bï¿½bï¿½Nï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½[
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// ï¿½oï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÌƒVï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Cï¿½Y
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	result = device_->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½Xï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	result = device_->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}


bool ParticleManager::Initialize()
{
	// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device_);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferData) + 0xff) & ~0xff);

	HRESULT result;

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device_->CreateCommittedResource(
		&heapProps, // ï¿½Aï¿½bï¿½vï¿½ï¿½ï¿½[ï¿½hï¿½Â”\
		D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));

	return true;
}

void ParticleManager::Update()
{

	HRESULT result;

	particle->Update();
	XMMATRIX matView = xmViewProjection->GetMatViewProjection();
	XMMATRIX matBillboard = xmViewProjection->GetMatBillboard();

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Öƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	ConstBufferData* constMap = nullptr;
	result = constBuff->Map(0, nullptr, (void**)&constMap);
	//ï¿½sï¿½ï¿½Ìï¿½ï¿½ï¿½
	constMap->mat = matView;
	constMap->matBillboard = matBillboard;
	constBuff->Unmap(0, nullptr);
}

void ParticleManager::Draw()
{
	// nullptrï¿½`ï¿½Fï¿½bï¿½N
	assert(device_);
	assert(ParticleManager::cmdList);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootConstantBufferView(0, constBuff->GetGPUVirtualAddress());

	particle->Draw(cmdList);
}

void ParticleManager::Fire(Particle* particle, const float& setpos, const float& setvel, const float& setacc, const int& setnum, const XMFLOAT2& setscale)
{
	for (int i = 0; i < setnum; i++)
	{
		//X,Y,Zï¿½Sï¿½ï¿½{-20.0f,20.0f}ï¿½Åƒï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½É•ï¿½ï¿½z
		const float md_pos = setpos;
		XMFLOAT3 pos{};
		pos.x = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		pos.y = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		pos.z = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		//X,Y,Zï¿½Sï¿½ï¿½{0.1f,0.1f}ï¿½Åƒï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½É•ï¿½ï¿½z
		const float md_vel = setvel;
		XMFLOAT3 vel{};
		vel.x = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		vel.y = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		vel.z = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		//ï¿½dï¿½Í‚ÉŒï¿½ï¿½ï¿½ï¿½Ä‚ï¿½Yï¿½Ì‚ï¿½{0.001f,0}ï¿½Åƒï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½É•ï¿½ï¿½z
		XMFLOAT3 acc{};
		const float md_acc = setacc;
		acc.y = -(float)rand() / RAND_MAX * md_acc;

		//ï¿½Ç‰ï¿½
		particle->Add(60, pos, vel, acc, setscale.x, setscale.y);
	}
}

============================================================
File Path: engine/effect/ParticleManager.h
============================================================
#pragma once

#include "Particle.h"
#include "XMViewProjection.h"
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include <d3dx12.h>

/// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
class ParticleManager
{
private: // ï¿½Gï¿½Cï¿½ï¿½ï¿½Aï¿½X
	// Microsoft::WRL::ï¿½ï¿½ï¿½È—ï¿½
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::ï¿½ï¿½ï¿½È—ï¿½
	using XMFLOAT2 = DirectX::XMFLOAT2;
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMFLOAT4 = DirectX::XMFLOAT4;
	using XMMATRIX = DirectX::XMMATRIX;

public: // ï¿½Tï¿½uï¿½Nï¿½ï¿½ï¿½X
	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½pï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½
	struct ConstBufferData
	{
		//XMFLOAT4 color;	// ï¿½F (RGBA)
		XMMATRIX mat;	// ï¿½Rï¿½cï¿½ÏŠï¿½ï¿½sï¿½ï¿½
		XMMATRIX matBillboard;	//ï¿½rï¿½ï¿½ï¿½{ï¿½[ï¿½hï¿½sï¿½ï¿½
	};
public: // ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	/// ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	static void StaticInitialize(ID3D12Device* device);

	/// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);

	/// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	static void PostDraw();

	/// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	static ParticleManager* Create();

private: // ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	// ï¿½fï¿½oï¿½Cï¿½X
	static ID3D12Device* device_;
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½g
	static ID3D12GraphicsCommandList* cmdList;
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½
	static ComPtr<ID3D12RootSignature> rootsignature;
	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	static ComPtr<ID3D12PipelineState> pipelinestate;

private:// ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½

	/// ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	static void InitializeGraphicsPipeline();

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	bool Initialize();
	/// ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Update();

	/// ï¿½`ï¿½ï¿½
	void Draw();

	/// ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Fire(Particle* particle, const float& setpos, const float& setvel, const float& setacc, const int& setnum, const XMFLOAT2& setscale);

private: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	ComPtr<ID3D12Resource> constBuff; // ï¿½è”ï¿½oï¿½bï¿½tï¿½@
	//ï¿½Xï¿½Pï¿½[ï¿½ï¿½
	XMFLOAT3 scale = { 1,1,1 };

	//DirectXMathï¿½ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½ViewProjection
	XMViewProjection* xmViewProjection = nullptr;
	//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½
	Particle* particle = nullptr;

public://setter
	//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½
	void SetParticleModel(Particle* particlemodel) { this->particle = particlemodel; }
	//ï¿½Jï¿½ï¿½ï¿½ï¿½
	void SetXMViewProjection(XMViewProjection* xmViewProjection) { this->xmViewProjection = xmViewProjection; }
};

============================================================
File Path: engine/effect/PostEffect.cpp
============================================================
#include "PostEffect.h"
#include "WinApp.h"

const float PostEffect::clearColor[4] = { 0.25f,0.5f,0.1f,0.0f };

void PostEffect::Initialize(ID3D12Device* dev)
{
	device = dev;
	HRESULT result;

	//ï¿½ï¿½ï¿½_ï¿½fï¿½[ï¿½^
	VertexPosUv vertices[] = {
		{{	-1.0f, -1.0f,	0.0f},{0.0f,1.0f}},
		{{	-1.0f,	+1.0f,	0.0f},{0.0f,0.0f}},
		{{	+1.0f, -1.0f,	0.0f},{1.0f,1.0f}},
		{{	+1.0f,	+1.0f,	0.0f},{1.0f,0.0f}},
	};

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapPropsVertexBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDescVertexBuffer =
		CD3DX12_RESOURCE_DESC::Buffer(sizeof(vertices));

	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapPropsVertexBuffer, // ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
		D3D12_HEAP_FLAG_NONE,
		&resourceDescVertexBuffer, // ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½Ö‚Ìƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	VertexPosUv* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	vertBuff->Unmap(0, nullptr);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[ï¿½Ìì¬
// GPUï¿½ï¿½ï¿½zï¿½Aï¿½hï¿½ï¿½ï¿½X
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ÌƒTï¿½Cï¿½Y
	vbView.SizeInBytes = sizeof(VertexPosUv) * 4;
	// ï¿½ï¿½ï¿½_1ï¿½Â•ï¿½ï¿½Ìƒfï¿½[ï¿½^ï¿½Tï¿½Cï¿½Y
	vbView.StrideInBytes = sizeof(VertexPosUv);

	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapPropsConstantBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC resourceDescConstantBuffer =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferData) + 0xff) & ~0xff);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapPropsConstantBuffer, // ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
		D3D12_HEAP_FLAG_NONE,
		&resourceDescConstantBuffer, // ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	ConstBufferData* constMap = nullptr;
	result = this->constBuff->Map(0, nullptr, (void**)&constMap); // ï¿½}ï¿½bï¿½sï¿½ï¿½ï¿½O
	if (SUCCEEDED(result)) {
		constMap->color = this->color;
		constMap->mat = this->mat.identity();
		this->constBuff->Unmap(0, nullptr);
	}


	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
		WinApp::window_width, (UINT)WinApp::window_height,
		1, 0, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);
	// ï¿½qï¿½[ï¿½vï¿½vï¿½ï¿½ï¿½pï¿½eï¿½B
	CD3DX12_HEAP_PROPERTIES heapPropsTex = CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);
	CD3DX12_CLEAR_VALUE valTex = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, clearColor);

	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateCommittedResource(
		&heapPropsTex, D3D12_HEAP_FLAG_NONE,
		&texresDesc, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		&valTex, IID_PPV_ARGS(&texBuff));
	assert(SUCCEEDED(result));

	const UINT pixelCount = WinApp::window_width * WinApp::window_height;
	const UINT rowPitch = sizeof(UINT) * WinApp::window_width;
	const UINT depthPitch = rowPitch * WinApp::window_height;
	//ï¿½æ‘œï¿½Cï¿½ï¿½ï¿½[ï¿½W
	UINT* img = new UINT[pixelCount];
	for (int i = 0; i < pixelCount; i++) {
		img[i] = 0xff0000ff;
	}
	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@ï¿½Éƒfï¿½[ï¿½^ï¿½]ï¿½ï¿½
	result = texBuff->WriteToSubresource(0, nullptr, img, rowPitch, depthPitch);
	assert(SUCCEEDED(result));
	delete[] img;
	//SRVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
	D3D12_DESCRIPTOR_HEAP_DESC srvDescHeapDesc = {};
	srvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	srvDescHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	srvDescHeapDesc.NumDescriptors = 1;
	//SRVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ð¶ï¿½
	result = device->CreateDescriptorHeap(&srvDescHeapDesc, IID_PPV_ARGS(&descHeapSRV));
	assert(SUCCEEDED(result));
	//SRVï¿½ÌÝ’ï¿½
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;
	//ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ï¿½SRVï¿½ì¬
	device->CreateShaderResourceView(texBuff.Get(), &srvDesc, descHeapSRV->GetCPUDescriptorHandleForHeapStart());
	
	//RTVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
	D3D12_DESCRIPTOR_HEAP_DESC rtvDescHeapDesc{};
	rtvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvDescHeapDesc.NumDescriptors = 1;
	//RTVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½[ï¿½qï¿½[ï¿½vï¿½ð¶ï¿½
	result = device->CreateDescriptorHeap(&rtvDescHeapDesc, IID_PPV_ARGS(&descHeapRTV));
	assert(SUCCEEDED(result));
	//ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½rï¿½ï¿½ï¿½[ï¿½ÌÝ’ï¿½
	D3D12_RENDER_TARGET_VIEW_DESC renderTargetViewDesc{};
	//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ÌŒvï¿½Zï¿½ï¿½ï¿½Ê‚ï¿½SRGBï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½Äï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	renderTargetViewDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	renderTargetViewDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
	//ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½[ï¿½qï¿½[ï¿½vï¿½ï¿½RTVï¿½ï¿½ï¿½ì¬
	device->CreateRenderTargetView(texBuff.Get(), &renderTargetViewDesc, descHeapRTV->GetCPUDescriptorHandleForHeapStart());

	//ï¿½[ï¿½xï¿½oï¿½bï¿½tï¿½@ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½Ý’ï¿½
	CD3DX12_RESOURCE_DESC depthResDesc =
		CD3DX12_RESOURCE_DESC::Tex2D(
			DXGI_FORMAT_D32_FLOAT, WinApp::window_width, WinApp::window_height,
			1, 0, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL
		);

	CD3DX12_CLEAR_VALUE valDepth = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_D32_FLOAT, 1.0f, 0);
	//ï¿½[ï¿½xï¿½oï¿½bï¿½tï¿½@ï¿½Ìï¿½ï¿½ï¿½
	CD3DX12_HEAP_PROPERTIES heapPropsDepth = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
	result = device->CreateCommittedResource(&heapPropsDepth, D3D12_HEAP_FLAG_NONE,
		&depthResDesc, D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&valDepth,
		IID_PPV_ARGS(&depthBuff));
	assert(SUCCEEDED(result));

	//DSVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ý’ï¿½
	D3D12_DESCRIPTOR_HEAP_DESC DescHeapDesc{};
	DescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	DescHeapDesc.NumDescriptors = 1;

	//DSVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ï¿½ï¿½ì¬
	result = device->CreateDescriptorHeap(&DescHeapDesc, IID_PPV_ARGS(&descHeapDSV));
	//ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ï¿½DSVï¿½ì¬
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	device->CreateDepthStencilView(depthBuff.Get(), &dsvDesc, descHeapDSV->GetCPUDescriptorHandleForHeapStart());
	
	CreateGraphicsPipelineState();

}

void PostEffect::Draw(ID3D12GraphicsCommandList* cmdList_)
{
	this->cmdList = cmdList_;
	 
	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½Æƒï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	cmdList->SetPipelineState(pipelinestate.Get());
	cmdList->SetGraphicsRootSignature(rootsignature.Get());

	// ï¿½vï¿½ï¿½ï¿½~ï¿½eï¿½Bï¿½uï¿½`ï¿½ï¿½ÌÝ’ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); // ï¿½Oï¿½pï¿½`ï¿½ï¿½ï¿½Xï¿½g

	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½pï¿½ÅƒXï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½ÌÝ’ï¿½
	ID3D12DescriptorHeap* ppHeaps[] = { descHeapSRV.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	// ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½ÌÝ’ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	// ï¿½è”ï¿½oï¿½bï¿½tï¿½@(CBV)ï¿½ÌÝ’ï¿½Rï¿½}ï¿½ï¿½ï¿½h
	cmdList->SetGraphicsRootConstantBufferView(0, constBuff->GetGPUVirtualAddress());

	//ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList->SetGraphicsRootDescriptorTable(
		1, descHeapSRV->GetGPUDescriptorHandleForHeapStart());

	//ï¿½|ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½Ì•`ï¿½ï¿½
	cmdList->DrawInstanced(4, 1, 0, 0);
}

void PostEffect::PreDrawScene(ID3D12GraphicsCommandList* cmdList_)
{
	CD3DX12_RESOURCE_BARRIER rb = CD3DX12_RESOURCE_BARRIER::Transition(texBuff.Get(),
		D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		D3D12_RESOURCE_STATE_RENDER_TARGET);
	cmdList_->ResourceBarrier(1, &rb);

	//ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½rï¿½ï¿½ï¿½[ï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	D3D12_CPU_DESCRIPTOR_HANDLE rtvH =
		descHeapRTV->GetCPUDescriptorHandleForHeapStart();
	//ï¿½[ï¿½xï¿½Xï¿½eï¿½ï¿½ï¿½Vï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[ï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½vï¿½Ìƒnï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
	D3D12_CPU_DESCRIPTOR_HANDLE dsvH =
		descHeapDSV->GetCPUDescriptorHandleForHeapStart();
	//ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½ï¿½ï¿½Zï¿½bï¿½g
	cmdList_->OMSetRenderTargets(1, &rtvH, false, &dsvH);
	//ï¿½rï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½ÌÝ’ï¿½
	CD3DX12_VIEWPORT vp = CD3DX12_VIEWPORT(0.0f, 0.0f, WinApp::window_width, WinApp::window_height);
	cmdList_->RSSetViewports(1, &vp);
	//ï¿½Sï¿½ï¿½ÊƒNï¿½ï¿½ï¿½A
	cmdList_->ClearRenderTargetView(rtvH, clearColor, 0, nullptr);
	cmdList_->ClearDepthStencilView(dsvH, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
}

void PostEffect::PostDrawScene(ID3D12GraphicsCommandList* cmdList_)
{
	//ï¿½ï¿½ï¿½\ï¿½[ï¿½Xï¿½oï¿½ï¿½ï¿½Aï¿½ï¿½ÏX(ï¿½`ï¿½ï¿½Â”\->ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½\ï¿½[ï¿½X)
	CD3DX12_RESOURCE_BARRIER rb = CD3DX12_RESOURCE_BARRIER::Transition(texBuff.Get(),
		D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
	cmdList_->ResourceBarrier(1, &rb);
}

void PostEffect::CreateGraphicsPipelineState()
{
	HRESULT result;
	//ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½
	ComPtr<ID3DBlob> vsBlob; // ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> psBlob; // ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	ComPtr<ID3DBlob> errorBlob; // ï¿½Gï¿½ï¿½ï¿½[ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g

	// ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/Shaders/PostEffectVS.hlsl", // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "vs_5_0", // ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&vsBlob, &errorBlob);

	// ï¿½Gï¿½ï¿½ï¿½[ï¿½È‚ï¿½
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½Ý‚ÆƒRï¿½ï¿½ï¿½pï¿½Cï¿½ï¿½
	result = D3DCompileFromFile(
		L"Resources/Shaders/PostEffectPS.hlsl",   // ï¿½Vï¿½Fï¿½[ï¿½_ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ï¿½Cï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½[ï¿½hï¿½Â”\ï¿½É‚ï¿½ï¿½ï¿½
		"main", "ps_5_0", // ï¿½Gï¿½ï¿½ï¿½gï¿½ï¿½ï¿½[ï¿½|ï¿½Cï¿½ï¿½ï¿½gï¿½ï¿½ï¿½Aï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½wï¿½ï¿½
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ï¿½fï¿½oï¿½bï¿½Oï¿½pï¿½Ý’ï¿½
		0,
		&psBlob, &errorBlob);

	// ï¿½Gï¿½ï¿½ï¿½[ï¿½È‚ï¿½
	if (FAILED(result)) {
		// errorBlobï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½stringï¿½^ï¿½ÉƒRï¿½sï¿½[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ï¿½Gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½oï¿½ÍƒEï¿½Bï¿½ï¿½ï¿½hï¿½Eï¿½É•\ï¿½ï¿½
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½g
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyzï¿½ï¿½ï¿½W(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

		{ // uvï¿½ï¿½ï¿½W(1ï¿½sï¿½Åï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ù‚ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â‚·ï¿½ï¿½)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÌÝ’ï¿½
	CD3DX12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

	CD3DX12_ROOT_PARAMETER rootParams[2];
	rootParams[0].InitAsConstantBufferView(0);
	rootParams[1].InitAsDescriptorTable(1, &descriptorRange, D3D12_SHADER_VISIBILITY_ALL);

	// ï¿½Xï¿½^ï¿½eï¿½Bï¿½bï¿½Nï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½[ï¿½ÌÝ’ï¿½
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //ï¿½ï¿½ï¿½Jï¿½ï¿½Ô‚ï¿½ï¿½iï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½j
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //ï¿½cï¿½Jï¿½ï¿½Ô‚ï¿½ï¿½iï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½j
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_BORDER; //ï¿½ï¿½ï¿½sï¿½Jï¿½ï¿½Ô‚ï¿½ï¿½iï¿½^ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½j
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK; //ï¿½{ï¿½[ï¿½_ï¿½[ï¿½ÌŽï¿½ï¿½Íï¿½
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; //ï¿½Sï¿½Äƒï¿½ï¿½jï¿½Aï¿½ï¿½ï¿½
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX; //ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½Å‘ï¿½l
	samplerDesc.MinLOD = 0.0f; //ï¿½~ï¿½bï¿½vï¿½}ï¿½bï¿½vï¿½Åï¿½ï¿½l
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; //ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½ï¿½Ì‚ÝŽgï¿½pï¿½Â”\

	// ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½Xï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ý’ï¿½
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	// ï¿½Vï¿½Fï¿½[ï¿½_ï¿½[ï¿½ÌÝ’ï¿½
	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	// ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½}ï¿½Xï¿½Nï¿½ÌÝ’ï¿½
	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // ï¿½Wï¿½ï¿½ï¿½Ý’ï¿½

	// ï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Cï¿½Uï¿½ÌÝ’ï¿½
	pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;  // ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½È‚ï¿½
	//pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ï¿½|ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½ï¿½ï¿½hï¿½ï¿½Â‚Ô‚ï¿½
	//pipelineDesc.RasterizerState.DepthClipEnable = true; // ï¿½[ï¿½xï¿½Nï¿½ï¿½ï¿½bï¿½sï¿½ï¿½ï¿½Oï¿½ï¿½Lï¿½ï¿½ï¿½ï¿½

	// ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½[ï¿½^ï¿½[ï¿½Qï¿½bï¿½gï¿½Ìƒuï¿½ï¿½ï¿½ï¿½ï¿½hï¿½Ý’ï¿½
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; // RBGAï¿½Sï¿½Ä‚Ìƒ`ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½

	blenddesc.BlendEnable = true;                   // ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½hï¿½ï¿½Lï¿½ï¿½ï¿½É‚ï¿½ï¿½ï¿½
	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;    // ï¿½ï¿½ï¿½Z
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;      // ï¿½\ï¿½[ï¿½Xï¿½Ì’lï¿½ï¿½100% ï¿½gï¿½ï¿½
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;    // ï¿½fï¿½Xï¿½gï¿½Ì’lï¿½ï¿½  0% ï¿½gï¿½ï¿½

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;             // ï¿½ï¿½ï¿½Z
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;         // ï¿½\ï¿½[ï¿½Xï¿½ÌƒAï¿½ï¿½ï¿½tï¿½@ï¿½l
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;    // 1.0f-ï¿½\ï¿½[ï¿½Xï¿½ÌƒAï¿½ï¿½ï¿½tï¿½@ï¿½l

	// ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½Cï¿½Aï¿½Eï¿½gï¿½ÌÝ’ï¿½
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// ï¿½}ï¿½`ï¿½ÌŒ`ï¿½ï¿½Ý’ï¿½
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// ï¿½ï¿½ï¿½Ì‘ï¿½ï¿½ÌÝ’ï¿½
	pipelineDesc.NumRenderTargets = 1; // ï¿½`ï¿½ï¿½ÎÛ‚ï¿½1ï¿½ï¿½
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï¿½`255ï¿½wï¿½ï¿½ï¿½RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½É‚Â‚ï¿½1ï¿½ï¿½Tï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½O

	//ï¿½fï¿½vï¿½Xï¿½Xï¿½eï¿½ï¿½ï¿½Vï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½ÌÝ’ï¿½
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS; // ï¿½ï¿½Éã‘ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½

	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthEnable = false;

	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌÝ’ï¿½
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams; //ï¿½ï¿½ï¿½[ï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½Ìæ“ªï¿½Aï¿½hï¿½ï¿½ï¿½X
	rootSignatureDesc.NumParameters = _countof(rootParams);        //ï¿½ï¿½ï¿½[ï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½ï¿½

	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Æƒï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ÌƒZï¿½bï¿½g

	ComPtr<ID3DBlob> rootSigBlob;
	// ï¿½oï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Å‚ÌƒVï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Cï¿½Y
	result = D3D12SerializeRootSignature(
		&rootSignatureDesc,
		D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob,
		&errorBlob);
	assert(SUCCEEDED(result));
	// ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateRootSignature(
		0,
		rootSigBlob->GetBufferPointer(),
		rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Éƒï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½g
	pipelineDesc.pRootSignature = rootsignature.Get();

	// ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½gï¿½Ìï¿½ï¿½ï¿½
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));
}


============================================================
File Path: engine/effect/PostEffect.h
============================================================
#pragma once
#include <Windows.h>
#include <D3dx12.h>
#include <d3dcompiler.h>
#include <cassert>
#include <DirectXTex.h>
#include <wrl.h>
#include <array>
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include"Matrix4.h"

#include "DirectXCommon.h"

#pragma comment(lib, "d3dcompiler.lib")

struct VertexPosUv {
	Vector3 pos;
	Vector2 uv;
};
class PostEffect
{
public:
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize(ID3D12Device* dev);
	//ï¿½`ï¿½ï¿½
	void Draw(ID3D12GraphicsCommandList* cmdList_);
	//ï¿½`ï¿½ï¿½Oï¿½ï¿½
	void PreDrawScene(ID3D12GraphicsCommandList* cmdList_);
	void PostDrawScene(ID3D12GraphicsCommandList* cmdList_);
	//ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void CreateGraphicsPipelineState();


private:
	static const float clearColor[4];

private:
	//ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> texBuff;
	//ï¿½[ï¿½xï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> depthBuff;
	//SRVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½v
	ComPtr<ID3D12DescriptorHeap> descHeapSRV;
	//RTVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½v
	ComPtr<ID3D12DescriptorHeap> descHeapRTV;
	//DSVï¿½pï¿½fï¿½Xï¿½Nï¿½ï¿½ï¿½vï¿½^ï¿½qï¿½[ï¿½v
	ComPtr<ID3D12DescriptorHeap> descHeapDSV;
	//ï¿½ï¿½ï¿½[ï¿½gï¿½Vï¿½Oï¿½lï¿½`ï¿½ï¿½
	ComPtr<ID3D12RootSignature> rootsignature;
	//ï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½
	ComPtr<ID3D12PipelineState> pipelinestate;
	//cmdList
	ComPtr<ID3D12GraphicsCommandList> cmdList;
	//Device
	ComPtr<ID3D12Device> device;
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> vertBuff;
	//ï¿½ï¿½ï¿½_ï¿½oï¿½bï¿½tï¿½@ï¿½rï¿½ï¿½ï¿½[
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	//ï¿½è”ï¿½oï¿½bï¿½tï¿½@
	ComPtr<ID3D12Resource> constBuff;
	//ï¿½è”ï¿½oï¿½bï¿½tï¿½@ï¿½pï¿½fï¿½[ï¿½^ï¿½\ï¿½ï¿½ï¿½ï¿½
	struct ConstBufferData {
		Vector4 color; // ï¿½F (RGBA)
		Matrix4 mat; //ï¿½ï¿½ï¿½W
	};
	Vector4 color = { 1,1,1,1 }; // ï¿½F (RGBA)
	Matrix4 mat; //ï¿½ï¿½ï¿½W
};



============================================================
File Path: engine/math/Matrix4.cpp
============================================================
// ========================
// Matrix4 ï¿½^ Matrix4.cpp
// ========================
#include "Matrix4.h"
#include "Vector3.h"
#include <cmath> // sin cos

const float EPSILON = 0.000001f;

Matrix4::Matrix4()
{
	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};
	// ï¿½ï¿½ï¿½
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}
}

// ï¿½ï¿½ï¿½
Matrix4::Matrix4(float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33)
{
	m[0][0] = m00, m[0][1] = m01, m[0][2] = m02, m[0][3] = m03,
		m[1][0] = m10, m[1][1] = m11, m[1][2] = m12, m[1][3] = m13,
		m[2][0] = m20, m[2][1] = m21, m[2][2] = m22, m[2][3] = m23,
		m[3][0] = m30, m[3][1] = m31, m[3][2] = m32, m[3][3] = m33;

}

// ï¿½Pï¿½Êsï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
Matrix4 Matrix4::identity()
{
	static const Matrix4 result
	{
		1.0f, 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f, 0.0f, 0.0f,
		0.0f, 0.0f, 1.0f, 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	};

	return result;
}

// ï¿½tï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
Matrix4 Matrix4::MakeInverse()
{
	Matrix4 temp;
	float mat[4][8] = { 0 };

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			mat[i][j] = m[i][j];
		}
	}

	mat[0][4] = 1;
	mat[1][5] = 1;
	mat[2][6] = 1;
	mat[3][7] = 1;

	for (int n = 0; n < 4; n++) {
		//ï¿½Å‘ï¿½Ìï¿½Î’lï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½Æ‚è‚ ï¿½ï¿½ï¿½ï¿½ï¿½ÎÛï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Å‘ï¿½Æ‰ï¿½ï¿½è‚µï¿½Ä‚ï¿½ï¿½ï¿½)
		float max = abs(mat[n][n]);
		int maxIndex = n;

		for (int i = n + 1; i < 4; i++) {
			if (abs(mat[i][n]) > max) {
				max = abs(mat[i][n]);
				maxIndex = i;
			}
		}

		float a = abs(mat[maxIndex][n]);
		//ï¿½Å‘ï¿½Ìï¿½Î’lï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½tï¿½sï¿½ï¿½Í‹ï¿½ï¿½ß‚ï¿½ï¿½È‚ï¿½
		if (abs(mat[maxIndex][n]) <= EPSILON) {
			return temp; //ï¿½Æ‚è‚ ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½Êsï¿½ï¿½Ô‚ï¿½ï¿½ï¿½ï¿½á‚¤
		}

		//ï¿½ï¿½ï¿½ï¿½Ö‚ï¿½
		if (n != maxIndex) {
			for (int i = 0; i < 8; i++) {
				float f = mat[maxIndex][i];
				mat[maxIndex][i] = mat[n][i];
				mat[n][i] = f;
			}
		}

		//ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½É‚È‚ï¿½lï¿½ï¿½ï¿½Zï¿½o
		float mul = 1 / mat[n][n];

		//ï¿½|ï¿½ï¿½ï¿½ï¿½
		for (int i = 0; i < 8; i++) {
			mat[n][i] *= mul;
		}

		//ï¿½ï¿½ï¿½Sï¿½ï¿½0ï¿½É‚ï¿½ï¿½ï¿½
		for (int i = 0; i < 4; i++) {
			if (n == i) {
				continue;
			}

			float mul = -mat[i][n];

			for (int j = 0; j < 8; j++) {
				mat[i][j] += mat[n][j] * mul;
			}
		}
	}

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++)
		{
			temp.m[i][j] = mat[i][j + 4];
		}
	}

	*this = temp;

	return *this;
}

// ï¿½gï¿½ï¿½kï¿½ï¿½ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
Matrix4 Matrix4::scale(const Vector3& s) {
	float result[4][4]
	{
		s.x ,0.0f,0.0f,0.0f,
		0.0f,s.y ,0.0f,0.0f,
		0.0f,0.0f,s.z ,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ï¿½ï¿½ï¿½
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// xï¿½ï¿½ï¿½Ü‚ï¿½ï¿½Ì‰ï¿½]ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
Matrix4 Matrix4::rotateX(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f, cos, sin,0.0f,
		0.0f,-sin, cos,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ï¿½ï¿½ï¿½
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// yï¿½ï¿½ï¿½Ü‚ï¿½ï¿½Ì‰ï¿½]ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
Matrix4 Matrix4::rotateY(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		cos ,0.0f,-sin,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		sin ,0.0f, cos,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ï¿½ï¿½ï¿½
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// zï¿½ï¿½ï¿½Ü‚ï¿½ï¿½Ì‰ï¿½]ï¿½Ìsï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
Matrix4 Matrix4::rotateZ(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		cos , sin,0.0f,0.0f,
		-sin, cos,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ï¿½ï¿½ï¿½
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// ï¿½ï¿½ï¿½sï¿½Ú“ï¿½ï¿½sï¿½ï¿½ÌÝ’ï¿½
Matrix4 Matrix4::translate(const Vector3& t)
{
	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		t.x ,t.y ,t.z ,1.0f
	};

	// ï¿½ï¿½ï¿½
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½iï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Æsï¿½ï¿½ÌŠ|ï¿½ï¿½ï¿½Zï¿½jï¿½ï¿½ï¿½sï¿½ï¿½transformï¿½Öï¿½ï¿½ï¿½ï¿½ì¬ï¿½ï¿½ï¿½ï¿½Bï¿½@ï¿½iï¿½ï¿½ï¿½ï¿½ï¿½ÏŠï¿½ï¿½É‚ï¿½ï¿½Î‰ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½j
Vector3 Matrix4::transform(const Vector3& v, const Matrix4& m)
{
	float w = v.x * m.m[0][3] + v.y * m.m[1][3] + v.z * m.m[2][3] + m.m[3][3];

	Vector3 result
	{
		(v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0] + m.m[3][0]) / w,
		(v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1] + m.m[3][1]) / w,
		(v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2] + m.m[3][2]) / w
	};

	return result;
}

// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½Ìì¬
Matrix4 Matrix4::ViewMat(Vector3 eye, Vector3 target, Vector3 up)
{
	Vector3 zaxis = target - eye;
	zaxis.normalize();
	Vector3 xaxis = up.cross(zaxis);
	xaxis.normalize();
	Vector3 yaxis = zaxis.cross(xaxis);
	yaxis.normalize();

	Matrix4 LookAt = {
		xaxis.x,	xaxis.y,	xaxis.z,	0,
		yaxis.x,	yaxis.y,	yaxis.z,	0,
		zaxis.x,	zaxis.y,	zaxis.z,	0,
		eye.x,		eye.y,		eye.z,		1
	};

	LookAt.MakeInverse();

	*this = LookAt;

	return *this;
}

// ï¿½Ë‰eï¿½sï¿½ï¿½Ìì¬
Matrix4 Matrix4::ProjectionMat(float fovAngleY, float aspectRatio, float nearZ, float farZ)
{
	float h = 1 / tanf(fovAngleY / 2);
	float w = h / aspectRatio;
	float a = farZ / (farZ - nearZ);
	float b = (-nearZ * farZ) / (farZ - nearZ);

	Matrix4 perspectiveFovLH = {
		w,		 0,		 0,		 0,
		0,		 h,		 0,		 0,
		0,		 0,		 a,		 1,
		0,		 0,		 b,		 0
	};

	*this = perspectiveFovLH;

	return *this;
}

Matrix4 Matrix4::ViewPortMat(float width, float height, Vector2 offset)
{
	float w = width / 2;
	float h = height / 2;
	float a = width / 2 + offset.x;
	float b = height / 2 + offset.y;

	Matrix4 projectiveTlansformationLH = {
		w,		 0,		 0,		 0,
		0,		 -h,		 0,		 0,
		0,		 0,		 1,		 0,
		a,		 b,		 0,		 1
	};

	*this = projectiveTlansformationLH;

	return *this;
}

// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½@*=ï¿½@ï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½hï¿½Öï¿½ï¿½iï¿½sï¿½ï¿½Æsï¿½ï¿½ÌÏj
Matrix4& Matrix4::operator*=(const Matrix4& m1)
{
	Matrix4 result;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			float Total = 0.0f;
			for (int k = 0; k < 4; k++) {
				Total += m[i][k] * m1.m[k][j];
			}
			result.m[i][j] = Total;
		}
	}

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result.m[i][j];
		}
	}

	return *this;
}

// ï¿½Qï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½@*ï¿½@ï¿½ÌƒIï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½hï¿½Öï¿½ï¿½iï¿½sï¿½ï¿½Æsï¿½ï¿½ÌÏj
Matrix4 Matrix4::operator*(const Matrix4& m1)
{
	return *this *= m1;
}

// ï¿½Qï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½@*ï¿½@ï¿½ÌƒIï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½hï¿½Öï¿½ï¿½iï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Æsï¿½ï¿½ÌÏj
Vector3 operator*(const Vector3& v, const Matrix4& m)
{
	float W = v.x * m.m[0][3] + v.y * m.m[1][3] + v.z * m.m[2][3] + m.m[3][3];
	Vector3 result
	{
		(v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0] + m.m[3][0]) / W,
		(v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1] + m.m[3][1]) / W,
		(v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2] + m.m[3][2]) / W
	};
	return result;
}

float Matrix4::ConvertToRadian(float rad) {
	return rad * ((float)3.141592 / 180);
}

============================================================
File Path: engine/math/Matrix4.h
============================================================
// ===============================
// Matrix4 ï¿½^ Matrix4.h
// ===============================
#pragma once

#include "Vector3.h"
#include "Vector2.h"

class Matrix4
{
public:

	// Matrix4 ï¿½\ï¿½ï¿½ï¿½ï¿½
	float m[4][4];


	// ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	Matrix4();
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½Ä‚Ìï¿½ï¿½ï¿½
	Matrix4(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33);

	// ï¿½Pï¿½Êsï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	static Matrix4 identity();

	// ï¿½tï¿½sï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	Matrix4 MakeInverse();

	// ï¿½gï¿½ï¿½kï¿½ï¿½ï¿½sï¿½ï¿½ÌÝ’ï¿½
	Matrix4 scale(const Vector3& s);

	// ï¿½ï¿½]ï¿½sï¿½ï¿½ÌÝ’ï¿½
	Matrix4 rotateX(float angle);
	Matrix4 rotateY(float angle);
	Matrix4 rotateZ(float angle);

	// ï¿½ï¿½ï¿½sï¿½Ú“ï¿½ï¿½sï¿½ï¿½Ìì¬
	Matrix4 translate(const Vector3& t);

	// ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½iï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Æsï¿½ï¿½ÌŠ|ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ï¿½j
	Vector3 transform(const Vector3& v, const Matrix4& m);

	// ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½ì¬
	Matrix4 ViewMat(Vector3 eye, Vector3 target, Vector3 up);

	// ï¿½Ë‰eï¿½sï¿½ï¿½ì¬
	Matrix4 ProjectionMat(float fovAngleY, float aspectRatio, float nearZ, float farZ);
	Matrix4 ViewPortMat(float width, float height, Vector2 offset);

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Matrix4& operator*=(const Matrix4& m1);

	Matrix4 operator*(const Matrix4& m1);

	static float ConvertToRadian(float rad);

};

	// 2ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Vector3 operator*(const Vector3& v, const Matrix4& m);



============================================================
File Path: engine/math/Spline.cpp
============================================================
#include "Spline.h"
#include <windows.h>
#include <sysinfoapi.h>

void Spline::Initialize() {
	isEnd = false;
	t = 0.0f;
}

Vector3 Spline::Update(std::vector<Vector3>& points, float val) {

	t = t + val;

	//timeRateï¿½ï¿½1.0fï¿½Èï¿½É‚È‚ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Ì‹ï¿½Ô‚Éiï¿½ï¿½
	if (t >= 1.0f) {
		if (startIndex < points.size() - 3) {

			startIndex++;

			t -= 1.0f;
			integer += 1.0f;
		}
		else {
			isEnd = true;
			t = 1.0f;
		}
	}

	Vector3 pos = SplinePosition(points, startIndex, t);

	t += (float)0.002;
	//float integer = (float)floor(val);
	//float few = (float)fmod(val, 1);

	//Vector3 pos = SplinePosition(points, (size_t)integer, few);

	//if (integer >= (float)points.size() - 3.0f) {
	//	isEnd = true;
	//}
	
	return pos;
}

Vector3 Spline::EnemyPosition(std::vector<Vector3>& points, float val)
{
	float integer = (float)floor(val);
	float few = (float)fmod(val, 1);

	Vector3 pos = SplinePosition(points, (size_t)integer, few);

	return pos;
}

Vector3 Spline::pointCal(std::vector<Vector3>& points) {

	const int INDEXMAX = (int)points.size() - 1;

	float nowPoint = (float)startIndex / (float)INDEXMAX;

	Vector3 pos = SplinePosition(points, startIndex, t);

	if (t >= 1) {
		startIndex++;
		t = 0;
	}
	else {
		t += 0.01f;
	}

	return pos;
}

void Spline::Reset()
{			 
	t = 0;
	integer = 0;
	startIndex = 1;
}

Vector3 Spline::SplinePosition(const std::vector<Vector3>& points, size_t startIndex, float t) {
	//ï¿½ï¿½Ô‚ï¿½ï¿½×‚ï¿½ï¿½_
	size_t n = points.size() - 2;

	if (startIndex > n) return points[n];
	if (startIndex < 1) return points[1];

	//p0~p3ï¿½Ìï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½æ“¾ï¿½ï¿½ï¿½ï¿½
	Vector3 p0_ = points[startIndex - 1];
	Vector3 p1_ = points[startIndex];
	Vector3 p2_ = points[startIndex + 1];
	Vector3 p3_ = points[startIndex + 2];

	//Catmull-Rom ï¿½ÌŽï¿½ï¿½É‚ï¿½ï¿½ï¿½ï¿½
	Vector3 position = 0.5 * (p1_ * 2 + (-p0_ + p2_) *
							  t + (p0_ * 2 - p1_ * 5 + p2_ * 4 - p3_) *
							  (t * t) + (-p0_ + p1_ * 3 - p2_ * 3 + p3_) *
							  (t * t * t));

	return position;
}

============================================================
File Path: engine/math/Spline.h
============================================================
#pragma once

#include "Vector3.h"
#include <Vector>

class Spline 
{
public:
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize();

	//ï¿½Xï¿½V
	Vector3 Update(std::vector<Vector3>& points,float val);

	Vector3 EnemyPosition(std::vector<Vector3>& points, float val);

	//ï¿½Xï¿½V
	Vector3 pointCal(std::vector<Vector3>& points);

	void Reset();

	//ï¿½ï¿½ï¿½ï¿½_ï¿½ÌWï¿½ï¿½(vectorï¿½Rï¿½ï¿½ï¿½eï¿½i)ï¿½Aï¿½ï¿½Ô‚ï¿½ï¿½ï¿½ï¿½Ô‚Ì“Yï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ÔŒoï¿½ß—ï¿½
	Vector3 SplinePosition(const std::vector<Vector3>& point, size_t startIndex, float t);

	bool GetIsEnd() { return isEnd; }
	float GetT() { return t + integer; }

private:
	//P1ï¿½ï¿½ï¿½ï¿½Xï¿½^ï¿½[ï¿½gï¿½ï¿½ï¿½ï¿½
	size_t startIndex = 1;
	bool isEnd = false;
	float t = 0;
	float integer = 0;


	//ï¿½ï¿½ï¿½ÌˆÊ’u
	Vector3 position;
};

============================================================
File Path: engine/math/Vector2.cpp
============================================================
#include "Vector2.h"
#include <cmath>      // sqrt

Vector2::Vector2()
	:x(0) , y(0)
{
}

Vector2::Vector2(float x,float y)
	:x(x) , y(y)
{
}

float Vector2::length() const
{
	return sqrt(x * x + y * y);
}

Vector2& Vector2::normalize()
{
	float len = length();
	if (len != 0)
	{
		return *this /= len;
	}
	return *this;
}

float Vector2::dot(const Vector2& v) const
{
	return x * v.x + y * v.y;
}

float Vector2::cross(const Vector2& v) const
{
	return x * v.y - y * v.x;
}

Vector2 Vector2::operator+() const
{
	return *this;
}

Vector2 Vector2::operator-() const
{
	return Vector2(-x, -y);
}

Vector2& Vector2::operator+=(const Vector2& v)
{
	x += v.x;
	y += v.y;
	return *this;
}

Vector2& Vector2::operator-=(const Vector2& v)
{
	x -= v.x;
	y -= v.y;
	return *this;
}

Vector2& Vector2::operator*=(float s)
{
	x *= s;
	y *= s;
	return *this;
}

Vector2& Vector2::operator/=(float s)
{
	x /= s;
	y /= s;
	return *this;
}

// Vector2 ï¿½Nï¿½ï¿½ï¿½Xï¿½É‘ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½Öï¿½ï¿½Q
// ï¿½ñ€‰ï¿½ï¿½Zï¿½q
const Vector2 operator+(const Vector2& v1, const Vector2& v2)
{
	Vector2 temp(v1);
	return temp += v2;
}

const Vector2 operator-(const Vector2& v1, const Vector2& v2)
{
	Vector2 temp(v1);
	return temp -= v2;
}

const Vector2 operator*(const Vector2& v, float s)
{
	Vector2 temp(v);
	return temp *= s;
}

const Vector2 operator*(float s, const Vector2& v)
{
	return v * s;
}

const Vector2 operator/(const Vector2& v, float s)
{
	Vector2 temp(v);
	return temp /= s;
}

============================================================
File Path: engine/math/Vector2.h
============================================================
#pragma once
class Vector2
{
public:
	float x; // xï¿½ï¿½ï¿½ï¿½
	float y; // yï¿½ï¿½ï¿½ï¿½

public:
	// ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	Vector2();                  // ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Æ‚ï¿½ï¿½Äï¿½ï¿½ï¿½
	Vector2(float x, float y);  // xï¿½ï¿½ï¿½ï¿½ , yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½Ä‚Ìï¿½ï¿½ï¿½

	// ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	float length() const;
	Vector2& normalize();
	float dot(const Vector2& v) const;
	float cross(const Vector2& v)const;

	// ï¿½Pï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Vector2 operator+() const;
	Vector2 operator-() const;

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Vector2& operator+=(const Vector2& v);
	Vector2& operator-=(const Vector2& v);
	Vector2& operator*=(float s);
	Vector2& operator/=(float s);

};

// 2ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Èˆï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½ÌŒ^ï¿½Æï¿½ï¿½ï¿½)ï¿½Ìƒpï¿½^ï¿½[ï¿½ï¿½ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½é‚½ï¿½ßAï¿½È‰ï¿½ï¿½Ì‚æ‚¤ï¿½Éï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½
const Vector2 operator+(const Vector2& v1, const Vector2& v2);
const Vector2 operator-(const Vector2& v1, const Vector2& v2);
const Vector2 operator*(const Vector2& v, float s);
const Vector2 operator*(float s, const Vector2& v);
const Vector2 operator/(const Vector2& v, float s);



============================================================
File Path: engine/math/Vector3.cpp
============================================================
// ===================
// Vector3 ï¿½^
// ===================
#include "Vector3.h"

Vector3::Vector3()
	:x(0), y(0), z(0)
{
}
Vector3::Vector3(float x, float y, float z)
	: x(x), y(y), z(z)
{
}
float Vector3::length() const
{
	return std::sqrt(x * x + y * y + z * z);
}
Vector3& Vector3::normalize()
{
	float len = length();
	if (len != 0)
	{
		return*this /= len;
	}
	return*this;
}
float Vector3::dot(const Vector3& v, const Vector3& v2)
{
	return v.x * v2.x + v.y * v2.y + v.z * v2.z;
}
Vector3 Vector3::cross(const Vector3& v)const
{
	Vector3 temp;
	temp.x = this->y * v.z - this->z * v.y;
	temp.y = this->z * v.x - this->x * v.z;
	temp.z = this->x * v.y - this->y * v.x;
	return temp;
}

const Vector3 Vector3::lerp(const Vector3& start, const Vector3& end, const float t)
{
	return start * (1.0f - t) + end * t;
}

Vector3 Vector3::operator+()const
{
	return *this;
}
Vector3 Vector3::operator-()const
{
	return Vector3(-x, -y, -z);
}
Vector3& Vector3::operator+=(const Vector3& v)
{
	x += v.x;
	y += v.y;
	z += v.z;
	return *this;
}
Vector3& Vector3::operator-=(const Vector3& v)
{
	x -= v.x;
	y -= v.y;
	z -= v.z;
	return *this;
}
Vector3& Vector3::operator*=(const Vector3& v)
{
	x *= v.x;
	y *= v.y;
	z *= v.z;
	return *this;
}
Vector3& Vector3::operator*=(float s)
{
	x *= s;
	y *= s;
	z *= s;
	return *this;
}
Vector3& Vector3::operator/=(float s)
{
	x /= s;
	y /= s;
	z /= s;
	return *this;
}
// Vector3 ï¿½Nï¿½ï¿½ï¿½Xï¿½É‘ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½Öï¿½ï¿½Q
// ï¿½ñ€‰ï¿½ï¿½Zï¿½q
const Vector3 operator+ (const Vector3& v1, const Vector3& v2)
{
	Vector3 temp(v1);
	return temp += v2;
}
const Vector3 operator-(const Vector3& v1, const Vector3& v2)
{
	Vector3 temp(v1);
	return temp -= v2;
}
const Vector3 operator*(const Vector3& v, float s)
{
	Vector3 temp(v);
	return temp *= s;
}
const Vector3 operator*(float s, const Vector3& v)
{
	return v * s;
}
const Vector3 operator/(const Vector3& v, float s)
{
	Vector3 temp(v);
	return temp /= s;
}



============================================================
File Path: engine/math/Vector3.h
============================================================
#pragma once
#include <cmath>

class Vector3 {
public:
	float x;//xï¿½ï¿½ï¿½ï¿½
	float y;//yï¿½ï¿½ï¿½ï¿½
	float z;//zï¿½ï¿½ï¿½ï¿½

public:
	//ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½g
	Vector3();                            //ï¿½[ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Æ‚ï¿½ï¿½Äï¿½ï¿½ï¿½
	Vector3(float x, float y, float z);   //xï¿½ï¿½ï¿½ï¿½,yï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½Ä‚Ìï¿½ï¿½ï¿½

	//ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	float length() const;                 //ï¿½mï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	Vector3& normalize();                 //ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	static float dot(const Vector3& v, const Vector3& v2);   //ï¿½ï¿½ï¿½Ï‚ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	Vector3 cross(const Vector3& v)const; //ï¿½Oï¿½Ï‚ï¿½ï¿½ï¿½ï¿½ß‚ï¿½

	// ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½(1ï¿½ï¿½ï¿½Öï¿½ï¿½ï¿½ï¿½)
	static const Vector3 lerp(const Vector3& start, const Vector3& end, const float t);

	//ï¿½bï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Vector3 operator+() const;
	Vector3 operator-() const;

	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Vector3& operator+=(const Vector3& v);
	Vector3& operator-=(const Vector3& v);
	Vector3& operator*=(const Vector3& v);
	Vector3& operator*=(float s);
	Vector3& operator/=(float s);
};
//2ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Èˆï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½ÌŒ^ï¿½Æï¿½ï¿½ï¿½)ï¿½Ìƒpï¿½^ï¿½[ï¿½ï¿½ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½é‚½ï¿½ßAï¿½È‰ï¿½ï¿½Ì‚æ‚¤ï¿½Éï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½
const Vector3  operator+(const Vector3& v1, const Vector3& v2);
const Vector3  operator-(const Vector3& v1, const Vector3& v2);
const Vector3  operator*(const Vector3& v, float s);
const Vector3  operator*(float s, const Vector3& v);
const Vector3  operator/(const Vector3& v, float s);




============================================================
File Path: engine/math/Vector4.cpp
============================================================
#include "Vector4.h"

#include<cmath>  //sprt

Vector4::Vector4() :x(0), y(0), z(0), w(0)
{
}

Vector4::Vector4(float x, float y, float z, float w) {
	this->x = x;
	this->y = y;
	this->z = z;
	this->w = w;
}

float Vector4::length()const {
	return std::sqrt(x * x + y * y + z * z + w * w);
}

Vector4& Vector4::normalize() {
	float len = length();
	if (len != 0) {
		return *this /= len;
	}
	return *this;
}

float Vector4::dot(const Vector4& v) const
{
	return x * v.x + y * v.y + z * v.z + w * v.w;
}

Vector4 Vector4::cross(const Vector4& v) const
{
	return Vector4(
		y * v.z - z * v.y,
		z * v.x - x * v.z,
		x * v.y - y * v.x,
		v.w
	);
}

Vector4 Vector4::operator+() const
{
	return Vector4(x, y, z, w);
}

Vector4 Vector4::operator-() const
{
	return Vector4(x, y, z, w);
}

Vector4& Vector4::operator+=(const Vector4& v)
{
	this->x += v.x;
	this->y += v.y;
	this->z += v.z;
	this->w += v.w;
	return *this;
}

Vector4& Vector4::operator-=(const Vector4& v)
{
	this->x -= v.x;
	this->y -= v.y;
	this->z -= v.z;
	this->w -= v.w;
	return *this;
}

Vector4& Vector4::operator*=(float s)
{
	this->x *= s;
	this->y *= s;
	this->z *= s;
	this->w *= s;
	return *this;
}

Vector4& Vector4::operator/=(float s)
{
	x /= s;
	y /= s;
	z /= s;
	w /= s;
	return *this;
}

//Vector4 ï¿½Nï¿½ï¿½ï¿½Xï¿½É‘ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½Öï¿½ï¿½Q


const Vector4 operator+(const Vector4& v1, const Vector4& v2)
{
	Vector4 temp(0,0,0,0);
	temp.x = v1.x + v2.x;
	temp.y = v1.y + v2.y;
	temp.z = v1.z + v2.z;
	temp.w = v1.w + v2.w;
	return temp;
}

const Vector4 operator-(const Vector4& v1, const Vector4& v2)
{
	Vector4 temp(0, 0, 0, 0);
	temp.x = v1.x - v2.x;
	temp.y = v1.y - v2.y;
	temp.z = v1.z - v2.z;
	temp.w = v1.w - v2.w;
	return temp;
}

const Vector4 operator*(const Vector4& v, float s)
{
	Vector4 temp(0,0,0,0);
	temp.x = v.x * s;
	temp.y = v.y * s;
	temp.z = v.z * s;
	temp.w = v.w * s;
	return temp;
}

const Vector4 operator/(const Vector4& v, float s)
{
	Vector4 temp(0, 0, 0, 0);
	temp.x = v.x / s;
	temp.y = v.y / s;
	temp.z = v.z / s;
	temp.w = v.w / s;
	return temp;
}

============================================================
File Path: engine/math/Vector4.h
============================================================
#pragma once

class Vector4
{
public:
	float x;
	float y;
	float z;
	float w;
public:
	//ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	Vector4();								//ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Æ‚ï¿½ï¿½ï¿½
	Vector4(float x, float y, float z, float w);		//xï¿½ï¿½ï¿½ï¿½,yï¿½ï¿½ï¿½ï¿½,zï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½wï¿½è‚µï¿½Äï¿½ï¿½ï¿½

	//ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	float length() const;					//ï¿½mï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	Vector4& normalize();					//ï¿½ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	float dot(const Vector4& v) const;		//ï¿½ï¿½ï¿½Ï‚ï¿½ï¿½ï¿½ï¿½ß‚ï¿½
	Vector4 cross(const Vector4& v) const;	//ï¿½Oï¿½Ï‚ï¿½ï¿½ï¿½ï¿½ß‚ï¿½


	//ï¿½Pï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Vector4 operator+() const;
	Vector4 operator-() const;

	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
	Vector4& operator+=(const Vector4& v);
	Vector4& operator-=(const Vector4& v);
	Vector4& operator*=(float s);
	Vector4& operator/=(float s);

};


//ï¿½@2ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Iï¿½[ï¿½oï¿½[ï¿½ï¿½ï¿½[ï¿½h
//ï¿½@ï¿½ï¿½ï¿½ë‚¢ï¿½ï¿½Èˆï¿½ï¿½ï¿½ï¿½Ìƒpï¿½^ï¿½[ï¿½ï¿½ï¿½É‘Î‰ï¿½(ï¿½ï¿½ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½é‚½ï¿½ßAï¿½È‰ï¿½ï¿½Ì‚æ‚¤ï¿½Éï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½
const Vector4 operator+(const Vector4& v1, const Vector4& v2);
const Vector4 operator-(const Vector4& v1, const Vector4& v2);
const Vector4 operator*(const Vector4& v, float s);
const Vector4 operator*(float s, const Vector4& v);
const Vector4 operator/(const Vector4& v, float s);

============================================================
File Path: engine/scene/AbstractSceneFactory.h
============================================================
#pragma once

#include "GameBaseScene.h"
#include <string>

class AbstractSceneFactory
{
public:
	virtual ~AbstractSceneFactory() = default;

	virtual GameBaseScene* CreateScene(const std::string& sceneName) = 0;
};

============================================================
File Path: engine/scene/Game.cpp
============================================================
#include "Game.h"

#include "SceneFactory.h"

void Game::Initialize()
{	
	// ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½Xï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	SIFrameWork::Initialize();

	// ï¿½Vï¿½[ï¿½ï¿½ï¿½tï¿½@ï¿½Nï¿½gï¿½ï¿½ï¿½ð¶ï¿½ï¿½ï¿½ï¿½Aï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½ÉƒZï¿½bï¿½g
	sceneFactory_ = new SceneFactory();
	sceneManager_->SetSceneFactory(sceneFactory_);
	// ï¿½Vï¿½[ï¿½ï¿½ï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½ÉÅï¿½ï¿½ÌƒVï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½g
	sceneManager_->ChangeScene("TITLE");
}

void Game::Finalize()
{
	// ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½Xï¿½ÌIï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	SIFrameWork::Finalize();
}

void Game::Update()
{
	// ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½Xï¿½ÌXï¿½Vï¿½ï¿½ï¿½ï¿½
	SIFrameWork::Update();
}

void Game::Draw()
{
	// ï¿½Rï¿½}ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Xï¿½gï¿½ÌŽæ“¾
	ID3D12GraphicsCommandList* cmdList = dxCommon->GetCommandList();

	//=== ï¿½Vï¿½[ï¿½ï¿½ï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½Ì•`ï¿½ï¿½ ===//
	sceneManager_->Draw();
}


============================================================
File Path: engine/scene/Game.h
============================================================
#pragma once

#include "SIFrameWork.h"

// ï¿½Qï¿½[ï¿½ï¿½ï¿½Sï¿½ï¿½
class Game : public SIFrameWork
{
public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void Initialize() override;

	// ï¿½Iï¿½ï¿½
	void Finalize() override;

	// ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Xï¿½V
	void Update() override;

	// ï¿½`ï¿½ï¿½
	void Draw() override;
};


============================================================
File Path: engine/scene/GameBaseScene.cpp
============================================================
#include "GameBaseScene.h"


void GameBaseScene::LoadObjFromLevelEditor(const std::string& fileName) {
	JsonLoader* file = nullptr;
	LevelData* levelData = file->LoadFile(fileName);

	//ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½zï¿½u
	for (auto& objectData : levelData->objects) {
		//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½^ï¿½Ï‚Ýƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		Model* model = nullptr;
		decltype(models)::iterator it = models.find(objectData.fileName);
		if (it != models.end()) { model = it->second; }
		//ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½ï¿½3DObjectï¿½ð¶ï¿½
		Object3d* newObject = Object3d::Create();
		newObject->Initialize();
		newObject->SetModel(model);
		//ï¿½ï¿½ï¿½W
		Vector3 pos;
		pos = Vector3(objectData.translation.x, objectData.translation.y, objectData.translation.z);
		newObject->SetPosition(pos);
		//ï¿½ï¿½]ï¿½p
		Vector3 rot;
		rot = Vector3(objectData.rotation.x, objectData.rotation.y, objectData.rotation.z);
		newObject->SetRotation(rot);
		//ï¿½Xï¿½Pï¿½[ï¿½ï¿½
		Vector3 scale;
		scale = Vector3(objectData.scaling.x, objectData.scaling.y, objectData.scaling.z);
		newObject->SetScale(scale);
		//ï¿½zï¿½ï¿½É“oï¿½^
		objects.push_back(newObject);
	}
}


============================================================
File Path: engine/scene/GameBaseScene.h
============================================================
#pragma once

#include "Sprite.h"
#include "JsonLoader.h"	
#include "Model.h"
#include "Object3d.h"

#include <cassert>
#include <fstream>
#include <sstream>
#include <map>
#include <list>

// ï¿½Oï¿½ï¿½ï¿½éŒ¾
class GameSceneManager;

// ï¿½Vï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½X
class GameBaseScene
{
public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	GameBaseScene() = default;
	virtual ~GameBaseScene() = default;

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	/// <summary>
	/// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	/// </summary>
	virtual void Initialize() = 0;

	/// <summary>
	/// ï¿½Xï¿½V
	/// </summary>
	virtual void Update() = 0;

	/// <summary>
	/// ï¿½`ï¿½ï¿½
	/// </summary>
	virtual void Draw() = 0;

	/// <summary>
	/// ï¿½ï¿½ï¿½
	/// </summary>
	virtual void Finalize() = 0;

	void LoadObjFromLevelEditor(const std::string& fileName);

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	virtual void SetSceneManager(GameSceneManager* gSceneManager) { gSceneManager_ = gSceneManager; }

protected: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	// ï¿½Vï¿½[ï¿½ï¿½ï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½iï¿½Ø‚ï¿½Ä‚ï¿½ï¿½ï¿½j
	GameSceneManager* gSceneManager_ = nullptr;
	//leveleditor
	std::map<std::string, Model*> models;
	std::vector<Object3d*> objects;
};



============================================================
File Path: engine/scene/GameClearScene.cpp
============================================================
#include "GameClearScene.h"

using namespace DirectX;

GameClearScene::GameClearScene()
{
}

GameClearScene::~GameClearScene()
{
}

void GameClearScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon = DirectXCommon::GetInstance();


	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	viewProjection = new ViewProjection();
	viewProjection->Initialize();

	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon->GetDevice());

	//gameclearï¿½Ì‰æ‘œ
	clearGH.LoadTexture(spriteCommon_, 0, L"Resources/clear.png", dxCommon->GetDevice());
	clearGH.SpriteCreate(dxCommon->GetDevice(), 1280, 720, 0, Vector2(0.0f, 0.0f), false, false);
	clearGH.SetScale(Vector2(1280 * 1, 720 * 1));
	clearGH.SpriteTransferVertexBuffer(clearGH, 0);
	clearGH.SpriteUpdate(clearGH, spriteCommon_);
	
	showTime = 0;
	isNext = false;
	curHit01 = false;
	curHit02 = false;
}

void GameClearScene::Update()
{
	viewProjection->UpdateMatrix();
	clearGH.SpriteUpdate(clearGH, spriteCommon_);
	if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
		GameSceneManager::GetInstance()->ChangeScene("TITLE");
	}
}

void GameClearScene::Draw()
{
	// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	dxCommon->PreDraw();

	Object3d::PreDraw(dxCommon->GetCommandList());


	Object3d::PostDraw();

	Sprite::PreDraw(dxCommon->GetCommandList(),spriteCommon_);

	clearGH.SpriteDraw(dxCommon->GetCommandList(), spriteCommon_, dxCommon->GetDevice());

	Sprite::PostDraw();

	
	// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	dxCommon->PostDraw();
}

void GameClearScene::Finalize()
{
}


============================================================
File Path: engine/scene/GameClearScene.h
============================================================
#pragma once

#include "Input.h"
#include "DirectXCommon.h"
#include "GameBaseScene.h"
#include "Sprite.h"
#include "GameSceneManager.h"
#include "GameTitleScene.h"
#include "Object3d.h"

#include <DirectXMath.h>

class GameClearScene : public GameBaseScene
{
public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	GameClearScene();
	// ï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	~GameClearScene();

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	/// <summary>
	/// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// ï¿½Xï¿½V
	/// </summary>
	void Update() override;

	/// <summary>
	/// ï¿½`ï¿½ï¿½
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// ï¿½ï¿½ï¿½
	/// </summary>
	void Finalize() override;

private: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	Input* input_ = nullptr;
	DirectXCommon* dxCommon = nullptr;
	Sprite* cross = nullptr;
	//ï¿½Jï¿½ï¿½ï¿½ï¿½
	ViewProjection* viewProjection = nullptr;
	//score
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite clearGH;
	int scores[6];
	float numPosX;
	int showTime;
	//title
	Sprite* title01 = nullptr;
	Sprite* title02 = nullptr;
	//retry
	Sprite* retry01 = nullptr;
	Sprite* retry02 = nullptr;
	bool isNext;
	bool curHit01;
	bool curHit02;
};


============================================================
File Path: engine/scene/GameOverScene.cpp
============================================================
#include "GameOverScene.h"

GameOverScene::GameOverScene()
{
}

GameOverScene::~GameOverScene()
{
}

void GameOverScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon = DirectXCommon::GetInstance();


	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	viewProjection = new ViewProjection();
	viewProjection->Initialize();

	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon->GetDevice());
}

void GameOverScene::Update()
{
	viewProjection->UpdateMatrix();
	if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
		GameSceneManager::GetInstance()->ChangeScene("TITLE");
	}
}

void GameOverScene::Draw()
{
	// ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	dxCommon->PreDraw();

	Object3d::PreDraw(dxCommon->GetCommandList());


	Object3d::PostDraw();


	// ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	dxCommon->PostDraw();
}

void GameOverScene::Finalize()
{
}


============================================================
File Path: engine/scene/GameOverScene.h
============================================================
#pragma once

#include "Input.h"
#include "DirectXCommon.h"
#include "GameBaseScene.h"
#include "Sprite.h"
#include "GameSceneManager.h"
#include "GameTitleScene.h"
#include "Object3d.h"

#include <DirectXMath.h>

class GameOverScene : public GameBaseScene
{
public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	GameOverScene();
	// ï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	~GameOverScene();

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	/// <summary>
	/// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// ï¿½Xï¿½V
	/// </summary>
	void Update() override;

	/// <summary>
	/// ï¿½`ï¿½ï¿½
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// ï¿½ï¿½ï¿½
	/// </summary>
	void Finalize() override;

private: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	Input* input_ = nullptr;
	DirectXCommon* dxCommon = nullptr;
	Sprite* cross = nullptr;
	//ï¿½Jï¿½ï¿½ï¿½ï¿½
	ViewProjection* viewProjection = nullptr;
	//score
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite clearGH;
	int scores[6];
	float numPosX;
	int showTime;
	//title
	Sprite* title01 = nullptr;
	Sprite* title02 = nullptr;
	//retry
	Sprite* retry01 = nullptr;
	Sprite* retry02 = nullptr;
	bool isNext;
	bool curHit01;
	bool curHit02;
};



============================================================
File Path: engine/scene/GameScene.cpp
============================================================
#include "GameScene.h"
#include "FbxLoader.h"
#include "FbxObject3d.h"
#include "SphereCollider.h"
#include "CollisionManager.h"
#include "GameSceneManager.h"

#include <cassert>
#include <fstream>
#include <sstream>
#include <map>

std::list<std::unique_ptr<Energy>> GameScene::energys_;
int GameScene::popEnergyCount = 0;
GameScene::GameScene() {}

GameScene::~GameScene() {
	delete player;
}

///-----ï¿½Ïï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½-----///
void GameScene::Initialize() {
	//ï¿½ï¿½ï¿½
	dxCommon_ = DirectXCommon::GetInstance();
	winApp = WinApp::GetInstance();
	input = Input::GetInstance();
	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	collisionManager = CollisionManager::GetInstance();

	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 0.7f));

	//ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½Ç‚Ýï¿½ï¿½ï¿½
	skyModel = Model::LoadFromOBJ("sky");
	seaModel = Model::LoadFromOBJ("sea");
	block01Model = Model::LoadFromOBJ("block01");
	block02Model = Model::LoadFromOBJ("block02");
	stoneModel = Model::LoadFromOBJ("stone");
	models.insert(std::make_pair("sky", skyModel));
	models.insert(std::make_pair("sea", seaModel));
	models.insert(std::make_pair("block01", block01Model));
	models.insert(std::make_pair("block02", block02Model));
	models.insert(std::make_pair("stone", stoneModel));
	//ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½Gï¿½fï¿½Bï¿½^ï¿½Ç‚Ýï¿½ï¿½ï¿½
	LoadObjFromLevelEditor("scene");

	railCamera = new RailCamera;
	railCamera->Initialize(player);

	xmViewProjection = new XMViewProjection;

	////FbxObjectï¿½ÌÃ“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	////ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½g
	//FbxObject3d::SetCamera(viewProjection);
	////ï¿½Oï¿½ï¿½ï¿½tï¿½Bï¿½bï¿½Nï¿½Xï¿½pï¿½Cï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	//FbxObject3d::CreateGraphicsPipeline();

	// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½g
	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon_->GetDevice());

	//titleï¿½Ì‰æ‘œ
	titleGH.LoadTexture(spriteCommon_, 0, L"Resources/title.png", dxCommon_->GetDevice());
	titleGH.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 0, Vector2(0.0f, 0.0f), false, false);
	titleGH.SetScale(Vector2(1280 * 1, 720 * 1));
	titleGH.SpriteTransferVertexBuffer(titleGH, 0);
	titleGH.SpriteUpdate(titleGH, spriteCommon_);

	//ï¿½Nï¿½ï¿½ï¿½Xï¿½wï¿½Aï¿½Ì‰æ‘œ
	for (int i = 0; i < 4; i++) {
		crosshair[i].LoadTexture(spriteCommon_, 1, L"Resources/crosshair.png", dxCommon_->GetDevice());
		crosshair[i].SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 1, Vector2(0.5f, 0.5f), false, false);
		crosshair[i].SetPosition(Vector3(1100, 0, 0));
		crosshair[i].SetScale(Vector2(24.0f * (i + 1.0f), 24.0f * (i + 1.0f)));
		crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
		crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
	}

	//HPï¿½pï¿½æ‘œ
	hp.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 2, Vector2(0.0f, 0.0f), false, false);
	hp.SetPosition(Vector3(28, 650, 0));
	hp.SetScale(Vector2(4 * 1, 48 * 1));
	hp.LoadTexture(spriteCommon_, 2, L"Resources/life.png", dxCommon_->GetDevice());
	hp.SpriteTransferVertexBuffer(hp, 2);
	hp.SpriteUpdate(hp, spriteCommon_);

	//gameclearï¿½Ì‰æ‘œ
	clearGH.LoadTexture(spriteCommon_, 3, L"Resources/clear.png", dxCommon_->GetDevice());
	clearGH.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 3, Vector2(0.0f, 0.0f), false, false);
	clearGH.SetScale(Vector2(1280 * 1, 720 * 1));
	clearGH.SpriteTransferVertexBuffer(clearGH, 3);
	clearGH.SpriteUpdate(clearGH, spriteCommon_);

	//gameoverï¿½Ì‰æ‘œ
	overGH.LoadTexture(spriteCommon_, 4, L"Resources/over.png", dxCommon_->GetDevice());
	overGH.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 4, Vector2(0.0f, 0.0f), false, false);
	overGH.SetScale(Vector2(1280 * 1, 720 * 1));
	overGH.SpriteTransferVertexBuffer(overGH, 4);
	overGH.SpriteUpdate(overGH, spriteCommon_);

	for (int i = 0; i < 10; i++) {
		lock[i].LoadTexture(spriteCommon_, 1, L"Resources/crosshair.png", dxCommon_->GetDevice());
		lock[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 1, Vector2(0.0f, 0.0f), false, false);
		lock[i].SetScale(Vector2(128 * 1, 128 * 1));
		lock[i].SpriteTransferVertexBuffer(lock[i], 1);
		lock[i].SpriteUpdate(lock[i], spriteCommon_);
	}

	//fade
	fade.LoadTexture(spriteCommon_, 5, L"Resources/black.png", dxCommon_->GetDevice());
	fade.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 5, Vector2(0.0f, 0.0f), false, false);
	fade.SetScale(Vector2(1280 * 1, 720 * 1));
	fade.SpriteTransferVertexBuffer(fade, 5);
	fade.SpriteUpdate(fade, spriteCommon_);
	//alpha
	fadeAlpha = 1.0f;
	fade.SetAlpha(fade, fadeAlpha);
	//boosHP
	bossHP.LoadTexture(spriteCommon_, 6, L"Resources/hp.png", dxCommon_->GetDevice());
	bossHP.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 6, Vector2(0.0f, 0.5f), false, false);
	bossHP.SetPosition(Vector3(25, 50, 0));
	bossHP.SetScale(Vector2(2 * 1, 48 * 1));
	bossHP.SpriteTransferVertexBuffer(bossHP, 6);
	bossHP.SpriteUpdate(bossHP, spriteCommon_);
	//gage
	gage.LoadTexture(spriteCommon_, 7, L"Resources/green.png", dxCommon_->GetDevice());
	gage.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 7, Vector2(0.0f, 0.5f), false, false);
	gage.SetPosition(Vector3(28, 641, 0));
	gage.SetScale(Vector2(2 * 1, 18 * 1));
	gage.SpriteTransferVertexBuffer(gage, 7);
	gage.SpriteUpdate(gage, spriteCommon_);
	//
	gageBack.LoadTexture(spriteCommon_, 8, L"Resources/green.png", dxCommon_->GetDevice());
	gageBack.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 8, Vector2(0.0f, 0.5f), false, false);
	gageBack.SetPosition(Vector3(28, 641, 0));
	gageBack.SetScale(Vector2(2 * 178, 18 * 1));
	gageBack.SetAlpha(gageBack, 0.5f);
	gageBack.SpriteTransferVertexBuffer(gageBack, 8);
	gageBack.SpriteUpdate(gageBack, spriteCommon_);
	//
	hpBack.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 9, Vector2(0.0f, 0.0f), false, false);
	hpBack.SetPosition(Vector3(28, 650, 0));
	hpBack.SetScale(Vector2(396, 48 * 1));
	hpBack.LoadTexture(spriteCommon_, 9, L"Resources/life.png", dxCommon_->GetDevice());
	hpBack.SetAlpha(hpBack, 0.5f);
	hpBack.SpriteTransferVertexBuffer(hpBack, 9);
	hpBack.SpriteUpdate(hpBack, spriteCommon_);
	//ï¿½tï¿½Fï¿½[ï¿½hï¿½Aï¿½Eï¿½g
	fadeout.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 10, Vector2(1.0f, 0.0f), false, false);
	fadeout.SetScale(Vector2(1280 * 1, 1120 * 1));
	fadeout.SetPosition({ 0,100,0 });
	fadeout.SetRotation(45);
	fadeout.SpriteTransferVertexBuffer(fadeout, 10);
	fadeout.SpriteUpdate(fadeout, spriteCommon_);
	fadeout.LoadTexture(spriteCommon_, 10, L"Resources/fade.png", dxCommon_->GetDevice());

	//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	particle = Particle::LoadParticleTexture("blue.png");
	pm_ = ParticleManager::Create();
	particle_ = Particle::LoadParticleTexture("crosshair.png");
	pm = ParticleManager::Create();
	//ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Éƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½Rï¿½tï¿½ï¿½ï¿½ï¿½
	pm->SetParticleModel(particle);
	pm_->SetParticleModel(particle_);
	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½g
	pm->SetXMViewProjection(xmViewProjection);
	pm_->SetXMViewProjection(xmViewProjection);

	////ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½Ä“Ç‚Ýï¿½ï¿½ï¿½
	//obj = new FbxObject3d;
	//obj->Initialize();
	//model = FbxLoader::GetInstance()->LoadModelFlomFile("cube");
	//obj->SetModel(model);
	//obj->SetPosition(Vector3(1, 0, -10));
	//obj->SetScale(Vector3((float)0.01, (float)0.01, (float)0.01));

	//boss
	boss = new Boss;
	boss->BossInitialize();
	boss->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 10.0f));


	//ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Ì“Ç‚Ýï¿½ï¿½ï¿½
	stageNum = 1;
	LoadStage(stageNum);
	LoadEnemy(stageNum);
	//ï¿½Ïï¿½
	isCheckPoint = false;
	isPlayable = false;
	gameState = MAIN;
	infos.clear();
	gameTime = 150;
	cursorRotate = 0.001f;
	bossPass = 0;
	cameraTmpPos = { 0,0,0 };
	cameraTmpRot = { 0,0,0 };
	isStart = false;
}

///-----ï¿½Xï¿½Vï¿½ï¿½ï¿½ï¿½-----///
void GameScene::Update() {
	//ï¿½Nï¿½ï¿½ï¿½Xï¿½wï¿½Aï¿½ï¿½ï¿½Xï¿½V
	GetCrosshair();
	//ï¿½ï¿½ï¿½Zï¿½bï¿½g
	if (Input::GetInstance()->TriggerKey(DIK_R)) {
		Reset();
		gameState = MAIN;
		gameTime = 150;
		railCamera->GetView()->SetEye(Vector3(-1, 0.5f, 490.0f));
		railCamera->GetView()->SetTarget(Vector3(0.0f, 0.5f, 495));
		player->SetPosition({ 0,0.5f,495 });
		Vector3 cursor = GetWorldToScreenPos(Vector3(0, 0, 0), railCamera);
		input->SetMousePos({ cursor.x,cursor.y });
	}
	if (isStart == false) {
		fadeAlpha = 0.0f;
		fade.SetAlpha(fade, fadeAlpha);
		gameTime = 150;
		railCamera->GetView()->SetEye(Vector3(-1, 0.5f, 490.0f));
		railCamera->GetView()->SetTarget(Vector3(0.0f, 0.5f, 495));
		player->SetPosition({ 0,0.5f,495 });
		Vector3 cursor = GetWorldToScreenPos(Vector3(-230, 85, 0), railCamera);
		input->SetMousePos({ cursor.x,cursor.y });
		for (auto& object : objects) {
			object->Update();
		}
		isStart = true;
	}
	//ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Qï¿½[ï¿½ï¿½ï¿½Jï¿½nï¿½ï¿½ï¿½tï¿½Fï¿½[ï¿½hï¿½Aï¿½Eï¿½g
	//if (fadeout.GetPosition().y < 400) {
	//	fadeout.SetPosition(fadeout.GetPosition() + Vector3(0, 40, 0));
	//	fadeout.SpriteUpdate(fadeout, spriteCommon_);
	//}

	Vector3 shotVec = { 0,0,0 };


  //ï¿½ï¿½ï¿½ï¿½Â”\ï¿½ï¿½Ô‚È‚ï¿½HPï¿½ï¿½ï¿½Xï¿½V
	if (isPlayable == true) {
		//playerhp
		float playerHp_ = player->GetHP() - (hp.GetScale().x / 4);
		if (playerHp_ > 0) {
			if ((playerHp_) > 4) {
				hp.SetScale(hp.GetScale() + Vector2(16.0f, 0.0f));
			}
			else if ((playerHp_) > 2) {
				hp.SetScale(hp.GetScale() + Vector2(8.0f, 0.0f));
			}
			else if ((playerHp_) > 1) {
				hp.SetScale(hp.GetScale() + Vector2(4.0f, 0.0f));
			}
		}
		else if (playerHp_ < 0) {
			if ((playerHp_) < 4) {
				hp.SetScale(hp.GetScale() - Vector2(8.0f, 0.0f));
			}
			else if ((playerHp_) < 2) {
				hp.SetScale(hp.GetScale() - Vector2(4.0f, 0.0f));
			}
			else if ((playerHp_) < 1) {
				hp.SetScale(hp.GetScale() - Vector2(2.0f, 0.0f));
			}
		}

		hp.SpriteTransferVertexBuffer(hp, 2);
		hp.SpriteUpdate(hp, spriteCommon_);
		//gage
		float gage_ = player->GetEnergy() - (gage.GetScale().x / 4);
		if (gage_ > 0) {
			if (player->GetEnergy() < 100) {
				if ((gage_) > 4) {
					gage.SetScale(gage.GetScale() + Vector2(16.0f, 0.0f));
				}
				else if ((gage_) > 2) {
					gage.SetScale(gage.GetScale() + Vector2(8.0f, 0.0f));
				}
				else if ((gage_) > 1) {
					gage.SetScale(gage.GetScale() + Vector2(4.0f, 0.0f));
				}
			}
		}
		else if (gage_ < 0) {
			if ((gage_) < 4) {
				gage.SetScale(gage.GetScale() - Vector2(8.0f, 0.0f));
			}
			else if ((gage_) < 2) {
				gage.SetScale(gage.GetScale() - Vector2(4.0f, 0.0f));
			}
			else if ((gage_) < 1) {
				gage.SetScale(gage.GetScale() - Vector2(2.0f, 0.0f));
			}
		}

		gage.SpriteTransferVertexBuffer(gage, 7);
		gage.SpriteUpdate(gage, spriteCommon_);
	}

	//ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½
	switch (gameState)
	{
		//ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Qï¿½[ï¿½ï¿½
	case GameScene::MAIN:
		//ï¿½Qï¿½[ï¿½ï¿½ï¿½Xï¿½^ï¿½[ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½o
		if (gameTime > 0) {
			//SPACEï¿½Å‰ï¿½ï¿½oï¿½Xï¿½Lï¿½bï¿½v
			if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
				gameTime = 1;
			}
			railCamera->GetView()->SetEye(railCamera->GetView()->GetEye() + Vector3(0, 0.0f, 0.05f));
			gameTime--;
			if (gameTime <= 0) {
				player->SetPosition(Vector3(0, -1.0f, -5.5f));
				player->SetAlpha(0.0f);
			}
			player->worldTransform_.UpdateMatrix();
		}
		//ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½
		if (gameTime == 0) {
			//ï¿½ï¿½ï¿½ï¿½sï¿½Âï¿½Ô‚ï¿½ï¿½ï¿½ï¿½ï¿½
			if (isPlayable == false) {
				isPlayable = true;
			}
			//bossï¿½ï¿½ï¿½
			if (railCamera->GetOnRail() == false) {
				if (isCheckPoint == false) {
					isCheckPoint = true;
					boss->Pop();
					gameState = BOSS;
					delete railCamera;
					railCamera = new RailCamera;
					railCamera->Initialize(player);
				}
			}
			/////ï¿½fï¿½oï¿½bï¿½Nï¿½p(ï¿½{ï¿½Xï¿½Ü‚ÅƒXï¿½Lï¿½bï¿½v)/////
			if (input->TriggerKey(DIK_B)) {
				railCamera->SetOnRail(false);
			}

			//playerï¿½Xï¿½V(ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Ì‘O)
			if (input->PushMouseLeft()) {
				shotVec = GetScreenToWorldPos(crosshair[0], railCamera);
			}
			if (isPlayable == true) {
				SerchEnemy();
				player->Update(shotVec, infos);
				if (gameState == BOSS && railCamera->GetOnRail() == true) {
					player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				}
				LockedClear();
			}
			//ï¿½Xï¿½V
			railCamera->Update(player, points);
			//ï¿½_ï¿½ï¿½ï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ‚ï¿½ï¿½É‰ï¿½ÊƒVï¿½Fï¿½Cï¿½N
			if (player->GetIsHit() == true) {
				railCamera->ShakeCamera(-0.2f, 0.2f);
			}
		}
		break;
		//ï¿½{ï¿½Xï¿½ï¿½
	case GameScene::BOSS:
		if (boss->GetTimer() > 0) {
			player->SetIsHit(false);
			//playerï¿½ð‘€ï¿½sï¿½Â‚ï¿½
			if (isPlayable == true) {
				isPlayable = false;
				railCamera->GetView()->SetEye(Vector3(-40, 55, -150));
			}
			//SPACEï¿½Å‰ï¿½ï¿½oï¿½Xï¿½Lï¿½bï¿½v
			if (input->TriggerKey(DIK_SPACE)) {
				boss->SkipMovie();
			}
			//ï¿½ï¿½ï¿½o
			railCamera->GetView()->SetTarget(boss->GetPosition());
			if (boss->GetTimer() == 150) {
				railCamera->GetView()->SetEye(Vector3(-80, 55, -300));
			}
			else if (boss->GetTimer() < 150) {
				railCamera->GetView()->SetEye(railCamera->GetView()->GetEye() + Vector3(0.5f, 0.0f, 0.05f));
			}
		}
		else {
			//ï¿½ï¿½ï¿½ï¿½Â”\ï¿½ï¿½Ô‚ï¿½
			if (isPlayable == false) {
				railCamera->GetView()->SetEye(Vector3(0, 60, -95));
				railCamera->GetView()->SetTarget(Vector3(0, 52, -200));
				railCamera->GetCamera()->SetPosition(Vector3(0, 59, -100));
				railCamera->GetCamera()->SetRotation(Vector3(0, 180, 0));
				player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				fadeAlpha = 1.0f;
				fade.SetAlpha(fade, fadeAlpha);
				isPlayable = true;
			}
			//BossHP
			float bossHp_ = boss->GetHP() - (bossHP.GetScale().x / 4);
			if (bossHp_ > 0) {
				if ((bossHp_) > 4) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(16.0f, 0.0f));
				}
				else if ((bossHp_) > 2) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(8.0f, 0.0f));
				}
				else if ((bossHp_) > 1) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(4.0f, 0.0f));
				}
			}
			else if (bossHp_ < 0) {
				if ((bossHp_) < 4) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(8.0f, 0.0f));
				}
				else if ((bossHp_) < 2) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(4.0f, 0.0f));
				}
				else if ((bossHp_) < 1) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(2.0f, 0.0f));
				}
			}
			bossHP.SpriteTransferVertexBuffer(bossHP, 6);
			bossHP.SpriteUpdate(bossHP, spriteCommon_);
			//playerï¿½Xï¿½V(ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Ì‘O)
			if (input->PushMouseLeft()) {
				shotVec = GetScreenToWorldPos(crosshair[0], railCamera);
			}
			if (isPlayable == true) {
				SerchEnemy();
				player->Update(shotVec, infos);
				if (gameState == BOSS && railCamera->GetOnRail() == true) {
					player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				}
				LockedClear();
			}

			//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½V
			if (railCamera->GetOnRail() == false) {
				gameTime++;
				if (gameTime == 300) {
					railCamera->SetOnRail(true);
					gameTime = 0;
				}
			}
			railCamera->Update(player, bossPoint);
			railCamera->GetView()->SetTarget(boss->GetPosition());
			railCamera->GetCamera()->SetRotation(railCamera->GetView()->GetTarget());
			//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
			if (bossPass == 0) {
				if (railCamera->GetPasPoint() + 1.0f > 3.0f) {
					railCamera->SetOnRail(false);
					bossPass = 1;
				}
			}
			else if (bossPass == 1) {
				if (railCamera->GetPasPoint() + 1.0f > 5.0f) {
					railCamera->SetOnRail(false);
					bossPass = 2;
				}
			}
			else if (bossPass == 2) {
				if (railCamera->GetPasPoint() + 1.0f > 7.0f) {
					railCamera->SetOnRail(false);
					bossPass = 3;
				}
			}
			else if (bossPass == 3) {
				if (railCamera->GetPasPoint() + 1.0f >= 8.96f) {
					railCamera->SetOnRail(false);
					railCamera->RailReset();
					bossPass = 0;
				}
			}
		}
		//fadein
		if (fadeAlpha > 0.0f) {
			fadeAlpha -= 0.005f;
			fade.SetAlpha(fade, fadeAlpha);
		}
		//gameclear
		if (boss->GetIsDead() == true) {
			LockedClear();
			GameSceneManager::GetInstance()->ChangeScene("CLEAR");
		}
		//ï¿½Xï¿½V
		boss->Update(player->GetWorldPos());
		//ï¿½_ï¿½ï¿½ï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ‚ï¿½ï¿½É‰ï¿½ÊƒVï¿½Fï¿½Cï¿½N
		if (player->GetIsHit() == true) {
			railCamera->ShakeCamera(-2.0f, 2.0f);
		}
		break;
	case GameScene::ULT:
		if (isPlayable == true) {
			isPlayable = false;
		}
		player->Ultimate();
		railCamera->SetTarget(player->GetWorldPos());
		if (player->GetIsUltimate() == false) {
			player->BackRail();
			railCamera->SetEye(cameraTmpPos);
			railCamera->SetTarget(cameraTmpRot);
			gameState = gameState_bak;
		}
		break;
	}
	//////////////ï¿½ï¿½ï¿½ï¿½Â”\ï¿½È‚ï¿½Xï¿½V///////////////////
	if (player->GetIsUltimate() == true && gameState != ULT) {
		cameraTmpPos = railCamera->GetView()->GetEye();
		cameraTmpRot = railCamera->GetView()->GetTarget();
		railCamera->SetEye(player->GetWorldPos() + Vector3(-2, 0, -3));
		railCamera->SetTarget(player->GetWorldPos());
		gameState_bak = gameState;
		gameState = ULT;
	}
	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½Oï¿½Ì—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½íœ
	enemys_.remove_if([](std::unique_ptr < Enemy>& enemy_) {
		return enemy_->GetIsDead();
		});
	//ï¿½Gï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½ÌXï¿½V
	for (const std::unique_ptr<Enemy>& enemy : enemys_) {
		enemy->Update(player->GetWorldPos(), railCamera->GetPasPoint());
	}
	//ï¿½Kï¿½Eï¿½Zï¿½Gï¿½lï¿½ï¿½ï¿½Mï¿½[
	for (const std::unique_ptr<Energy>& energy : energys_) {
		energy->Update(player->GetWorldPos(), railCamera->GetCamera()->GetRotation());
	}
	//ï¿½fï¿½Xï¿½tï¿½ï¿½ï¿½Oï¿½Ì—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½íœ
	energys_.remove_if([](std::unique_ptr <Energy>& energys_) {
		return energys_->GetIsDead();
		});
	//gameover
	if (player->GetHP() == 0) {
		LockedClear();
		GameSceneManager::GetInstance()->ChangeScene("OVER");
	}
	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	collisionManager->CheckAllCollisions();
}

void GameScene::Draw() {
#pragma region 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½`ï¿½ï¿½

	dxCommon_->PreDraw();

	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	Object3d::PreDraw(dxCommon_->GetCommandList());

	//ï¿½wï¿½iï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
	for (auto& object : objects) {
		object->Draw(railCamera->GetView());
	}
	//ï¿½Gï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½Ì•`ï¿½ï¿½
	for (const std::unique_ptr<Enemy>& enemy : enemys_) {
		enemy->EnemyDraw(railCamera->GetView());
	}
	for (const std::unique_ptr<Energy>& energy : energys_) {
		energy->Draw(railCamera->GetView());
	}
	//ï¿½{ï¿½X
	if (gameState == BOSS) {
		boss->BossDraw(railCamera->GetView());
	}
	//ï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½[
	player->PlayerDraw(railCamera->GetView());

	// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	Object3d::PostDraw();

#pragma endregion

#pragma region FBX3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½`ï¿½ï¿½

	//// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	//FbxObject3d::PreDraw(dxCommon_->GetCommandList());

	//// 3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	//FbxObject3d::PostDraw();

#pragma endregion

#pragma region ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½`ï¿½ï¿½

	// ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	ParticleManager::PreDraw(dxCommon_->GetCommandList());

	///==== ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½`ï¿½ï¿½ ====///
	//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½
	/*pm->Draw();
	pm_->Draw();*/

	// ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	ParticleManager::PostDraw();

#pragma endregion

#pragma region ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½`ï¿½ï¿½

	// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½`ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½
	Sprite::PreDraw(dxCommon_->GetCommandList(), spriteCommon_);

	///=== ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½`ï¿½ï¿½ ===///

	if (gameState == BOSS) {
		fade.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		if (boss->GetTimer() == 0) {
			//ï¿½{ï¿½Xï¿½ï¿½HP
			bossHP.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
	}
	if (isPlayable == true) {
		hpBack.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		gageBack.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		hp.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		gage.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}
	if (isPlayable == true) {
		for (int i = 0; i < 4; i++) {
			crosshair[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
	}
	for (int i = 0; i < infos.size(); i++) {
		lock[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}
	fadeout.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());

	// ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½`ï¿½ï¿½ãˆï¿½ï¿½
	Sprite::PostDraw();

	dxCommon_->PostDraw();
}

void GameScene::LoadStage(int stageNum) {
	points.clear();
	bossPoint.clear();

	//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½
	std::ifstream file;
	file.open("Resources/csv/stagePop.csv");
	assert(file.is_open());

	HRESULT result = S_FALSE;

	std::string num;
	num = stageNum + 48;

	// ï¿½Pï¿½sï¿½ï¿½ï¿½Â“Ç‚Ýï¿½ï¿½ï¿½
	string line;
	while (getline(file, line)) {

		// ï¿½Pï¿½sï¿½ï¿½ï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½Ä‰ï¿½Í‚ï¿½ï¿½â‚·ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		std::istringstream line_stream(line);

		// ï¿½ï¿½ï¿½pï¿½Xï¿½pï¿½[ï¿½Xï¿½ï¿½Ø‚ï¿½Åsï¿½Ìæ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
		string key;
		getline(line_stream, key, ' ');


		// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½stï¿½È‚ï¿½Xï¿½eï¿½[ï¿½W
		if (key == "st" + num) {
			// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
			points.emplace_back(position);
		}
		if (stageNum == 10) {
			if (key == "st10") {
				// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
				points.emplace_back(position);
			}
		}
		else if (stageNum > 10) {
			if (key == "st1" + stageNum - 10) {
				// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
				points.emplace_back(position);
			}
		}
		//ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½boï¿½È‚ï¿½{ï¿½X
		if (key == "bo" + num) {
			// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
			bossPoint.emplace_back(position);
		}
		if (stageNum == 10) {
			if (key == "st10") {
				// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
				bossPoint.emplace_back(position);
			}
		}
		else if (stageNum > 10) {
			if (key == "st1" + stageNum - 10) {
				// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
				bossPoint.emplace_back(position);
			}
		}
	}
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Æ•Â‚ï¿½ï¿½ï¿½
	file.close();
}

void GameScene::Reset() {
	delete player;
	delete railCamera;
	delete enemy;
	delete boss;

	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 0.7f));
	player->SetPosition({ 0,0.5f,495 });
	hp.SetScale(Vector2(0, 48 * 1));
	//boss
	boss = new Boss;
	boss->BossInitialize();
	boss->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 10.0f));
	bossHP.SetScale(Vector2(12 * 1, 48 * 1));
	//camera
	railCamera = new RailCamera;
	railCamera->Initialize(player);
	//enemy
	LoadEnemy(stageNum);
	//ï¿½Ïï¿½
	isCheckPoint = false;
	isPlayable = false;
	cursorRotate = 0.001f;
	LockedClear();
	infos.clear();
	gameState = MAIN;
	gameTime = 150;
	bossPass = 0;
	fadeAlpha = 1.0f;
	fade.SetAlpha(fade, fadeAlpha);
	popEnergyCount = 0;
}

void GameScene::Finalize()
{
}

void GameScene::LoadEnemy(int stageNum) {

	Spline spline;
	spline.Initialize();

	pointsL = points;
	pointsR = points;

	for (int i = 0; i < points.size(); i++)
	{
		pointsL[i] += Vector3(-2, 0, 0);
		pointsR[i] += Vector3(2, 0, 0);
	}

	enemys_.clear();

	//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½
	std::ifstream file;
	file.open("Resources/csv/EnemyPop.csv");
	assert(file.is_open());

	HRESULT result = S_FALSE;

	std::string num;
	num = stageNum + 48;

	// ï¿½Pï¿½sï¿½ï¿½ï¿½Â“Ç‚Ýï¿½ï¿½ï¿½
	string line;
	while (getline(file, line)) {

		// ï¿½Pï¿½sï¿½ï¿½ï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½Ä‰ï¿½Í‚ï¿½ï¿½â‚·ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		std::istringstream line_stream(line);

		// ï¿½ï¿½ï¿½pï¿½Xï¿½pï¿½[ï¿½Xï¿½ï¿½Ø‚ï¿½Åsï¿½Ìæ“ªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½æ“¾
		string key;
		getline(line_stream, key, ' ');

		string word;
		getline(line_stream, word, ' ');

		if (stageNum < 10) {
			// ï¿½æ“ªï¿½ï¿½ï¿½ï¿½ï¿½ñ‚ª‚ï¿½ï¿½È‚ç’¸ï¿½_ï¿½ï¿½ï¿½W
			if (key == "ea" + num) {
				//ï¿½Gï¿½Ìï¿½ï¿½ï¿½
				std::unique_ptr<Enemy> newEnemy = std::make_unique<Enemy>();
				//ï¿½Gï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
				newEnemy->EnemyInitialize();
				////ï¿½Rï¿½ï¿½ï¿½Cï¿½_ï¿½[ï¿½Ì’Ç‰ï¿½
				newEnemy->SetCollider(new SphereCollider());
				// X,Y,Zï¿½ï¿½ï¿½Wï¿½Ç‚Ýï¿½ï¿½ï¿½
				Vector3 position{};
				float t;

				if (word.find("L") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(pointsL, t);
				}
				else if (word.find("M") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(points, t);
				}
				else if (word.find("R") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(pointsR, t);
				}

				// ï¿½ï¿½ï¿½Wï¿½fï¿½[ï¿½^ï¿½É’Ç‰ï¿½
				newEnemy->SetPosition(position);
				newEnemy->SetScale({ 0.6f,0.6f,0.6f });
				//ï¿½oï¿½^
				enemys_.push_back(std::move(newEnemy));
			}
		}
	}
	// ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½Æ•Â‚ï¿½ï¿½ï¿½
	file.close();
}

void GameScene::SerchEnemy()
{
	Vector3 cur = input->GetMousePos();

	if (input->PushKey(DIK_LSHIFT)) {
		for (int i = 0; i < boss->GetPartsNum(); i++) {
			Vector3 epos1 = GetWorldToScreenPos(boss->GetParts(i)->GetWorldPos(), railCamera);
			if (boss->GetIsInvisible() == false) {
				if (pow((epos1.x - cur.x), 2) + pow((epos1.y - cur.y), 2) < pow(50, 2)) {
					if (boss->GetParts(i)->GetIsLocked() == false && infos.size() < 10) {
						LockInfo info;
						info.vec = boss->GetParts(i)->GetWorldPos();
						info.obj = boss->GetParts(i);
						infos.push_back(info);
						boss->GetParts(i)->SetIsLocked(true);
					}
				}
			}
		}

		for (const std::unique_ptr<Enemy>& enemy : enemys_) {
			Vector3 epos2 = GetWorldToScreenPos(enemy->GetWorldPos(), railCamera);
			Vector3 len = enemy->GetWorldPos() - player->GetWorldPos();
			float len_ = len.length();
			if (pow((epos2.x - cur.x), 2) + pow((epos2.y - cur.y), 2) < pow(30, 2)) {
				if (enemy->GetIsLocked() == false && infos.size() < 10) {
					LockInfo info;
					info.vec = enemy->GetWorldPos();
					info.obj = enemy->GetPointer();
					infos.push_back(info);
					enemy->SetIsLocked(true);
				}
			}
		}
		if (cursorRotate < 0.005f) {
			cursorRotate += 0.0001f;
		}
	}
	else {
		if (cursorRotate > 0.001f) {
			cursorRotate -= 0.0001f;
		}
	}
	//ï¿½ï¿½ï¿½bï¿½Nï¿½Iï¿½ï¿½ï¿½æ‘œï¿½ÌXï¿½V
	for (int i = 0; i < infos.size(); i++) {
		lock[i].SetScale(GetWorldToScreenScale(infos[i].obj, railCamera));
		lock[i].SetPosition(GetWorldToScreenPos(infos[i].obj->GetWorldPos(), railCamera) - (Vector3(lock[i].GetScale().x, lock[i].GetScale().y, 0) / 2));
		lock[i].SpriteUpdate(lock[i], spriteCommon_);
		lock[i].SpriteTransferVertexBuffer(lock[i], 1);
	}
}

void GameScene::LockedClear()
{
	if (player->GetIsShooted() == true) {
		if (boss->GetIsLocked() == true) {
			boss->SetIsLocked(false);
		}

		for (const std::unique_ptr<Enemy>& enemy : enemys_) {
			if (enemy->GetIsLocked() == true) {
				enemy->SetIsLocked(false);
			}
		}
		infos.clear();
	}
}

void GameScene::GetCrosshair()
{
	Vector3 mPos = input->GetMousePos();
	//ï¿½}ï¿½Eï¿½Xï¿½Jï¿½[ï¿½\ï¿½ï¿½ï¿½ÌêŠï¿½ÉƒNï¿½ï¿½ï¿½Xï¿½wï¿½Aï¿½ï¿½\ï¿½ï¿½
	if (gameState == MAIN) {
		for (int i = 0; i < 4; i++) {
			if (i == 0) {
				crosshair[i].SetPosition(mPos);
			}
			else if (i == 1) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.1f);
			}
			else if (i == 2) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.25f);
			}
			else if (i == 3) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.55f);
			}
			if (i % 2 == 0) {
				crosshair[i].SetRotation(crosshair[i].GetRotation() + cursorRotate);
			}
			else {
				crosshair[i].SetRotation(crosshair[i].GetRotation() - cursorRotate);
			}
			if (crosshair[i].GetRotation() == 1.0f) {
				crosshair[i].SetRotation(0.0f);
			}
			crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
			crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
		}
	}
	else {
		for (int i = 0; i < 4; i++) {
			crosshair[i].SetPosition(mPos);
			if (i % 2 == 0) {
				crosshair[i].SetRotation(crosshair[i].GetRotation() + cursorRotate);
			}
			else {
				crosshair[i].SetRotation(crosshair[i].GetRotation() - cursorRotate);
			}
			if (crosshair[i].GetRotation() == 1.0f) {
				crosshair[i].SetRotation(0.0f);
			}
			crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
			crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
		}
	}
}

void GameScene::PopEnergy(Vector3 pos_)
{
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½u
	std::random_device seed_gen;
	std::mt19937_64 engine(seed_gen());
	std::uniform_real_distribution<float>dist(-1.5f, 1.5f);
	std::uniform_real_distribution<float>dist2(-2.5f, 2.5f);
	std::uniform_real_distribution<float>dist3(-1.5f, 1.5f);
	//ï¿½eï¿½ð¶ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	std::unique_ptr<Energy> newEnergy = std::make_unique<Energy>();

	//ï¿½Pï¿½ï¿½													   
	newEnergy->EnergyInitialize();
	newEnergy->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 2.0f));
	newEnergy->SetPosition(pos_ + Vector3(dist(engine), dist2(engine), dist3(engine)));
	energys_.push_back(std::move(newEnergy));
}

Vector3 GameScene::GetScreenToWorldPos(Sprite& sprite_, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector3(0, 0, 1);
	}

	//ï¿½rï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½sï¿½ñ¶ï¿½
	Matrix4 viewPort = viewPort.ViewPortMat(WinApp::window_width, WinApp::window_height, Vector2(0.0f, 0.0f));

	//ï¿½rï¿½ï¿½ï¿½[ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½
	Matrix4 invViewPort = viewPort;
	invViewPort.MakeInverse();
	//ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½//
	float fovAngleY = 45.0f * (3.141592f / 180.0f);;
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	//ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ñ¶ï¿½
	Matrix4 projection = projection.ProjectionMat(fovAngleY, aspectRatio, 0.1f, 200.0f);
	Matrix4 invProjection = projection;
	invProjection.MakeInverse();
	//ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½//
	Matrix4 view = railCamera->GetView()->GetMatView();
	Matrix4 invView = view;
	invView.MakeInverse();
	////ï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½Ì‹tï¿½sï¿½ï¿½ï¿½ï¿½vï¿½Zï¿½ï¿½ï¿½ï¿½
	Matrix4 matInverseVPV = invViewPort * invProjection * invView;
	//ï¿½Xï¿½Nï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½ï¿½ï¿½çƒï¿½[ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Wï¿½n
	Matrix4 mat1, mat2;
	//wï¿½ï¿½ï¿½Z
	Vector3 posNear = Vector3(sprite_.GetPosition().x, sprite_.GetPosition().y, 0);
	Vector3 posFar = Vector3(sprite_.GetPosition().x, sprite_.GetPosition().y, 1);
	posNear = mat1.transform(posNear, matInverseVPV);
	posFar = mat2.transform(posFar, matInverseVPV);

	//ï¿½}ï¿½Eï¿½Xï¿½ï¿½ï¿½Cï¿½Ì•ï¿½ï¿½ï¿½
	Vector3 mouseDirection = posFar - posNear;
	mouseDirection = mouseDirection.normalize();
	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æï¿½ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Ì‹ï¿½ï¿½ï¿½
	const float kDistanceTestObject = 0.05f;

	Vector3 pos = player->GetWorldPos();
	Vector3 translate = (posFar - pos) * kDistanceTestObject;

	return translate;
}

Vector3 GameScene::GetWorldToScreenPos(Vector3 pos_, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector3(0, 0, 0);
	}

	//ï¿½rï¿½ï¿½ï¿½[ï¿½sï¿½ï¿½//
	Matrix4 view = railCamera->GetView()->GetMatView();
	//ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ï¿½//
	float fovAngleY = 45.0f * (3.141592f / 180.0f);;
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	//ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½sï¿½ñ¶ï¿½
	Matrix4 projection = projection.ProjectionMat(fovAngleY, aspectRatio, 0.1f, 200.0f);
	//ï¿½rï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½sï¿½ñ¶ï¿½
	Matrix4 viewPort = viewPort.ViewPortMat(WinApp::window_width, WinApp::window_height, Vector2(0.0f, 0.0f));

	Matrix4 matVPV = view * projection * viewPort;

	Matrix4 mat;
	Vector3 posScreen = pos_;
	posScreen = mat.transform(posScreen, matVPV);
	posScreen.z = 0;

	return posScreen;
}

Vector2 GameScene::GetWorldToScreenScale(Object3d* obj, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector2(0, 0);
	}

	Vector3 v = obj->GetPosition() - rail->GetView()->GetEye();
	v.normalize();
	float len = v.length();

	float x = 64;
	x *= obj->GetScale().x;
	float y = 64;
	y *= obj->GetScale().y;


	return Vector2(x / len, y / len);
}

//void GameScene::LoadObjFromLevelEditor(const std::string& fileName) {
//	JsonLoader* file = nullptr;
//	LevelData* levelData = file->LoadFile(fileName);
//
//	//ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½zï¿½u
//	for (auto& objectData : levelData->objects) {
//		//ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½^ï¿½Ï‚Ýƒï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
//		Model* model = nullptr;
//		decltype(models)::iterator it = models.find(objectData.fileName);
//		if (it != models.end()) { model = it->second; }
//		//ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½wï¿½è‚µï¿½ï¿½3DObjectï¿½ð¶ï¿½
//		Object3d* newObject = Object3d::Create();
//		newObject->Initialize();
//		newObject->SetModel(model);
//		//ï¿½ï¿½ï¿½W
//		Vector3 pos;
//		pos = Vector3(objectData.translation.x, objectData.translation.y, objectData.translation.z);
//		newObject->SetPosition(pos);
//		//ï¿½ï¿½]ï¿½p
//		Vector3 rot;
//		rot = Vector3(objectData.rotation.x, objectData.rotation.y, objectData.rotation.z);
//		newObject->SetRotation(rot);
//		//ï¿½Xï¿½Pï¿½[ï¿½ï¿½
//		Vector3 scale;
//		scale = Vector3(objectData.scaling.x, objectData.scaling.y, objectData.scaling.z);
//		newObject->SetScale(scale);
//		//ï¿½zï¿½ï¿½É“oï¿½^
//		objects.push_back(newObject);
//	}
//}

============================================================
File Path: engine/scene/GameScene.h
============================================================
#pragma once
#include "Sprite.h"
#include "Object3d.h"
#include"WinApp.h"
#include"DirectXCommon.h"
#include "Object3d.h"
#include "Input.h"
#include "time.h"
#include <random>
#include "Model.h"
#include "ViewProjection.h"
#include "Particle.h"
#include "ParticleManager.h"
#include "FbxObject3d.h"
#include "FbxModel.h"
#include "Player.h"
#include "RailCamera.h"
#include "Enemy.h"
#include "CollisionManager.h"
#include "Boss.h"
#include "JsonLoader.h"	
#include "energy.h"
#include "GameBaseScene.h"


class GameScene : public GameBaseScene {
public:
	//ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	GameScene();

	~GameScene();

	void Initialize() override;
	/*void LoadObjFromLevelEditor(const std::string& fileName);*/

	void Update();

	void Draw();
	void Reset();
	void Finalize()override;

	void LoadStage(int stageNum);
	void LoadEnemy(int stageNum);
	void SerchEnemy();
	void LockedClear();
	void GetCrosshair();
	static void PopEnergy(Vector3 pos_);

	Vector3 GetScreenToWorldPos(Sprite& sprite_, RailCamera* rail);
	Vector3 GetWorldToScreenPos(Vector3 pos_, RailCamera* rail);
	Vector2 GetWorldToScreenScale(Object3d* obj, RailCamera* rail);

private:
	//base
	DirectXCommon* dxCommon_ = nullptr;
	WinApp* winApp = nullptr;
	//ï¿½ï¿½ï¿½Í‚Ìƒ|ï¿½Cï¿½ï¿½ï¿½^
	Input* input = nullptr;
	//ï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½gï¿½Ìƒ|ï¿½Cï¿½ï¿½ï¿½^
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite titleGH;
	Sprite crosshair[4];
	Sprite hp;
	Sprite clearGH;
	Sprite overGH;
	Sprite lock[10];
	Sprite fade;
	float fadeAlpha;
	Sprite bossHP;
	Sprite gage;
	Sprite gageBack;
	Sprite hpBack;
	Sprite fadeout;
	//ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Ìƒ|ï¿½Cï¿½ï¿½ï¿½^
	//3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
	Player* player = nullptr;
	Enemy* enemy = nullptr;
	Model* skyModel = nullptr;
	Model* seaModel = nullptr;
	Model* block01Model = nullptr;
	Model* block02Model = nullptr;
	Model* stoneModel = nullptr;
	Boss* boss = nullptr;
	//ï¿½Jï¿½ï¿½ï¿½ï¿½
	ViewProjection* viewProjection = nullptr;
	XMViewProjection* xmViewProjection = nullptr;
	RailCamera* railCamera = nullptr;
	Vector3 cameraTmpPos;
	Vector3 cameraTmpRot;
	//ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½
	Particle* particle = nullptr;
	ParticleManager* pm = nullptr;
	Particle* particle_ = nullptr;
	ParticleManager* pm_ = nullptr;
	//enemy
	std::list<std::unique_ptr<Enemy>> enemys_;
	//energy
	static std::list<std::unique_ptr<Energy>> energys_;
	static int popEnergyCount;
	//ï¿½ï¿½ï¿½ï¿½ï¿½è”»ï¿½ï¿½
	CollisionManager* collisionManager = nullptr;
	//FBX
	FbxModel* model = nullptr;
	FbxObject3d* obj = nullptr;
	//ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Ú“ï¿½ï¿½pï¿½ï¿½ï¿½[ï¿½ï¿½
	std::vector<Vector3> points{};
	std::vector<Vector3> pointsL;
	std::vector<Vector3> pointsR;
	std::vector<Vector3> bossPoint{};
	//ï¿½Xï¿½eï¿½[ï¿½W
	int stageNum = 0;
	bool isCheckPoint = false;
	bool isPlayable = false;
	//ï¿½ï¿½ï¿½bï¿½Nï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½
	std::vector<LockInfo> infos;
	int gameTime;
	float cursorRotate;
	//ï¿½Qï¿½[ï¿½ï¿½ï¿½Xï¿½eï¿½[ï¿½^ï¿½X
	enum GameState {
		MAIN,
		BOSS,
		ULT
	};
	GameState gameState;
	GameState gameState_bak;
	int bossPass;
	bool isStart;
};

============================================================
File Path: engine/scene/GameSceneManager.cpp
============================================================
#include "GameSceneManager.h"

GameSceneManager::~GameSceneManager()
{
	// ï¿½ÅŒï¿½ÌƒVï¿½[ï¿½ï¿½ï¿½ÌIï¿½ï¿½ï¿½Æ‰ï¿½ï¿½
	if (scene_ != nullptr) {
		scene_->Finalize();
		delete scene_;
		scene_ = nullptr;
	}
}

GameSceneManager* GameSceneManager::GetInstance() 
{
	static GameSceneManager instance;

	return &instance;
}

void GameSceneManager::Update()
{
	// ï¿½\ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½Ì—\ï¿½ñ‚ª‚ï¿½ï¿½ï¿½È‚ï¿½
	if (nextScene_) {
		// ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½ÌIï¿½ï¿½
		if (scene_) {
			scene_->Finalize();

			delete scene_;
		}

		// ï¿½Vï¿½[ï¿½ï¿½ï¿½Ø‚ï¿½Ö‚ï¿½
		scene_ = nextScene_;
		nextScene_ = nullptr;

		// ï¿½Vï¿½[ï¿½ï¿½ï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½bï¿½g
		scene_->SetSceneManager(this);

		// ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		scene_->Initialize();
	}

	// ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½Vï¿½ï¿½ï¿½ï¿½
	scene_->Update();
}

void GameSceneManager::Draw()
{
	// ï¿½Vï¿½[ï¿½ï¿½ï¿½Ì•`ï¿½ï¿½
	scene_->Draw();
}

void GameSceneManager::Destroy()
{
	if (scene_ != nullptr) {
		scene_->Finalize();
		delete scene_;
		scene_ = nullptr;
	}
}

void GameSceneManager::ChangeScene(const std::string& sceneName)
{
	assert(sceneFactory_);
	assert(nextScene_ == nullptr);

	// ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	nextScene_ = sceneFactory_->CreateScene(sceneName);
}


============================================================
File Path: engine/scene/GameSceneManager.h
============================================================
#pragma once

#include "GameBaseScene.h"
#include "AbstractSceneFactory.h"

/// <summary>
/// ï¿½Vï¿½[ï¿½ï¿½ï¿½Ç—ï¿½
/// </summary>
class GameSceneManager final
{
private: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	// ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	GameSceneManager() = default;
	// ï¿½fï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^
	~GameSceneManager();

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	/// <summary>
	/// ï¿½Xï¿½V
	/// </summary>
	void Update();

	/// <summary>
	/// ï¿½`ï¿½ï¿½
	/// </summary>
	void Draw();

	/// <summary>
	/// ï¿½Vï¿½[ï¿½ï¿½ï¿½Ì‰ï¿½ï¿½
	/// </summary>
	void Destroy();

public:
	// ï¿½Cï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½Ìì¬
	static GameSceneManager* GetInstance();

private:
	// ï¿½Rï¿½sï¿½[ï¿½Rï¿½ï¿½ï¿½Xï¿½gï¿½ï¿½ï¿½Nï¿½^ï¿½ð–³Œï¿½ï¿½É‚ï¿½ï¿½ï¿½
	GameSceneManager(const GameSceneManager&) = delete;
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½ð–³Œï¿½ï¿½É‚ï¿½ï¿½ï¿½
	GameSceneManager& operator=(const GameSceneManager&) = delete;

public: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	/// <summary>
	/// ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½ï¿½\ï¿½ï¿½
	/// </summary>
	/// <param name="sceneName">ï¿½tï¿½@ï¿½Cï¿½ï¿½ï¿½ï¿½</param>
	void ChangeScene(const std::string& sceneName);

	// ï¿½Vï¿½[ï¿½ï¿½ï¿½tï¿½@ï¿½Nï¿½gï¿½ï¿½ï¿½[ï¿½ï¿½setter
	void SetSceneFactory(AbstractSceneFactory* sceneFactory) { sceneFactory_ = sceneFactory; }

private: // ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Ïï¿½
	// ï¿½ï¿½ï¿½ÌƒVï¿½[ï¿½ï¿½(ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½)
	GameBaseScene* scene_ = nullptr;
	// ï¿½ï¿½ï¿½Vï¿½[ï¿½ï¿½
	GameBaseScene* nextScene_ = nullptr;
	// ï¿½Vï¿½[ï¿½ï¿½ï¿½tï¿½@ï¿½Nï¿½gï¿½ï¿½ï¿½[ï¿½iï¿½Ø‚ï¿½Ä‚ï¿½ï¿½ï¿½j
	AbstractSceneFactory* sceneFactory_ = nullptr;
};



============================================================
File Path: engine/scene/GameTitleScene.cpp
============================================================
ï»¿#include "GameTitleScene.h"

using namespace DirectX;

GameTitleScene::GameTitleScene()
{
	//// ã‚µã‚¦ãƒ³ãƒ‰ã®é™çš„åˆæœŸåŒ–
	//Sound::StaticInitialize();
}

GameTitleScene::~GameTitleScene()
{
}

void GameTitleScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon_ = DirectXCommon::GetInstance();
	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon_->GetDevice());

	//titleã®ç”»åƒ
	title.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 0, Vector2(0.0f, 0.0f), false, false);
	title.SetScale(Vector2(1280 * 1, 720 * 1));
	title.SetPosition({ -354,-32,0 });
	title.SpriteTransferVertexBuffer(title, 0);
	title.SpriteUpdate(title, spriteCommon_);
	title.LoadTexture(spriteCommon_, 0, L"Resources/title.png", dxCommon_->GetDevice());
	//titleèƒŒæ™¯
	for (int i = 0; i < 3; i++) {
		titleBack[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, i + 1, Vector2(0.0f, 0.0f), false, false);
		titleBack[i].SetScale(Vector2(1280 * 1.1, 720 * 1.7));
		titleBack[i].SetPosition({ -418,-192,0 });
		titleBack[i].SpriteTransferVertexBuffer(titleBack[i], i + 1);
		titleBack[i].SpriteUpdate(titleBack[i], spriteCommon_);
	}
	titleBack[0].LoadTexture(spriteCommon_, 1, L"Resources/titleBack.png", dxCommon_->GetDevice());
	titleBack[1].LoadTexture(spriteCommon_, 2, L"Resources/titleBack2.png", dxCommon_->GetDevice());
	titleBack[2].LoadTexture(spriteCommon_, 3, L"Resources/titleBack3.png", dxCommon_->GetDevice());
	//ã‚«ãƒ¼ã‚½ãƒ«
	for (int i = 0; i < 9; i++) {
		cursor[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 4, Vector2(0.5f, 0.5f), false, false);
		cursor[i].SetScale(Vector2(48 * 1, 48 * 1));
		cursor[i].SetPosition(Input::GetInstance()->GetMousePos());
		cursor[i].SetAlpha(cursor[i], 1 - (i * 0.1f));
		cursor[i].SpriteTransferVertexBuffer(cursor[i], 4);
		cursor[i].SpriteUpdate(cursor[i], spriteCommon_);
		cursor[i].LoadTexture(spriteCommon_, 4, L"Resources/cursor.png", dxCommon_->GetDevice());
	}
	//ã‚¯ãƒªãƒƒã‚¯
	for (int i = 0; i < 2; i++) {
		click[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 5+i, Vector2(0.5f, 0.5f), false, false);
		click[i].SetScale(Vector2(312.0f * 1.2f, 52.0f * 1.2f));
		click[i].SetPosition({ 640,640,0 });
		click[i].SpriteTransferVertexBuffer(click[i], 5+i);
		click[i].SpriteUpdate(click[i], spriteCommon_);
	}
	click[0].LoadTexture(spriteCommon_, 5, L"Resources/click1.png", dxCommon_->GetDevice());
	click[1].LoadTexture(spriteCommon_, 6, L"Resources/click2.png", dxCommon_->GetDevice());
	//ã‚«ãƒ¼ã‚½ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	circle.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 7, Vector2(0.5f, 0.5f), false, false);
	circle.SetScale(Vector2(48 * circleSize, 48 * circleSize));
	circle.SetPosition({ 0,0,0 });
	circle.SpriteTransferVertexBuffer(circle, 7);
	circle.SpriteUpdate(circle, spriteCommon_);
	circle.LoadTexture(spriteCommon_, 7, L"Resources/circle.png", dxCommon_->GetDevice());
	//ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	fade.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 8, Vector2(0.0f, 0.0f), false, false);
	fade.SetScale(Vector2(1280 * 1, 1120 * 1));
	fade.SetPosition({ 0,-1120,0 });
	fade.SpriteTransferVertexBuffer(fade, 8);
	fade.SpriteUpdate(fade, spriteCommon_);
	fade.LoadTexture(spriteCommon_, 8, L"Resources/fade.png", dxCommon_->GetDevice());
	//loading
	loading.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 9, Vector2(0.0f, 0.0f), false, false);
	loading.SetScale(Vector2(256 * 1, 48 * 1));
	loading.SetPosition({ 1000,600,0 });
	loading.SpriteTransferVertexBuffer(loading, 9);
	loading.LoadTexture(spriteCommon_, 9, L"Resources/loading.png", dxCommon_->GetDevice());


	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetPosition({ 0.0f,33.3f,288.0f });
	player->SetRotation({ 0,90,0 });

	//ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–
	viewProjection = new ViewProjection();
	viewProjection->Initialize();
	viewProjection->SetEye({ 3.5f,34.5f,298.0f });
	viewProjection->SetTarget({0,40,-400});

	//ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	skyModel = Model::LoadFromOBJ("sky");
	seaModel = Model::LoadFromOBJ("sea");
	block01Model = Model::LoadFromOBJ("block01");
	block02Model = Model::LoadFromOBJ("block02");
	stoneModel = Model::LoadFromOBJ("stone");
	models.insert(std::make_pair("sky", skyModel));
	models.insert(std::make_pair("sea", seaModel));
	models.insert(std::make_pair("block01", block01Model));
	models.insert(std::make_pair("block02", block02Model));
	models.insert(std::make_pair("stone", stoneModel));
	//ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿èª­ã¿è¾¼ã¿
	LoadObjFromLevelEditor("title");
	gameTimer = 0;
	isBackNum = 0;
	onCursor = false;
	isNext = false;
	circleSize = 1.0f;
}

void GameTitleScene::Update()
{
	if (isNext == false) {
		Vector3 cur = Input::GetInstance()->GetMousePos();
		cursor[8].SetPosition(cursor[7].GetPosition());
		cursor[7].SetPosition(cursor[6].GetPosition());
		cursor[6].SetPosition(cursor[5].GetPosition());
		cursor[5].SetPosition(cursor[4].GetPosition());
		cursor[4].SetPosition(cursor[3].GetPosition());
		cursor[3].SetPosition(cursor[2].GetPosition());
		cursor[2].SetPosition(cursor[1].GetPosition());
		cursor[1].SetPosition(cursor[0].GetPosition());
		cursor[0].SetPosition(cur);
		circle.SetPosition(cur);
		if (Input::GetInstance()->TriggerMouseLeft() == true) {
			circleSize = 1.0f;
		}
		else if (circleSize < 6.0f) {
			circleSize += 0.1f;
		}
		else {
			circleSize = 1.0f;
		}
		circle.SetScale(Vector2(64 * circleSize, 64 * circleSize));
		circle.SpriteTransferVertexBuffer(circle, 7);
		circle.SpriteUpdate(circle, spriteCommon_);
		for (int i = 0; i < 9; i++) {
			cursor[i].SpriteUpdate(cursor[i], spriteCommon_);
		}
		//ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
		if (cur.x > click[0].GetPosition().x - 156 && cur.x < click[0].GetPosition().x + 156) {
			if (cur.y > click[0].GetPosition().y - 26 && cur.y < click[0].GetPosition().y + 26) {
				if (onCursor == false) {
					onCursor = true;
				}
				if (Input::GetInstance()->TriggerMouseLeft()) {
					isNext = true;
					gameTimer = 0;
				}
			}
			else {
				if (onCursor == true) {
					onCursor = false;
				}
			}
		}
		else {
			if (onCursor == true) {
				onCursor = false;
			}
		}
		//ã‚¿ã‚¤ãƒˆãƒ«æ¼”å‡º
		if (gameTimer % 8 == 0) {
			if (isBackNum < 2) {
				isBackNum++;
			}
			else if (isBackNum == 2) {
				isBackNum = 0;
			}
		}
		title.SpriteUpdate(title, spriteCommon_);
		for (int i = 0; i < 3; i++) {
			titleBack[i].SpriteUpdate(titleBack[i], spriteCommon_);
		}
		//ã‚¯ãƒªãƒƒã‚¯
		for (int i = 0; i < 2; i++) {
			click[i].SpriteUpdate(click[i], spriteCommon_);
		}

		//æ›´æ–°
		for (auto& object : objects) {
			object->Update();
		}
		if (gameTimer < 50) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.005f, 0));
		}
		else if (gameTimer < 100) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.005f, 0));
		}
		gameTimer++;
		if (gameTimer > 100) {
			gameTimer = 0;
		}
	}
	else {
		//ã‚·ãƒ¼ãƒ³é·ç§»
		if (gameTimer < 10) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.0075f, 0));
		}
		else if (gameTimer < 25) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.01f, 0));
		}
		else if (gameTimer < 75) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.0025f, 0));
		}
		else if(player->GetPosition().y < 60.0f) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.8f, 0));
			viewProjection->SetTarget(viewProjection->GetTarget() + Vector3(0,3.0f,0));
		}
		else if (fade.GetPosition().y < 0) {
			fade.SetPosition(fade.GetPosition() + Vector3(0, +40, 0));
			fade.SpriteUpdate(fade, spriteCommon_);
		}
		else {
			loading.SpriteUpdate(loading, spriteCommon_);
			//æ¬¡ã‚·ãƒ¼ãƒ³ã¸
			GameSceneManager::GetInstance()->ChangeScene("GAMEPLAY");
		}
		gameTimer++;
	}
	//æ›´æ–°
	player->worldTransform_.UpdateMatrix();
	viewProjection->UpdateMatrix();
}

void GameTitleScene::Draw()
{
	dxCommon_->PreDraw();

	Object3d::PreDraw(dxCommon_->GetCommandList());

	player->Draw(viewProjection);
	//èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	for (auto& object : objects) {
		object->Draw(viewProjection);
	}

	Object3d::PostDraw();

	Sprite::PreDraw(dxCommon_->GetCommandList(), spriteCommon_);
	if (isNext == false) {
		titleBack[isBackNum].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		title.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		if (onCursor == false) {
			click[0].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
		else {
			click[1].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
		circle.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		for (int i = 0; i < 9; i++) {
			cursor[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
   }
	else {
		fade.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		loading.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}

	Sprite::PostDraw();

	dxCommon_->PostDraw();
}

void GameTitleScene::Finalize()
{

}

============================================================
File Path: engine/scene/GameTitleScene.h
============================================================
ï»¿#pragma once

#include "DirectXCommon.h"
#include "Input.h"
#include "Sprite.h"
#include "GameBaseScene.h"
#include "GameSceneManager.h"
#include "GameScene.h"
#include "viewProjection.h"
#include "Player.h"


#include <DirectXMath.h>

class GameTitleScene : public GameBaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	GameTitleScene();

	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~GameTitleScene();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// è§£æ”¾
	/// </summary>
	void Finalize() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// å…¥åŠ›
	Input* input_ = nullptr;
	DirectXCommon* dxCommon_ = nullptr;


	//ã‚«ãƒ¡ãƒ©
	ViewProjection* viewProjection = nullptr;

	//ã‚«ãƒ¼ã‚½ãƒ«
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite title;
	Sprite titleBack[3];
	Sprite cursor[9];
	Sprite click[2];
	Sprite circle;
	Sprite fade;
	Sprite loading;

	Model* skyModel = nullptr;
	Model* seaModel = nullptr;
	Model* block01Model = nullptr;
	Model* block02Model = nullptr;
	Model* stoneModel = nullptr;
	Player* player = nullptr;

	int gameTimer;
	int isBackNum;
	bool onCursor;
	bool isNext;
	float circleSize;
};


============================================================
File Path: engine/scene/SIFrameWork.cpp
============================================================
#include "SIFrameWork.h"

void SIFrameWork::Initialize()
{
	// WindowsAPIï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	winApp = WinApp::GetInstance();
	winApp->Initialize();

	// DirectXï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	dxCommon = DirectXCommon::GetInstance();
	dxCommon->Initialize(winApp);

	// ï¿½ï¿½ï¿½Í‚Ìï¿½ï¿½ï¿½ï¿½ï¿½
	input = Input::GetInstance();
	input->Initialize(winApp);
	//3Dï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	Object3d::StaticInitialize(dxCommon->GetDevice(), WinApp::window_width, WinApp::window_height);
	// ï¿½rï¿½ï¿½ï¿½[ï¿½vï¿½ï¿½ï¿½Wï¿½Fï¿½Nï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	ViewProjection::StaticInitialize(dxCommon->GetDevice());
	// ï¿½Vï¿½[ï¿½ï¿½ï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
	sceneManager_ = GameSceneManager::GetInstance();
	// ï¿½pï¿½[ï¿½eï¿½Bï¿½Nï¿½ï¿½ï¿½Ã“Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	ParticleManager::StaticInitialize(dxCommon->GetDevice());
	//fbxï¿½Ä—pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	FbxLoader::GetInstance()->Initialize(dxCommon->GetDevice());
	//
	FbxObject3d::StaticInitialize(dxCommon->GetDevice());

	/*postEffect.Initialize(dxCommon->GetDevice());*/
	
}

void SIFrameWork::Finalize()
{
	sceneManager_->Destroy();
	//ï¿½Vï¿½[ï¿½ï¿½ï¿½tï¿½@ï¿½Nï¿½gï¿½ï¿½ï¿½Ì‰ï¿½ï¿½
	delete sceneFactory_;

	// WindowsAPIï¿½ÌIï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	winApp->Finalize();

	// DirectXï¿½ï¿½ï¿½
	dxCommon->fpsFixedFinalize();
}

void SIFrameWork::Update()
{
	// Windowsï¿½Ìƒï¿½ï¿½bï¿½Zï¿½[ï¿½Wï¿½ï¿½ï¿½ï¿½
	if (winApp->ProcessMessage()) {
		// ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
		endRequest = true;
	}

	// ï¿½ï¿½ï¿½Í‚ÌXï¿½V
	input->Update();

	if (Input::GetInstance()->TriggerKey(DIK_ESCAPE)) {
		endRequest = true;
	}

	// ï¿½Vï¿½[ï¿½ï¿½ï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½ï¿½ÌXï¿½V
	sceneManager_->Update();
}

void SIFrameWork::Run()
{
	// ï¿½Qï¿½[ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½ï¿½ï¿½
	Initialize();

	while (true) // ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½v 
	{
		// ï¿½ï¿½ï¿½tï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Xï¿½V
		Update();

		// ï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½Gï¿½Xï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½çƒ‹ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
		if (IsEndRequest()) {
			// ï¿½Qï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½vï¿½ð”²‚ï¿½ï¿½ï¿½
			break;
		}

		// ï¿½`ï¿½ï¿½
		Draw();
	}

	// ï¿½Qï¿½[ï¿½ï¿½ï¿½ÌIï¿½ï¿½
	Finalize();
}


============================================================
File Path: engine/scene/SIFrameWork.h
============================================================
#pragma once
#include"Input.h"
#include"WinApp.h"
#include"DirectXCommon.h"
#include "Sprite.h"
#include "Object3d.h"
#include "FbxObject3d.h"
#include"Model.h"
#include "ParticleManager.h"
#include "FbxLoader.h"
#include "AbstractSceneFactory.h"
#include "GameSceneManager.h"

class SIFrameWork
{
public://ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½Öï¿½
	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	virtual void Initialize();
	//ï¿½Iï¿½ï¿½
	virtual void Finalize();
	//ï¿½Xï¿½V
	virtual void Update();
	//ï¿½`ï¿½ï¿½
	virtual void Draw() = 0;
	//ï¿½Iï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½N
	virtual bool IsEndRequest() { return endRequest; }

public:
	virtual ~SIFrameWork() = default;

public:
	//ï¿½ï¿½ï¿½s
	void Run();

protected:
	//WindowsAPIï¿½Ìƒ|ï¿½Cï¿½ï¿½ï¿½^
	WinApp* winApp = nullptr;
	//DirectXï¿½Ìƒ|ï¿½Cï¿½ï¿½ï¿½^
	DirectXCommon* dxCommon = nullptr;
	//ï¿½ï¿½ï¿½Í‚Ìƒ|ï¿½Cï¿½ï¿½ï¿½^
	Input* input = nullptr;
	// ï¿½Vï¿½[ï¿½ï¿½ï¿½}ï¿½lï¿½[ï¿½Wï¿½ï¿½
	GameSceneManager* sceneManager_ = nullptr;
	// ï¿½Vï¿½[ï¿½ï¿½ï¿½tï¿½@ï¿½Nï¿½gï¿½ï¿½ï¿½[
	AbstractSceneFactory* sceneFactory_ = nullptr;
private:
	bool endRequest = false;
};



============================================================
File Path: engine/scene/SceneFactory.cpp
============================================================
#include "SceneFactory.h"

GameBaseScene* SceneFactory::CreateScene(const std::string& sceneName)
{
    // ï¿½ï¿½ï¿½ÌƒVï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
    GameBaseScene* newScene = nullptr;

    if (sceneName == "TITLE") {
        newScene = new GameTitleScene();
    }
    else if (sceneName == "GAMEPLAY") {
        newScene = new GameScene();
    }
    else if (sceneName == "CLEAR") {
        newScene = new GameClearScene();
    }
    else if (sceneName == "OVER") {
        newScene = new GameOverScene();
    }

    return newScene;
}


============================================================
File Path: engine/scene/SceneFactory.h
============================================================
#pragma once

#include "AbstractSceneFactory.h"
#include "GameTitleScene.h"
#include "GameScene.h"
#include "GameClearScene.h"
#include "GameOverScene.h"

/// <summary>
/// ï¿½ï¿½ï¿½ÌƒQï¿½[ï¿½ï¿½ï¿½pï¿½ÌƒVï¿½[ï¿½ï¿½ï¿½Hï¿½ï¿½
/// </summary>
class SceneFactory : public AbstractSceneFactory
{
public:
	/// <summary>
	/// ï¿½Vï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	/// </summary>
	/// <param name="sceneName">ï¿½Vï¿½[ï¿½ï¿½ï¿½ï¿½</param>
	/// <returns></returns>
	GameBaseScene* CreateScene(const std::string& sceneName) override;
};



============================================================
File Path: main.cpp
============================================================
#include "Game.h"


int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
	SIFrameWork* game = new Game();

	game->Run();

	delete game;

	return 0;
}
