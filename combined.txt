### ğŸŒ³ Codebase File Tree (Physical Structure)

â”œâ”€â”€ ./
â”‚   â””â”€â”€ CG2_DirectXGame.vcxproj
â”‚   â””â”€â”€ CG2_DirectXGame.vcxproj.filters
â”‚   â””â”€â”€ main.cpp
â”‚   â”œâ”€â”€ engine/
â”‚   â”‚   â”œâ”€â”€ collision/
â”‚   â”‚   â”‚   â””â”€â”€ CollisionTypes.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionPrimitive.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionManager.h
â”‚   â”‚   â”‚   â””â”€â”€ Collision.h
â”‚   â”‚   â”‚   â””â”€â”€ BaseCollider.h
â”‚   â”‚   â”‚   â””â”€â”€ SphereCollider.cpp
â”‚   â”‚   â”‚   â””â”€â”€ SphereCollider.h
â”‚   â”‚   â”‚   â””â”€â”€ Collision.cpp
â”‚   â”‚   â”‚   â””â”€â”€ CollisionInfo.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionPrimitive.cpp
â”‚   â”‚   â”‚   â””â”€â”€ RaycastHit.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionManager.cpp
â”‚   â”‚   â”œâ”€â”€ math/
â”‚   â”‚   â”‚   â””â”€â”€ Vector2.h
â”‚   â”‚   â”‚   â””â”€â”€ Vector2.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Vector4.h
â”‚   â”‚   â”‚   â””â”€â”€ Matrix4.h
â”‚   â”‚   â”‚   â””â”€â”€ Spline.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Vector3.h
â”‚   â”‚   â”‚   â””â”€â”€ Matrix4.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Spline.h
â”‚   â”‚   â”‚   â””â”€â”€ Vector4.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Vector3.cpp
â”‚   â”‚   â”œâ”€â”€ scene/
â”‚   â”‚   â”‚   â””â”€â”€ GameSceneManager.h
â”‚   â”‚   â”‚   â””â”€â”€ Game.h
â”‚   â”‚   â”‚   â””â”€â”€ SIFrameWork.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameTitleScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameClearScene.h
â”‚   â”‚   â”‚   â””â”€â”€ GameClearScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ SIFrameWork.h
â”‚   â”‚   â”‚   â””â”€â”€ GameBaseScene.h
â”‚   â”‚   â”‚   â””â”€â”€ GameTitleScene.h
â”‚   â”‚   â”‚   â””â”€â”€ SceneFactory.h
â”‚   â”‚   â”‚   â””â”€â”€ AbstractSceneFactory.h
â”‚   â”‚   â”‚   â””â”€â”€ GameOverScene.h
â”‚   â”‚   â”‚   â””â”€â”€ SceneFactory.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Game.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameScene.h
â”‚   â”‚   â”‚   â””â”€â”€ GameOverScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameBaseScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameSceneManager.cpp
â”‚   â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”‚   â””â”€â”€ JsonLoader.h
â”‚   â”‚   â”‚   â””â”€â”€ Input.cpp
â”‚   â”‚   â”‚   â””â”€â”€ DirectXCommon.cpp
â”‚   â”‚   â”‚   â””â”€â”€ DirectXCommon.h
â”‚   â”‚   â”‚   â””â”€â”€ FPSFixed.h
â”‚   â”‚   â”‚   â””â”€â”€ Input.h
â”‚   â”‚   â”‚   â””â”€â”€ WinApp.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FPSFixed.cpp
â”‚   â”‚   â”‚   â””â”€â”€ JsonLoader.cpp
â”‚   â”‚   â”‚   â””â”€â”€ WinApp.h
â”‚   â”‚   â”œâ”€â”€ 2d/
â”‚   â”‚   â”‚   â””â”€â”€ Sprite.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Sprite.h
â”‚   â”‚   â”œâ”€â”€ 3d/
â”‚   â”‚   â”‚   â””â”€â”€ PlayerBullet.cpp
â”‚   â”‚   â”‚   â””â”€â”€ EnemyBullet.h
â”‚   â”‚   â”‚   â””â”€â”€ XMViewProjection.h
â”‚   â”‚   â”‚   â””â”€â”€ Boss.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Player.h
â”‚   â”‚   â”‚   â””â”€â”€ Object3d.h
â”‚   â”‚   â”‚   â””â”€â”€ Energy.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FbxLoader.h
â”‚   â”‚   â”‚   â””â”€â”€ Model.h
â”‚   â”‚   â”‚   â””â”€â”€ FbxModel.h
â”‚   â”‚   â”‚   â””â”€â”€ PlayerBullet.h
â”‚   â”‚   â”‚   â””â”€â”€ Player.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Model.cpp
â”‚   â”‚   â”‚   â””â”€â”€ EnemyBullet.cpp
â”‚   â”‚   â”‚   â””â”€â”€ WorldTransform.cpp
â”‚   â”‚   â”‚   â””â”€â”€ ViewProjection.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FbxModel.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Enemy.h
â”‚   â”‚   â”‚   â””â”€â”€ FbxObject3d.cpp
â”‚   â”‚   â”‚   â””â”€â”€ RailCamera.h
â”‚   â”‚   â”‚   â””â”€â”€ Energy.h
â”‚   â”‚   â”‚   â””â”€â”€ Boss.h
â”‚   â”‚   â”‚   â””â”€â”€ RailCamera.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Enemy.cpp
â”‚   â”‚   â”‚   â””â”€â”€ XMViewProjection.cpp
â”‚   â”‚   â”‚   â””â”€â”€ BossBullet.h
â”‚   â”‚   â”‚   â””â”€â”€ BossBullet.cpp
â”‚   â”‚   â”‚   â””â”€â”€ WorldTransform.h
â”‚   â”‚   â”‚   â””â”€â”€ Object3d.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FbxObject3d.h
â”‚   â”‚   â”‚   â””â”€â”€ ViewProjection.h
â”‚   â”‚   â”‚   â””â”€â”€ FbxLoader.cpp
â”‚   â”‚   â”œâ”€â”€ effect/
â”‚   â”‚   â”‚   â””â”€â”€ Particle.cpp
â”‚   â”‚   â”‚   â””â”€â”€ PostEffect.cpp
â”‚   â”‚   â”‚   â””â”€â”€ ParticleManager.cpp
â”‚   â”‚   â”‚   â””â”€â”€ ParticleManager.h
â”‚   â”‚   â”‚   â””â”€â”€ Particle.h
â”‚   â”‚   â”‚   â””â”€â”€ PostEffect.h
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ scene/
â”‚   â”‚   â”‚   â””â”€â”€ BaseScene.h
â”‚   â”‚   â”‚   â””â”€â”€ BaseScene.cpp
â”‚   â”‚   â”œâ”€â”€ platform/
â”‚   â”‚   â”‚   â””â”€â”€ Framework.h
â”‚   â”‚   â”‚   â””â”€â”€ Framework.cpp

============================================================
FILE CONTENTS START BELOW
============================================================

<file_content path="CG2_DirectXGame.vcxproj">
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e2b32998-cddf-4587-aac4-cfebbfbd82fd}</ProjectGuid>
    <RootNamespace>CG2DirectXGame</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir)engine\external\DirectXTex\include;$(ProjectDir)engine\external\fbx_sdk\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)engine\external\fbx_sdk\lib\Debug;$(ProjectDir)engine\external\DirectXTex\lib\Debug;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\Generated\Obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\Generated\Output\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)engine\external\DirectXTex\include;$(ProjectDir)engine\external\fbx_sdk\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)engine\external\fbx_sdk\lib\Release;$(ProjectDir)engine\external\DirectXTex\lib\Release;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\Generated\Obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\Generated\Output\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)app\scene;$(ProjectDir)app\platform;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\base;$(ProjectDir)engine\effect;$(ProjectDir)engine\math;$(ProjectDir)engine\collision;$(ProjectDir)engine\scene</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-md.lib;libxml2-md.lib;zlib-md.lib;DirectXTex.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_ITERATOR_DEBUG_LEVEL=2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)app\scene;$(ProjectDir)app\platform;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\base;$(ProjectDir)engine\effect;$(ProjectDir)engine\math;$(ProjectDir)engine\collision;$(ProjectDir)engine\scene</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <UndefineAllPreprocessorDefinitions>false</UndefineAllPreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>libfbxsdk-md.lib;libxml2-md.lib;zlib-md.lib;DirectXTex.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="app\platform\Framework.cpp" />
    <ClCompile Include="app\scene\BaseScene.cpp" />
    <ClCompile Include="engine\3d\Boss.cpp" />
    <ClCompile Include="engine\3d\BossBullet.cpp" />
    <ClCompile Include="engine\3d\Enemy.cpp" />
    <ClCompile Include="engine\3d\EnemyBullet.cpp" />
    <ClCompile Include="engine\3d\Energy.cpp" />
    <ClCompile Include="engine\3d\Player.cpp" />
    <ClCompile Include="engine\3d\PlayerBullet.cpp" />
    <ClCompile Include="engine\3d\RailCamera.cpp" />
    <ClCompile Include="engine\base\DirectXCommon.cpp" />
    <ClCompile Include="engine\base\FPSFixed.cpp" />
    <ClCompile Include="engine\base\Input.cpp" />
    <ClCompile Include="engine\base\JsonLoader.cpp" />
    <ClCompile Include="engine\collision\Collision.cpp" />
    <ClCompile Include="engine\collision\CollisionManager.cpp" />
    <ClCompile Include="engine\collision\CollisionPrimitive.cpp" />
    <ClCompile Include="engine\collision\SphereCollider.cpp" />
    <ClCompile Include="engine\effect\PostEffect.cpp" />
    <ClCompile Include="engine\math\Spline.cpp" />
    <ClCompile Include="engine\scene\Game.cpp" />
    <ClCompile Include="engine\scene\GameBaseScene.cpp" />
    <ClCompile Include="engine\scene\GameClearScene.cpp" />
    <ClCompile Include="engine\scene\GameOverScene.cpp" />
    <ClCompile Include="engine\scene\GameSceneManager.cpp" />
    <ClCompile Include="engine\scene\GameTitleScene.cpp" />
    <ClCompile Include="engine\scene\SceneFactory.cpp" />
    <ClCompile Include="engine\scene\SIFrameWork.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="engine\math\Matrix4.cpp" />
    <ClCompile Include="engine\3d\Model.cpp" />
    <ClCompile Include="engine\3d\Object3d.cpp" />
    <ClCompile Include="engine\effect\Particle.cpp" />
    <ClCompile Include="engine\effect\ParticleManager.cpp" />
    <ClCompile Include="engine\2d\Sprite.cpp" />
    <ClCompile Include="engine\math\Vector2.cpp" />
    <ClCompile Include="engine\math\Vector3.cpp" />
    <ClCompile Include="engine\math\Vector4.cpp" />
    <ClCompile Include="engine\3d\ViewProjection.cpp" />
    <ClCompile Include="engine\base\WinApp.cpp" />
    <ClCompile Include="engine\scene\GameScene.cpp" />
    <ClCompile Include="engine\3d\WorldTransform.cpp" />
    <ClCompile Include="engine\3d\XMViewProjection.cpp" />
    <ClCompile Include="engine\3d\FbxLoader.cpp" />
    <ClCompile Include="engine\3d\FbxModel.cpp" />
    <ClCompile Include="engine\3d\FbxObject3d.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\shaders\Basic.hlsli" />
    <None Include="Resources\shaders\FBX.hlsli" />
    <None Include="Resources\shaders\OBJ.hlsli" />
    <None Include="Resources\shaders\Particle.hlsli" />
    <None Include="Resources\shaders\PostEffect.hlsli" />
    <None Include="Resources\shaders\Sprite.hlsli" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\BasicPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\BasicVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXPS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXVS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleGS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Geometry</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Geometry</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Geometry</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticlePS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpritePS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpriteVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="app\platform\Framework.h" />
    <ClInclude Include="app\scene\BaseScene.h" />
    <ClInclude Include="engine\3d\Boss.h" />
    <ClInclude Include="engine\3d\BossBullet.h" />
    <ClInclude Include="engine\3d\Enemy.h" />
    <ClInclude Include="engine\3d\EnemyBullet.h" />
    <ClInclude Include="engine\3d\Energy.h" />
    <ClInclude Include="engine\3d\Player.h" />
    <ClInclude Include="engine\3d\PlayerBullet.h" />
    <ClInclude Include="engine\3d\RailCamera.h" />
    <ClInclude Include="engine\base\DirectXCommon.h" />
    <ClInclude Include="engine\base\FPSFixed.h" />
    <ClInclude Include="engine\base\Input.h" />
    <ClInclude Include="engine\base\json.hpp" />
    <ClInclude Include="engine\base\JsonLoader.h" />
    <ClInclude Include="engine\collision\BaseCollider.h" />
    <ClInclude Include="engine\collision\Collision.h" />
    <ClInclude Include="engine\collision\CollisionInfo.h" />
    <ClInclude Include="engine\collision\CollisionManager.h" />
    <ClInclude Include="engine\collision\CollisionPrimitive.h" />
    <ClInclude Include="engine\collision\CollisionTypes.h" />
    <ClInclude Include="engine\collision\RaycastHit.h" />
    <ClInclude Include="engine\collision\SphereCollider.h" />
    <ClInclude Include="engine\effect\PostEffect.h" />
    <ClInclude Include="engine\math\Matrix4.h" />
    <ClInclude Include="engine\3d\Model.h" />
    <ClInclude Include="engine\3d\Object3d.h" />
    <ClInclude Include="engine\effect\Particle.h" />
    <ClInclude Include="engine\effect\ParticleManager.h" />
    <ClInclude Include="engine\2d\Sprite.h" />
    <ClInclude Include="engine\math\Spline.h" />
    <ClInclude Include="engine\math\Vector2.h" />
    <ClInclude Include="engine\math\Vector3.h" />
    <ClInclude Include="engine\math\Vector4.h" />
    <ClInclude Include="engine\3d\ViewProjection.h" />
    <ClInclude Include="engine\base\WinApp.h" />
    <ClInclude Include="engine\scene\AbstractSceneFactory.h" />
    <ClInclude Include="engine\scene\Game.h" />
    <ClInclude Include="engine\scene\GameBaseScene.h" />
    <ClInclude Include="engine\scene\GameClearScene.h" />
    <ClInclude Include="engine\scene\GameOverScene.h" />
    <ClInclude Include="engine\scene\GameScene.h" />
    <ClInclude Include="engine\3d\WorldTransform.h" />
    <ClInclude Include="engine\3d\XMViewProjection.h" />
    <ClInclude Include="engine\3d\FbxLoader.h" />
    <ClInclude Include="engine\3d\FbxModel.h" />
    <ClInclude Include="engine\3d\FbxObject3d.h" />
    <ClInclude Include="engine\scene\GameSceneManager.h" />
    <ClInclude Include="engine\scene\GameTitleScene.h" />
    <ClInclude Include="engine\scene\SceneFactory.h" />
    <ClInclude Include="engine\scene\SIFrameWork.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
</file_content>

<file_content path="CG2_DirectXGame.vcxproj.filters">
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{0ec641aa-dd1b-4500-8535-382c3827c462}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{8af0deee-6556-46f7-99ed-db9664eaec35}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{385839e5-4dc3-4305-b5f9-d2ff99e4d14b}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d">
      <UniqueIdentifier>{fa0a1209-5613-41f4-8336-a1b32e0bb017}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d">
      <UniqueIdentifier>{c9e7a42e-e554-4643-b452-9d37989931a1}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base">
      <UniqueIdentifier>{ef959771-e341-4b66-b050-784b8557adaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math">
      <UniqueIdentifier>{c5ed0df1-7d03-4dcc-9231-f51298ef7b4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene">
      <UniqueIdentifier>{6bef14bd-ffae-4ac6-9aee-6e82cdf7d056}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect">
      <UniqueIdentifier>{436c057a-8f47-423b-8489-b9aceefb13ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform">
      <UniqueIdentifier>{46d387be-bb6f-44f2-acdc-483e1b27f2b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene">
      <UniqueIdentifier>{0554bbb1-90f0-423b-b877-043bcaaa4592}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{2e619881-ee64-4395-9e02-763883744995}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine">
      <UniqueIdentifier>{dbabf37a-58f2-44ee-90e9-abbd314ee416}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math">
      <UniqueIdentifier>{0025325f-b1da-41dc-8b22-11a61d4549fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene">
      <UniqueIdentifier>{5855e325-0d99-4092-bf18-d5326cc03816}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect">
      <UniqueIdentifier>{3285a7bc-7645-4c4c-a945-e02fdeece07d}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base">
      <UniqueIdentifier>{df34dcd6-551e-4994-8c34-9780c07caa06}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d">
      <UniqueIdentifier>{b1febb7f-4466-46af-aa04-d3bf26ecbdbf}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d">
      <UniqueIdentifier>{5138cc02-99cf-4f0f-bdef-c2321640aa1c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform">
      <UniqueIdentifier>{5d923fb2-2d4d-47e6-ac8a-df6b18b95a2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene">
      <UniqueIdentifier>{bcb6b033-1690-4db6-a7a7-f0e436506639}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj">
      <UniqueIdentifier>{db1e4cf1-5bc3-450f-8d25-9e3810865cb0}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj">
      <UniqueIdentifier>{f3046790-de45-420a-9f52-00891842d0ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera">
      <UniqueIdentifier>{d39ca11e-0299-46e3-9634-f3dae2283183}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera">
      <UniqueIdentifier>{564b3b6e-4c8d-4015-879a-b2fe90bba468}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision">
      <UniqueIdentifier>{6d468e4a-84a8-4f43-aa92-3bd8a1d2e728}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision">
      <UniqueIdentifier>{9db64233-bb0d-4897-ba7c-418dd1007c1e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\Sprite.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3d.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Input.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Matrix4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector2.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector3.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\WorldTransform.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Model.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\Particle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\ParticleManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxModel.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxObject3d.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="app\scene\BaseScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene</Filter>
    </ClCompile>
    <ClCompile Include="app\platform\Framework.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Spline.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Player.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\XMViewProjection.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ViewProjection.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\RailCamera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\PlayerBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Enemy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\Collision.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\CollisionManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\CollisionPrimitive.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\SphereCollider.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\WinApp.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\EnemyBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Boss.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\FPSFixed.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\JsonLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\PostEffect.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\BossBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Energy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\Game.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameBaseScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameClearScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameSceneManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameTitleScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SceneFactory.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SIFrameWork.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameOverScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\shaders\Basic.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\Sprite.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\OBJ.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\Particle.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\FBX.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\PostEffect.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\BasicPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\BasicVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpritePS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpriteVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleGS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticlePS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine\2d\Sprite.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Input.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\WinApp.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3d.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Matrix4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Model.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector2.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector3.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\WorldTransform.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\Particle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\ParticleManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxModel.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxObject3d.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="app\platform\Framework.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform</Filter>
    </ClInclude>
    <ClInclude Include="app\scene\BaseScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Spline.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Player.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\XMViewProjection.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ViewProjection.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\RailCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\PlayerBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Enemy.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\BaseCollider.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\Collision.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionInfo.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionPrimitive.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionTypes.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\RaycastHit.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\SphereCollider.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\EnemyBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\FPSFixed.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\JsonLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\json.hpp">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\PostEffect.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\BossBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Boss.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Energy.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\AbstractSceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\Game.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameBaseScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameClearScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameSceneManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameTitleScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SIFrameWork.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameOverScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
</file_content>

<file_content path="app/platform/Framework.cpp">
#include "Framework.h"

void Framework::Run()
{
	// Q[Ì
	Initialize();

	while (true) // Q[[v 
	{
		// t[XV
		Update();

		// INGXgçƒ‹[vğ”²‚
		if (IsEndRequest()) {
			// Q[[vğ”²‚
			break;
		}
		if (input->TriggerKey(DIK_ESCAPE)) {
			// Q[[vğ”²‚
			break;
		}

		// `
		Draw();
	}

	// Q[ÌI
	Finalize();
}

void Framework::Initialize()
{
	// WindowsAPIÌ
	winApp = WinApp::GetInstance();
	winApp->Initialize();

	// DirectXÌ
	dXCommon = DirectXCommon::GetInstance();
	dXCommon->Initialize(winApp);

	// Í‚Ì
	input = Input::GetInstance();
	input->Initialize(winApp);
	//3DIuWFNgÃ“I
	Object3d::StaticInitialize(dXCommon->GetDevice(), WinApp::window_width, WinApp::window_height);
	// r[vWFNVÌ
	ViewProjection::StaticInitialize(dXCommon->GetDevice());
	// p[eBNÃ“I
	ParticleManager::StaticInitialize(dXCommon->GetDevice());
	//fbxÄ—p
	FbxLoader::GetInstance()->Initialize(dXCommon->GetDevice());
	//
	FbxObject3d::StaticInitialize(dXCommon->GetDevice());

	postEffect.Initialize(dXCommon->GetDevice());
#pragma endregion ÕƒVXeÌ

	//Q[V[
	/*gameScene = new GameScene();*/
	gameScene->Initialize();
}

void Framework::Update()
{
	// WindowsÌƒbZ[W
	if (winApp->ProcessMessage()) {
		// Q[[vğ”²‚
		endRequest_ = true;
	}
	gameScene->Update();
	// Í‚ÌXV
	/*input->Update();*/
}

void Framework::Draw()
{
#pragma region Q[V[`


#pragma endregion

#pragma region `
	postEffect.PreDrawScene(dXCommon->GetCommandList());
	gameScene->Draw();
	postEffect.PostDrawScene(dXCommon->GetCommandList());
	// `O
	dXCommon->PreDraw();
	//=== Q[V[` ===//
	postEffect.Draw(dXCommon->GetCommandList());
	// `ãˆ
	dXCommon->PostDraw();
#pragma endregion
}

void Framework::Finalize()
{
	delete gameScene;
	FbxLoader::GetInstance()->Finalize();
	// WindowsAPIÌI
	winApp->Finalize();

	// DirectX
	dXCommon->fpsFixedFinalize();
	
}

</file_content>

<file_content path="app/platform/Framework.h">
#pragma once

#include "Input.h"
#include "WinApp.h"
#include "DirectXCommon.h"
#include "Sprite.h"
#include "Model.h"
#include "Object3d.h"
#include "GameScene.h"
#include "ParticleManager.h"
#include "FbxLoader.h"
#include "FbxObject3d.h"
#include"WinApp.h"
#include"DirectXCommon.h"

#include<windows.h>
#include<cassert>
#include<vector>
#include<string>
#include<d3dcompiler.h>
#include<DirectXMath.h>
#include<dinput.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include "PostEffect.h"

#pragma comment(lib,"d3dcompiler.lib")
#pragma comment(lib,"dxguid.lib")

class Framework
{

public:
	// s
	void Run();

	// 
	void Initialize();

	// XV
	void Update();

	// XV
	void Draw();

	// I
	void Finalize();

public:
	//@I`FbN
	bool IsEndRequest() { return endRequest_; }

protected:
	WinApp* winApp = nullptr;
	DirectXCommon* dXCommon = nullptr;
	Input* input = nullptr;
	SpriteCommon spriteCommon;
	GameScene* gameScene = nullptr;
	PostEffect postEffect;
	ParticleManager* particleManager = nullptr;

private:
	// Q[ItO
	bool endRequest_ = false;
};

</file_content>

<file_content path="app/scene/BaseScene.cpp">
#include "BaseScene.h"

//void BaseScene::Initialize()
//{
//	// NXÌ
//	Framework::Initialize();
//
//	dXCommon = DirectXCommon::GetInstance();
//
//	// Q[V[ÌÆ
//	scene_ = new GameScene();
//	scene_->Initialize(spriteCommon);
//}
//
//void BaseScene::Update()
//{
//	// NXÌXV
//	Framework::Update();
//
//	// Q[V[ÌXV
//	scene_->Update();
//
//}
//
//void BaseScene::Draw()
//{
//#pragma region Q[V[`
//
//	//=== Q[V[` ===//
//	scene_->Draw();
//
//#pragma endregion
//
//#pragma region `
//	// `O
//	dXCommon->PreDraw();
//
//	// `ãˆ
//	dXCommon->PostDraw();
//#pragma endregion
//}
//
//void BaseScene::Finalize()
//{
//	// Q[V[Ì‰
//	delete scene_;
//
//	// NXÌI
//	Framework::Finalize();
//}

</file_content>

<file_content path="app/scene/BaseScene.h">
#pragma once

#include "Framework.h"

// Q[S
class BaseScene
{
//public:
//	// 
//	void Initialize() override;
//
//	// XV
//	void Update() override;
//
//	// `
//	void Draw() override;
//
//	// I
//	void Finalize() override;

};

</file_content>

<file_content path="engine/2d/Sprite.cpp">
#include "Sprite.h"

Sprite::Sprite() {

}

Sprite::~Sprite() {

}

PipelineSet Sprite::SpriteCreateGraphicsPipeline(ID3D12Device* device) 
{
	HRESULT result;
	ComPtr<ID3DBlob> vsBlob; // _VF[_IuWFNg
	ComPtr<ID3DBlob> psBlob; // sNZVF[_IuWFNg
	ComPtr<ID3DBlob> errorBlob; // G[IuWFNg

	// _VF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/Shaders/SpriteVS.hlsl", // VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "vs_5_0", // Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&vsBlob, &errorBlob);

	// G[È‚
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// sNZVF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/Shaders/SpritePS.hlsl",   // VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "ps_5_0", // Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&psBlob, &errorBlob);

	// G[È‚
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// _CAEg
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyzW(1sÅÙ‚â‚·)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

		{ // uvW(1sÅÙ‚â‚·)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// fXNv^WÌİ’
	CD3DX12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

	CD3DX12_ROOT_PARAMETER rootParams[2];
	rootParams[0].InitAsConstantBufferView(0);
	rootParams[1].InitAsDescriptorTable(1, &descriptorRange, D3D12_SHADER_VISIBILITY_ALL);

	// eNX`Tv[Ìİ’
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //JÔ‚i^COj
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //cJÔ‚i^COj
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //sJÔ‚i^COj
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK; //{[_[ÌÍ
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; //SÄƒjA
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX; //~bv}bvÅ‘l
	samplerDesc.MinLOD = 0.0f; //~bv}bvÅl
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; //sNZVF[_Ì‚İgpÂ”\

	// OtBbNXpCvCİ’
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	// VF[_[Ìİ’
	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	// Tv}XNÌİ’
	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // Wİ’

	// X^CUÌİ’
	pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;  // JOÈ‚
	//pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // |ShÂ‚Ô‚
	//pipelineDesc.RasterizerState.DepthClipEnable = true; // [xNbsOL

	// _[^[QbgÌƒuhİ’
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; // RBGASÄ‚Ìƒ`l`
	blenddesc.BlendEnable = true;                   // uhLÉ‚
	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;    // Z
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;      // \[XÌ’l100% g
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;    // fXgÌ’l  0% g

	// 
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;             // Z
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;         // \[XÌƒAt@l
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;    // 1.0f-\[XÌƒAt@l

	// _CAEgÌİ’
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// }`ÌŒ`İ’
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// Ì‘Ìİ’
	pipelineDesc.NumRenderTargets = 1; // `ÎÛ‚1
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0`255wRGBA
	pipelineDesc.SampleDesc.Count = 1; // 1sNZÉ‚Â‚1TvO

	// fvXXeVXe[gÌİ’
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS; // Éã‘[
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthEnable = false;

	// [gVOl`Ìİ’
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams; // [gp[^Ìæ“ªAhX
	rootSignatureDesc.NumParameters = _countof(rootParams); // [gp[^
	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// pCvCÆƒ[gVOl`ÌƒZbg
	PipelineSet pipelineSet;

	ComPtr<ID3DBlob> rootSigBlob;
	// o[WÅ‚ÌƒVACY
	result = D3D12SerializeRootSignature(
		&rootSignatureDesc, 
		D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, 
		&errorBlob);
	assert(SUCCEEDED(result));
	// [gVOl`Ì
	result = device->CreateRootSignature(
		0, 
		rootSigBlob->GetBufferPointer(), 
		rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineSet.rootsignature));
	assert(SUCCEEDED(result));

	// pCvCÉƒ[gVOl`Zbg
	pipelineDesc.pRootSignature = pipelineSet.rootsignature.Get();

	// pCvXe[gÌ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineSet.pipelinestate));
	assert(SUCCEEDED(result));

	// fXNv^q[vğ¶	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//VF[_çŒ©æ‚¤
	descHeapDesc.NumDescriptors = 1; // VF[_[\[Xr[1
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap));//
	if (FAILED(result)) {
		assert(0);
	}

	// pCvCÆƒ[gVOl`Ô‚
	return pipelineSet;
}

void Sprite::SpriteCreate(ID3D12Device* dev, int window_width, int window_height, 
	UINT texNumber, Vector2 anchorpoint, bool isFlipX, bool isFlipY) {

	HRESULT result = S_FALSE;

	//_f[^
	VertexPosUv vertices[] = {
		{{	0.0f, 100.0f,	0.0f},{0.0f,1.0f}},
		{{	0.0f,	0.0f,	0.0f},{0.0f,0.0f}},
		{{100.0f, 100.0f,	0.0f},{1.0f,1.0f}},
		{{100.0f,	0.0f,	0.0f},{1.0f,0.0f}},
	};

	UINT sizeVB = static_cast<UINT>(sizeof(VertexPosUv) * _countof(vertices));

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapPropsVertexBuffer = 
		CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDescVertexBuffer =
		CD3DX12_RESOURCE_DESC::Buffer(sizeof(vertices));

	// eNX`ÔRs[
	this->texNumber = texNumber;

	//_obt@
	result = dev->CreateCommittedResource(
		&heapPropsVertexBuffer, // q[vİ’
		D3D12_HEAP_FLAG_NONE,
		&resourceDescVertexBuffer, // \[Xİ’
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	// wÔÌ‰æ‘œÇ‚İİÏ‚İ‚È‚
	if (spriteCommon_.texBuff[this->texNumber]) {
		// eNX`æ“¾
		D3D12_RESOURCE_DESC resDesc = spriteCommon_.texBuff[this->texNumber]->GetDesc();
		// XvCgÌ‘å‚«æ‘œÌ‰ğ‘œ“xÉí‚¹
		scale = { (float)resDesc.Width,(float)resDesc.Height };
		// eNX`æ“¾
	}

	texSize_ = { (float)resDesc.Width, (float)resDesc.Height };

	// AJ[|CgRs[
	this->anchorpoint = anchorpoint;

	// ]tORs[
	this->isFlipX_ = isFlipX;
	this->isFlipY_ = isFlipY;

	//_obt@Ö‚Ìƒf[^]
	VertexPosUv* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	vertBuff->Unmap(0, nullptr);

	// _obt@r[Ìì¬
	// GPUzAhX
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	// _obt@ÌƒTCY
	vbView.SizeInBytes = sizeof(vertices);
	// _1Â•Ìƒf[^TCY
	vbView.StrideInBytes = sizeof(vertices[0]);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapPropsConstantBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDescConstantBuffer =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB0) + 0xff) & ~0xff);

	// è”obt@Ì
	result = dev->CreateCommittedResource(
		&heapPropsConstantBuffer, // q[vİ’
		D3D12_HEAP_FLAG_NONE,
		&resourceDescConstantBuffer, // \[Xİ’
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB0));
	assert(SUCCEEDED(result));

	// è”obt@Éƒf[^]
	result = constBuffB0->Map(0, nullptr, (void**)&constMap); // }bsO
	assert(SUCCEEDED(result));

	constMap->color = color_;

	// PÊs
	constMap->mat.identity();

	// WÏŠ
	constMap->mat.m[0][0] = 2.0f / WinApp::window_width;
	constMap->mat.m[1][1] = -2.0f / WinApp::window_height;
	constMap->mat.m[3][0] = -1.0f;
	constMap->mat.m[3][1] = 1.0f;
}

void Sprite::PreDraw(ID3D12GraphicsCommandList* cmdList, const SpriteCommon& spriteCommon) {

	// pCvCXe[gÆƒ[gVOl`Ìİ’
	cmdList->SetPipelineState(spriteCommon.pipelineSet.pipelinestate.Get());
	cmdList->SetGraphicsRootSignature(spriteCommon.pipelineSet.rootsignature.Get());

	// v~eBu`Ìİ’
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); // Op`Xg

	//eNX`pÅƒXNv^q[vÌİ’
	ID3D12DescriptorHeap* ppHeaps[] = { spriteCommon.descHeap.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
}

void Sprite::PostDraw()
{
}

void Sprite::SpriteDraw(ID3D12GraphicsCommandList* cmdList_, const SpriteCommon& spriteCommon, 
	ID3D12Device* dev) 
{
	// \tOtrueÈ‚
	if (isInvisible) {
		// `æ‚¹É”
		return;
	}

	this->cmdList = cmdList_;

	// _obt@Zbg
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	// è”obt@(CBV)Zbg
	cmdList->SetGraphicsRootConstantBufferView(0, constBuffB0->GetGPUVirtualAddress());

	//VF[_[\[Xr[Zbg
	cmdList->SetGraphicsRootDescriptorTable(
		1, CD3DX12_GPU_DESCRIPTOR_HANDLE(
			spriteCommon.descHeap->GetGPUDescriptorHandleForHeapStart(),
			texNumber, 
			dev->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)));

	//|SÌ•`(4_Ålp`)
	cmdList->DrawInstanced(4, 1, 0, 0);
}

SpriteCommon Sprite::SpriteCommonCreate(ID3D12Device* dev) 
{
	HRESULT result = S_FALSE;

	// VÈƒXvCgÊƒf[^ğ¶
	SpriteCommon spriteCommon{};

	// XvCgppCvC
	spriteCommon.pipelineSet = SpriteCreateGraphicsPipeline(dev);

	spriteCommon.matProjection = Matrix4::identity();

	// WÏŠ
	spriteCommon.matProjection.m[0][0] = 2.0f / WinApp::window_width;
	spriteCommon.matProjection.m[1][1] = -2.0f / WinApp::window_height;
	spriteCommon.matProjection.m[3][0] = -1.0f;
	spriteCommon.matProjection.m[3][1] = 1.0f;

	// fXNv^q[vğ¶
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	descHeapDesc.NumDescriptors = SpriteCommon::kMaxSRVCount;
	result = dev->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&spriteCommon.descHeap));

	// XvCgÔ‚
	return spriteCommon;
}

void Sprite::SpriteUpdate(Sprite& sprite, const SpriteCommon& spriteCommon) 
{
	// sÌİ’
	Matrix4 matRot;
	Matrix4 matTrans;
	Matrix4 matRotX, matRotY, matRotZ;

	//esvZ
	matRot = Matrix4::identity();
	matRot *= matRotZ.rotateZ(rotation * 180.0f / 3.1415f);
	matRot *= matRotX.rotateX(rotation_.x * 180.0f / 3.1415f);
	matRot *= matRotY.rotateY(rotation_.y * 180.0f / 3.1415f);
	matTrans = Matrix4::identity();
	matTrans.translate(position);

	// [hsÌXV
	Matrix4 mat;
	sprite.matWorld = mat.identity();
	// Z]
	sprite.matWorld *= matRot;
	// sÚ“
	sprite.matWorld *= matTrans;

	// è”obt@Ì“]
	HRESULT result = sprite.constBuffB0->Map(0, nullptr, (void**)&constMap);
	constMap->mat = sprite.matWorld * spriteCommon.matProjection;
	sprite.constBuffB0->Unmap(0, nullptr);
}

void Sprite::LoadTexture(SpriteCommon& spriteCommon, UINT texnumber, const wchar_t* filename, ID3D12Device* dev) {

	assert(texnumber <= SpriteCommon::kMaxSRVCount - 1);

	HRESULT result;
	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// WICeNX`Ìƒ[h
	result = LoadFromWICFile(filename, WIC_FLAGS_NONE, &metadata, scratchImg);
	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	// ~bv}bv
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// Ç‚İñ‚¾ƒfBt[YeNX`SRGBÆ‚Äˆ
	metadata.format = MakeSRGB(metadata.format);

	// \[Xİ’
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// eNX`pobt@Ì
	result = dev->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // eNX`pw
		nullptr, IID_PPV_ARGS(&spriteCommon.texBuff[texnumber]));
	assert(SUCCEEDED(result));

	// eNX`obt@Éƒf[^]
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // f[^o
		result = spriteCommon.texBuff[texnumber]->WriteToSubresource(
			(UINT)i,
			nullptr, // SÌˆÖƒRs[
			img->pixels, // f[^AhX
			(UINT)img->rowPitch, // 1CTCY
			(UINT)img->slicePitch // 1TCY
		);
		assert(SUCCEEDED(result));
	}

	// VF[_\[Xr[ì¬
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // İ’\
	D3D12_RESOURCE_DESC resDesc = spriteCommon.texBuff[texnumber]->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;// 2DeNX`
	srvDesc.Texture2D.MipLevels = 1;

	dev->CreateShaderResourceView(spriteCommon.texBuff[texnumber].Get(), // r[ÆŠÖ˜Atobt@
		&srvDesc, // eNX`İ’
		CD3DX12_CPU_DESCRIPTOR_HANDLE(spriteCommon.descHeap->GetCPUDescriptorHandleForHeapStart(), 
		texnumber, 
		dev->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV))
	);
}

void Sprite::SpriteTransferVertexBuffer(const Sprite& sprite, uint32_t texIndex)
{
	HRESULT result = S_FALSE;

	this->texIndex_ = texIndex;

	// _f[^
	VertexPosUv vertices[] = {
		//    u    v
		{{},{0.0f,1.0f}}, // 
		{{},{0.0f,0.0f}}, // 
		{{},{1.0f,1.0f}}, // E
		{{},{1.0f,0.0f}}, // E
	};

	//  AAEAE
	enum { LB, LT, RB, RT };

	// Eã‰º[ÌWvZ
	float left = (0.0f - anchorpoint.x) * scale.x;
	float right = (1.0f - anchorpoint.x) * scale.x;
	float top = (0.0f - anchorpoint.y) * scale.y;
	float bottom = (1.0f - anchorpoint.y) * scale.y;

	if (isFlipX_ = false) 
	{// EÖ‚
		left = -left;
		right = -right;
	}

	if (isFlipY_ = false)
	{// EÖ‚
		top = -top;
		bottom = -bottom;
	}

	// _f[^zÉWZbg
	vertices[LB].pos = { left,  bottom, 0.0f }; // 
	vertices[LT].pos = { left,     top, 0.0f }; // 
	vertices[RB].pos = { right, bottom, 0.0f }; // E
	vertices[RT].pos = { right,    top, 0.0f }; // E

	// UVvZ
	// wÔÌ‰æ‘œÇ‚İİÏ‚İ‚È‚
	if (spriteCommon_.texBuff[sprite.texIndex_]) {
		// eNX`æ“¾
		resDesc = spriteCommon_.texBuff[sprite.texIndex_]->GetDesc();

		float tex_left = sprite.texLeftTop_.x / resDesc.Width;
		float tex_right = (sprite.texLeftTop_.x + sprite.texSize_.x) / resDesc.Width;
		float tex_top = sprite.texLeftTop_.y / resDesc.Height;
		float tex_bottom = (sprite.texLeftTop_.y + sprite.texSize_.y) / resDesc.Height;

		vertices[LB].uv = { tex_left,  tex_bottom }; // 
		vertices[LT].uv = { tex_left,     tex_top }; // 
		vertices[RB].uv = { tex_right, tex_bottom }; // Ez
		vertices[RT].uv = { tex_right,    tex_top }; // E
	}

	// _obt@Ö‚Ìƒf[^]
	VertexPosUv* vertMap = nullptr;
	result = sprite.vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	sprite.vertBuff->Unmap(0, nullptr);
}

void Sprite::Finalize()
{
	//delete dXCommon;
}

void Sprite::SetAlpha(Sprite sprite,float alpha_) {

	// è”obt@Ì“]
	HRESULT result = sprite.constBuffB0->Map(0, nullptr, (void**)&constMap);
	constMap->color.w = alpha_;
	sprite.constBuffB0->Unmap(0, nullptr);
	assert(SUCCEEDED(result));
}

</file_content>

<file_content path="engine/2d/Sprite.h">
#pragma once

#include <Windows.h>
#include <D3dx12.h>
#include <DirectXMath.h>
#include <d3dcompiler.h>
#include <cassert>
#pragma warning(push)
#pragma	warning(disable:26813)
#include <DirectXTex.h>
#pragma warning(pop)
#include <wrl.h>
#include <array>
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include"Matrix4.h"

#include "DirectXCommon.h"

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;



// pCvCZbg
struct PipelineSet {
	// pCvCXe[gIuWFNg
	ComPtr<ID3D12PipelineState> pipelinestate;
	// [gVOl`
	ComPtr<ID3D12RootSignature> rootsignature;
};

// XvCgÌ‹Êƒf[^
struct SpriteCommon {
	// pCvCZbg
	PipelineSet pipelineSet;
	// Ë‰es
	Matrix4 matProjection{};
	// eNX`pfXNv^q[vÌ
	ComPtr<ID3D12DescriptorHeap> descHeap;
	// SRVÌÅ‘å–‡
	static const size_t kMaxSRVCount = 512;
	// eNX`\[X(eNX`obt@)Ì”z
	ComPtr<ID3D12Resource> texBuff[kMaxSRVCount];
	// eNX`obt@æ“¾
	ID3D12Resource* GetTexBuffer(uint32_t index) const { return texBuff[index].Get(); }
};

// XvCg
class Sprite
{
public://TuNX
	// è”obt@pf[^\B0
	struct ConstBufferDataB0
	{
		Vector4 color;
		Matrix4 mat;	// RcÏŠs
	};

	// _f[^
	struct VertexPosUv {
		Vector3 pos;
		Vector2 uv;
	};
public:
	Sprite();
	~Sprite();

	/// XvCgÊƒf[^
	SpriteCommon SpriteCommonCreate(ID3D12Device* dev);

	/// 3DIuWFNgppCvC
	PipelineSet SpriteCreateGraphicsPipeline(ID3D12Device* device);

	/// XvCgÊƒeNX`Ç‚İ
	void LoadTexture(SpriteCommon& spriteCommon, UINT texnumber, 
		const wchar_t* filename, ID3D12Device* dev);

	/// XvCg
	void SpriteCreate(ID3D12Device* dev, int window_width, int window_height, 
		UINT texNumber, Vector2 anchorpoint, bool isFlipX, bool FlipY);

	/// XvCgPÌ’_obt@Ì“]
	void SpriteTransferVertexBuffer(const Sprite& sprite, uint32_t texIndex_ = UINT32_MAX);

	/// XvCgPÌXV
	void SpriteUpdate(Sprite& sprite, const SpriteCommon& spriteCommon);

	/// `O
	static void PreDraw(ID3D12GraphicsCommandList* cmdList, const SpriteCommon& spriteCommon);

	/// `ãˆ
	static void PostDraw();

	/// XvCgPÌ•`
	void SpriteDraw(ID3D12GraphicsCommandList* cmdList_, const SpriteCommon& spriteCommon, 
		ID3D12Device* dev);

	/// I
	void Finalize();

public: // Zb^[
	// Wİ’
	void SetPosition(Vector3 position) { this->position = position; }
	// TCYİ’
	void SetScale(Vector2 scale) { this->scale = scale; }
	// ]
	void SetRotation(float rotation) { this->rotation = rotation; }
	// Ô
	void SetTexNumber(UINT texNumber) { this->texNumber = texNumber; }
	// F
	void SetColor(const Vector4& color) { this->color_ = color; }
	void SetAlpha(Sprite sprite, float alpha_);
	// tbv
	void SetIsFlipX(bool isFlipX) { this->isFlipX_ = isFlipX; } // X
	void SetIsFlipY(bool isFlipY) { this->isFlipY_ = isFlipY; } // Y
	// eNX`W
	void SetTexLeftTop(const Vector2& texLeftTop) { this->texLeftTop_ = texLeftTop; }
	// eNX`Ø‚oTCY
	void SetTexSize(const Vector2& texSize) { this->texSize_ = texSize; }

public: // Qb^[
	// W
	Vector3 GetPosition() const { return position; }
	// TCY
	Vector2 GetScale() const { return scale; }
	//[hs
	Matrix4 GetMat() { return constMap->mat; }
	// ]
	float GetRotation() const { return rotation; }
	// Ô
	UINT GetTexNumber() const { return texNumber; }
	// F
	Vector4 GetColor() const { return color_; }
	// tbv
	bool GetIsFlipX() const { return isFlipX_; } // X
	bool GetIsFlipY() const { return isFlipY_; } // Y
	// eNX`W
	Vector2 GetTexLeftTop() const { return texLeftTop_; }
	// eNX`Ø‚oTCY
	Vector2 GetTexSize() const { return texSize_; }

public:
	//_obt@
	ComPtr<ID3D12Resource> vertBuff;
	//_obt@r[
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	D3D12_RESOURCE_DESC resDesc;

private:
	// DirectXCommonÌƒCX^X
	DirectXCommon* dXCommon = nullptr;
	SpriteCommon spriteCommon_;

	ComPtr<ID3D12GraphicsCommandList> cmdList;
	ComPtr<ID3D12DescriptorHeap> descHeap;
	//è”obt@
	ComPtr<ID3D12Resource> constBuffB0 = nullptr;
	// }bsOÏ‚İƒAhX
	ConstBufferDataB0* constMap = nullptr;
	D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
	static const size_t kMaxSRVCount = 2056;
	// eNX`obt@
	std::array<ComPtr<ID3D12Resource>, kMaxSRVCount> texBuffers_;

	// eNX`Ô
	UINT texNumber = 0;
	uint32_t texIndex_ = 0;
	// W
	Vector3 position = { 0.0f, 0.0f, 0.0f };
	// TCY
	Vector2 scale = { 1.0f, 1.0f };
	// ]
	Vector3 rotation_ = { 0.0f,0.0f,0.0f };
	// [hs
	Matrix4 matWorld;
	// AJ[|Cg
	Vector2 anchorpoint = { 0.0f,0.0f };
	// eNX`Wİ’
	Vector2 texLeftTop_ = { 50.0f, 50.0f };
	// eNX`Ø‚oTCY
	Vector2 texSize_ = { 100.0f, 100.0f };
	// F
	Vector4 color_ = { 1,1,1,1 };

	// ZÌ‰]
	float rotation = 0.0f;
	// E]
	bool isFlipX_ = false;
	// ã‰º]
	bool isFlipY_ = false;
	// \
	bool isInvisible = false;
};


</file_content>

<file_content path="engine/3d/Boss.cpp">
#include "Boss.h"
#include "SphereCollider.h"
#include "time.h"
#include "stdlib.h"
#include "GameScene.h"

Boss::~Boss()
{
	delete bossModel;
}

void Boss::BossInitialize()
{
	Initialize();
	// OBJçƒ‚ff[^Ç‚İ
	bossModel = Model::LoadFromOBJ("fighter");
	// 3DIuWFNg
	Create();
	// IuWFNgÉƒfĞ‚t
	SetModel(bossModel);
	SetPosition({ -75,65,-200 });
	SetScale({ 10,10,10 });
	//p[cÌ
	for (int i = 0; i < PARTS_NUM; i++) {
		parts[i] = Create();
		parts[i]->worldTransform_.SetParent3d(&worldTransform_);
		parts[i]->SetCollider(new SphereCollider());
	}
	parts[0]->SetPosition({ -2.0f,0.0f,-0.5f });
	parts[1]->SetPosition({ 2.0f,0.0f,-0.5f });
	parts[2]->SetPosition({ 0.0f,0.0f,1.0f });
	parts[3]->SetPosition({ -3.0f,0.0f,-1.0f });
	parts[4]->SetPosition({ 3.0f,0.0f,-1.0f });

	isDead_ = false;
	isInvisible = true;
	//^C}[
	appearTimer = 0;
	bossAlpha = 0.0f;
	hp = 300;
	isHit = false;
	hitTimer = 0;
	timer = 0;
	timeCount = 0;
	state = WAIT;
	//
	srand((unsigned int)time(NULL));
}

void Boss::Update(Vector3 velo)
{
	//oê
	if (appearTimer > 0) {
		if (appearTimer > 150) {
			SetPosition(GetPosition() + Vector3(0.5f, -0.1f, 0));
		}
		if (appearTimer > 100) {
			bossAlpha += 0.02f;
		}
		appearTimer--;
	}
	//{
	Move();
	ChangeState();

	//eÈ‚XV
	for (std::unique_ptr<BossBullet>& bullet : bullets_) {
		bullet->Update(velo);
	}
	//fXtOÌ—Gíœ
	bullets_.remove_if([](std::unique_ptr <BossBullet>& bullets_) {
		return bullets_->IsDead();
		});
	
	 //_[W
	if (hitTimer > 0) {
		hitTimer--;
		if (hitTimer == 0) {
			isHit = false;
		}
	}
	//HP0È‚ç€S
	if (hp <= 0) {
		isDead_ = true;
	}
	//XV
	worldTransform_.UpdateMatrix();
	//è”»XV
	if (collider)
	{
		collider->Update();
	}
	//{Xp[cAbvf[g
	for (int i = 0; i < PARTS_NUM; i++) {
		parts[i]->Update();
	}
	//JEgZbg
	if (timeCount == 4) {
		timeCount = 0;
	}
}

void Boss::Pop()
{
	if (isInvisible == true) {
		isInvisible = false;
	}
	appearTimer = 300;
}

void Boss::Attack()
{
	//eğ¶
	std::unique_ptr<BossBullet> newBullet = std::make_unique<BossBullet>();

	//P													   
	newBullet->BulletInitialize(GetPosition());
	newBullet->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 5.0f));

	//eÌ“o^										 
   //
	newBullet->SetPosition(GetPosition());
	newBullet->SetScale({ 1.2f,1.2f,1.2f });
	bullets_.push_back(std::move(newBullet));
}

void Boss::Move()
{
	//{Xo
	if (isInvisible == false) {
		if (timer < 75) {
			SetPosition(GetPosition() + Vector3(0.0f, 0.01f, 0.0f));
		}
		else if (timer < 150) {
			SetPosition(GetPosition() + Vector3(0.0f, -0.01f, 0.0f));
		}
		else {
			timer = 0;
			timeCount++;
		}
		timer++;
	}
}

void Boss::ChangeState()
{
	//Ò‹@
	if (state == WAIT) {
		if (timeCount == 4) {
			//É‚s
			int random = rand() % 1 + 1;
			//Iê‚½s
			state = (State)random;
		}						 
	}
	//ËŒ
	else if (state == SHOT) {
		Attack();
		state = WAIT;
	}
}

void Boss::BossDraw(ViewProjection* viewProjection_)
{
	Draw(viewProjection_, bossAlpha);
	//e`
	for (std::unique_ptr<BossBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}

void Boss::OnCollision(const CollisionInfo& info)
{
	//Õ“Ë‘Ì–O
	const char* str1 = "class PlayerBullet";

	//è‚ªplayerÌ’e
	if (strcmp(toCollisionName, str1) == 0) {
		if (isHit == false && isInvisible == false) {
			isHit = true;
			hitTimer = 30;
			hp-= 5;
			for (int i = 0; i < PARTS_NUM; i++) {
				if (parts[i]->GetIsLocked() == true) {
					parts[i]->SetIsLocked(false);
					GameScene::PopEnergy(parts[i]->GetWorldPos());
					hp -= 5;
				}
			}
		}
	}
}

void Boss::SkipMovie()
{
	appearTimer = 0;
	SetPosition({ 0.0f,49.99f,-200.0f });
	bossAlpha = 1.0f;
}

</file_content>

<file_content path="engine/3d/Boss.h">
#pragma once
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include "BossBullet.h"

//GameSceneÌ‘OéŒ¾
class GameScene;

class Boss : public Object3d
{
public:
	//fXgN^
	~Boss();
	//
	void BossInitialize();

	void Update(Vector3 velo);
	void Pop();
	void Attack();
	void Move();
	void ChangeState();
	
	void BossDraw(ViewProjection* viewProjection_);

	bool GetIsDead() const { return isDead_; }
	//è”»
	void OnCollision(const CollisionInfo& info) override;
	//Getter
	bool GetIsInvisible() { return isInvisible; }
	float GetAlpha() { return bossAlpha; }
	int GetTimer() { return appearTimer; }
	float GetHP() { return hp; }
	int GetPartsNum() { return PARTS_NUM; }
	Object3d* GetParts(int i) { return parts[i]; }
	//oXLbv
	void SkipMovie();

	

private:

	//fXtO
	bool isDead_ = false;
	bool isInvisible = true;
	//^C}[
	int appearTimer = 0;
	float bossAlpha = 0.0f;
	float hp;
	bool isHit;
	int hitTimer;
	int timeCount;
	int timer;
	
	//{Xs
	enum State {
		WAIT,
		SHOT
	};
	State state;

	// f
	Model* bossModel = nullptr;
	//e
	std::list<std::unique_ptr<BossBullet>> bullets_;
	static const int PARTS_NUM = 5;
	Object3d* parts[PARTS_NUM];
};

</file_content>

<file_content path="engine/3d/BossBullet.cpp">
#include "BossBullet.h"
#include "BaseCollider.h"

void BossBullet::BulletInitialize(const Vector3& position)
{
	Initialize();

	// OBJçƒ‚ff[^Ç‚İ
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	bulletModel->LoadTexture("Resources/blue.png");
	// 3DIuWFNg
	Create();
	// IuWFNgÉƒfĞ‚t
	SetModel(bulletModel);

	//Ì—Íw
	hp = 2;
	hitTime = 0;
	isHit = false;
}

void BossBullet::Update(const Vector3& playerPos_)
{
	//Ú“xNgvZ
	velocity = playerPos_ - GetPosition();
	velocity.normalize();
	//WZ
	SetPosition(GetPosition() + velocity);
	//XV
	worldTransform_.UpdateMatrix();

	//è”»XV
	if (collider)
	{
		collider->Update();
	}
	//qbgN[^C
	if (hitTime > 0) {
		hitTime--;
		if (isHit == false) {
			isHit = true;
			bulletModel->LoadTexture("Resources/red.png");
		}
	}
	else {
		if (isHit == true) {
			isHit = false;
			bulletModel->LoadTexture("Resources/blue.png");
		}
	}
	//ÔŒoß‚ÅƒfX
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}
}

void BossBullet::OnCollision(const CollisionInfo& info)
{
	//Õ“Ë‘Ì–O
	const char* str1 = "class Player";
	const char* str2 = "class PlayerBullet";

	//è‚ªplayer
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
	//è‚ªplayerÌ’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (hitTime == 0) {
			if (hp == 2) {
				hp--;
			}
			else {
				isDead_ = true;
				hitTime = 10;
			}
		}
	}
}

</file_content>

<file_content path="engine/3d/BossBullet.h">
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class BossBullet : public Object3d
{
public:
	///< summary>
	///
	///</summary>
	void BulletInitialize(const Vector3& position);

	///< summary>
	///
	///</summary>
	void Update(const Vector3& playerPos_);


	//Õ“Ë‚oÄ‚ÑoR[obNÖ
	void OnCollision(const CollisionInfo& info) override;


public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }

private:
	//f
	Model* bulletModel = nullptr;

	//x
	Vector3 playerPos;
	Vector3 velocity;

	//
	static const int32_t kLifeTime = 60 * 3;
	//fX^C}[
	int32_t deathTimer_ = kLifeTime;
	//fXtO
	int hp;
	int hitTime;
	bool isHit;
	bool isDead_ = false;

};

</file_content>

<file_content path="engine/3d/Enemy.cpp">
#include "Enemy.h"
#include "string.h"
#include "BaseCollider.h"
#include "SphereCollider.h"
#include "GameScene.h"

//fXgN^
Enemy::~Enemy() {
	delete enemyModel;
}

//
void Enemy::EnemyInitialize()
{
	Initialize();
	// OBJçƒ‚ff[^Ç‚İ
	enemyModel = Model::LoadFromOBJ("triangle_mat");
	enemyModel->LoadTexture("Resources/red.png");
	// 3DIuWFNg
	Create();
	// IuWFNgÉƒfĞ‚t
	SetModel(enemyModel);
	isDead_ = false;
	isInvisible = true;
	timer = 0;
	isAttack = false;
	timeCount = 0;
	alpha = 0;
}

void Enemy::Update(Vector3 velo,float t) {
	//Ô‚È‚
	if (isInvisible == true) {
		float len = stagePoint - t + 1.0f;
 		if (len < 4.0f) {
			isInvisible = false;
		}
	}
	else {
		if (alpha < 1) {
			alpha += 0.05f;
		}
		float moveX;
		if (timeCount == 0) {
			moveX = -0.05f;
		}
		else if (timeCount == 1) {
			moveX = 0.05f;
		}
		else if (timeCount == 2) {
			moveX = 0.05f;
		}
		else {
			moveX = -0.05f;
		}

		if (timer < 75) {
			SetPosition(GetPosition() + Vector3(moveX, 0.005f, 0));
		}
		else if (timer < 150) {
			SetPosition(GetPosition() + Vector3(moveX, -0.005f, 0));
		}
		else {
			timer = 0;
			if (timeCount == 4) {
				timeCount = 0;
			}
			else {
				timeCount++;
			}
		}
		//playerGÇ‚zUÈ‚
		if (stagePoint < t + 1.0f) {
			if (isAttack == true) {
				isAttack = false;
			}
		}
		//U
		if (isAttack == false) {
			Vector3 playerVec = velo - GetPosition();
			float len = playerVec.length();
			if (len < 70.0f) {
				isAttack = true;
			}
		}
		else {
			Attack();
		}

		for (std::unique_ptr<EnemyBullet>& bullet : bullets_) {
			bullet->Update(velo);
		}
		//fXtOÌ—Gíœ
		bullets_.remove_if([](std::unique_ptr <EnemyBullet>& bullets_) {
			return bullets_->IsDead();
			});
		//è”»XV
		if (collider)
		{
			collider->Update();
		}
		worldTransform_.UpdateMatrix();
		timer++;
	}
}

void Enemy::OnCollision(const CollisionInfo& info)
{
	//Õ“Ë‘Ì–O
	const char* str1 = "class PlayerBullet";

	//è‚ªplayerÌ’e
	if (strcmp(toCollisionName, str1) == 0) {
		if (isInvisible == false) {
			if (isDead_ == false) {
				isDead_ = true;
				for (int i = 0; i < 3; i++) {
					GameScene::PopEnergy(GetPosition());
				}
			}
		}
	}
}

void Enemy::Attack() {

		if (coolTime == 0) {
			//eğ¶
		//
			std::unique_ptr<EnemyBullet> newBullet = std::make_unique<EnemyBullet>();

			//P													   
			newBullet->BulletInitialize(GetPosition());
			newBullet->SetCollider(new SphereCollider(Vector3{0,0,0},0.5f));

			//eÌ“o^										 
		   //
			newBullet->SetPosition(GetPosition());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			bullets_.push_back(std::move(newBullet));


			//N[^Cİ’
			coolTime = 200;
		}
		else if (coolTime > 0) {
			coolTime--;
		}

}

void Enemy::EnemyDraw(ViewProjection* viewProjection_) {
	Draw(viewProjection_, alpha);
	//e`
	for (std::unique_ptr<EnemyBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}
</file_content>

<file_content path="engine/3d/Enemy.h">
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include <list>
#include "EnemyBullet.h"

//GameSceneÌ‘OéŒ¾
class GameScene;

class Enemy : public Object3d
{
public:
	//fXgN^
	~Enemy();
	//
	void EnemyInitialize();


	bool GetIsDead() const { return isDead_; }
	
	void Update(Vector3 velo,float t);
	void EnemyDraw(ViewProjection* viewProjection_);

	void Attack();

	void OnCollision(const CollisionInfo& info) override;
	void SetStagePoint(float pos_) { stagePoint = pos_; }
	float GetStagePoint(){return stagePoint;}
	Object3d* GetPointer() { return this; }
	bool GetIsInvisible() { return isInvisible; }

	//eXgæ“¾
	const std::list<std::unique_ptr<EnemyBullet>>& GetBullets() { return bullets_; }

private:

	//fXtO
	bool isDead_ = false;
	//
	bool isInvisible = true;

	//G
	std::list<std::unique_ptr<EnemyBullet>> bullets_;

	// f
	Model* enemyModel = nullptr;
	float alpha;

	//a
	int timer;
	float radius = 1.0f;
	int coolTime = 0;
	float stagePoint;

	bool isAttack;
	int timeCount;
};

</file_content>

<file_content path="engine/3d/EnemyBullet.cpp">
#include "EnemyBullet.h"
#include "BaseCollider.h"

void EnemyBullet::BulletInitialize(const Vector3& position) {

	Initialize();

	// OBJçƒ‚ff[^Ç‚İ
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	// 3DIuWFNg
	Create();
	// IuWFNgÉƒfĞ‚t
	SetModel(bulletModel);

	//Åó‚¯xoÏÉ‘
	bulletTime = 0;
}

void EnemyBullet::Update(const Vector3& playerPos_) {

	if (bulletTime < 40) {
		velocity = (playerPos_ - GetPosition()) * 0.05f;
		bulletTime++;
	}

	SetPosition(GetPosition() + velocity);

	worldTransform_.UpdateMatrix();

	//è”»XV
	if (collider)
	{
		collider->Update();
	}
	//ÔŒoß‚ÅƒfX
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}
}

void EnemyBullet::OnCollision(const CollisionInfo& info)
{
	//Õ“Ë‘Ì–O
	const char* str1 = "class Player";
	const char* str2 = "class PlayerBullet";

	//è‚ªplayer
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
	//è‚ªplayerÌ’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
}

</file_content>

<file_content path="engine/3d/EnemyBullet.h">
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class EnemyBullet : public Object3d
{
public:
	///< summary>
	///
	///</summary>
	void BulletInitialize(const Vector3& position);

	///< summary>
	///
	///</summary>
	void Update(const Vector3& playerPos_);


	//Õ“Ë‚oÄ‚ÑoR[obNÖ
	void OnCollision(const CollisionInfo& info) override;


public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }

private:
	//f
	Model* bulletModel = nullptr;

	//x
	Vector3 playerPos;
	Vector3 velocity;

	//
	static const int32_t kLifeTime = 60 * 3;
	//fX^C}[
	int32_t deathTimer_ = kLifeTime;
	int bulletTime;
	//fXtO
	bool isDead_ = false;

};

</file_content>

<file_content path="engine/3d/Energy.cpp">
#include "Energy.h"
#include "string.h"
#include "BaseCollider.h"
#include "SphereCollider.h"

void Energy::EnergyInitialize()
{
	Initialize();
	// OBJçƒ‚ff[^Ç‚İ
	energyModel = Model::LoadFromOBJ("panel");
	// 3DIuWFNg
	Create();
	// IuWFNgÉƒfĞ‚t
	SetModel(energyModel);
	SetScale(Vector3(0.5f, 0.5f, 0.5f));
	isDead = false;
}

void Energy::Update(Vector3 pos,Vector3 rot)
{
	//playerÌ‚Æ‚
	Vector3 velo = pos - GetPosition();
	velo = velo.normalize();
	SetPosition(GetPosition() + velo);
	SetRotation(rot + Vector3(0,90,0));

	worldTransform_.UpdateMatrix();

	//è”»XV
	if (collider)
	{
		collider->Update();
	}
}

void Energy::OnCollision(const CollisionInfo& info)
{
	//Õ“Ë‘Ì–O
	const char* str1 = "class Player";

	//è‚ªplayerÌ’e
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead == false) {
			isDead = true;
		}
	}
}

</file_content>

<file_content path="engine/3d/Energy.h">
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include <list>

//GameSceneÌ‘OéŒ¾
class GameScene;

class Energy : public Object3d
{
public:

	void EnergyInitialize();
	
	void Update(Vector3 pos, Vector3 rot);

	void OnCollision(const CollisionInfo& info) override;

	bool GetIsDead() const { return isDead; }

private:
	// f
	Model* energyModel = nullptr;
	
	bool isDead;
};

</file_content>

<file_content path="engine/3d/FbxLoader.cpp">
#include "FbxLoader.h"
#include <cassert>
#include "Vector3.h"
#include "DirectXMath.h"

//Ã“IÏÌ
const std::string FbxLoader::baseDirectory =
"Resources/";
const std::string FbxLoader::defaultTextureFileName =
"white1x1.png";

//CX^Xæ“¾
FbxLoader* FbxLoader::GetInstance() {
	static FbxLoader instance;
	return &instance;
}

//
void FbxLoader::Initialize(ID3D12Device* device) {

	//Ä`FbN
	assert(fbxManager == nullptr);
	//çƒoÏÉ‘
	this->device = device;
	//FBX}l[W[Ì
	fbxManager = FbxManager::Create();
	//FBX}l[W[Ì“oÍİ’
	FbxIOSettings* ios = FbxIOSettings::Create(fbxManager, IOSROOT);
	fbxManager->SetIOSettings(ios);
	//FBXC|[^[Ì
	fbxImporter = FbxImporter::Create(fbxManager, "");
}

//fÇ‚İ
FbxModel* FbxLoader::LoadModelFlomFile(const string& modelName) {
	const string directoryPath = baseDirectory + modelName + "/";
	const string fileName = modelName + ".fbx";
	//A
	const string fullPath = directoryPath + fileName;

	//t@Cwè‚µÄ“Ç‚İ
	if (!fbxImporter->Initialize(fullPath.c_str(), -1, fbxManager->GetIOSettings())) {
		assert(0);
	}
	FbxScene* fbxScene = FbxScene::Create(fbxManager, "fbxScene");

	//t@CV[ÉƒC|[g
	fbxImporter->Import(fbxScene);

	//f
	FbxModel* model = new FbxModel();
	model->name = modelName;
	//m[hæ“¾
	int nodeCount = fbxScene->GetNodeCount();

	model->nodes.reserve(nodeCount);

	ParseNodeRecursive(model, fbxScene->GetRootNode());
	model->fbxScene = fbxScene;

	//obt@
	model->CreateBuffers(device);
	assert(model->indices.size());

	return model;
}

//m[h
void FbxLoader::ParseNodeRecursive(FbxModel* model, FbxNode* fbxNode, Node* parent) {

	model->nodes.emplace_back();
	Node& node = model->nodes.back();
	//m[hæ“¾
	node.name = fbxNode->GetName();

	//fbxm[hÌƒ[JÚ“
	FbxDouble3 rotation = fbxNode->LclRotation.Get();
	FbxDouble3 scaling = fbxNode->LclScaling.Get();
	FbxDouble3 translation = fbxNode->LclTranslation.Get();

	//`ÏŠÄ‘
	node.rotation = { (float)rotation[0],(float)rotation[1],(float)rotation[2],0.0f };
	node.scaling = { (float)scaling[0],(float)scaling[1],(float)scaling[2],0.0f };
	node.translation = { (float)translation[0],(float)translation[1],(float)translation[2],1.0f };

	//]pDegreeçƒ‰WAÉ•ÏŠ
	node.rotation.x = Matrix4::ConvertToRadian(node.rotation.x);
	node.rotation.y = Matrix4::ConvertToRadian(node.rotation.y);
	node.rotation.z = Matrix4::ConvertToRadian(node.rotation.z);

	//psÌŒvZ
	Matrix4 matScaling, matRotation, matTranslation;
	Matrix4 matRotX, matRotY, matRotZ;
	Vector3 scl = { node.scaling.x,node.scaling.y ,node.scaling.z };
	matScaling = Matrix4::identity();
	matScaling.scale(scl);
	matRotation = Matrix4::identity();
	matRotation *= matRotZ.rotateZ(Matrix4::ConvertToRadian(node.rotation.z));
	matRotation *= matRotX.rotateX(Matrix4::ConvertToRadian(node.rotation.x));
	matRotation *= matRotY.rotateY(Matrix4::ConvertToRadian(node.rotation.y));
	Vector3 trl = { node.translation.x,node.translation.y,node.translation.z };
	matTranslation = Matrix4::identity();
	matTranslation.translate(trl);

	//[JÏŠsÌŒvZ
	node.tranform = Matrix4::identity();
	node.tranform *= matScaling;
	node.tranform *= matRotation;
	node.tranform *= matTranslation;

	//O[oÏŒ`sÌŒvZ
	node.globalTransform = node.tranform;
	if (parent) {
		node.parent = parent;
		//eÌ•ÏŒ`Z
		node.globalTransform *= parent->globalTransform;
	}

	//bV
	FbxNodeAttribute* fbxNodeAttribute = fbxNode->GetNodeAttribute();

	if (fbxNodeAttribute) {
		if (fbxNodeAttribute->GetAttributeType() == FbxNodeAttribute::eMesh) {
			model->meshNode = &node;
			ParseMesh(model, fbxNode);
		}
	}

	//qm[hÉ‘Î‚ÄÄ‹NÄ‚Ño
	for (int i = 0; i < fbxNode->GetChildCount(); i++) {
		ParseNodeRecursive(model, fbxNode->GetChild(i), &node);
	}


}

void FbxLoader::ParseMesh(FbxModel* model, FbxNode* fbxNode) {
	FbxMesh* fbxMesh = fbxNode->GetMesh();

	//_WÇ‚İ
	ParseMeshVertices(model, fbxMesh);
	//
	ParseMeshFaces(model, fbxMesh);
	//}eA
	ParseMatrial(model, fbxNode);
	//XLjOÇ‚İ
	ParseSkin(model, fbxMesh);

}
//_Ç‚İ
void FbxLoader::ParseMeshVertices(FbxModel* model, FbxMesh* fbxMesh) {
	auto& vertices = model->vertices;

	//_WÌƒf[^Ì
	const int controlPointsCount = fbxMesh->GetControlPointsCount();

	//Kv_f[^m
	FbxModel::VertexPosNormalUvSkin vert{};
	model->vertices.resize(controlPointsCount, vert);

	//fbxbVÌ’_Wzæ“¾
	FbxVector4* pCoord = fbxMesh->GetControlPoints();

	//fbxbVÌ‘S_WfÌ”zÉƒRs[
	for (int i = 0; i < controlPointsCount; i++) {
		FbxModel::VertexPosNormalUvSkin& vertex = vertices[i];
		//WÌƒRs[
		vertex.pos.x = (float)pCoord[i][0];
		vertex.pos.y = (float)pCoord[i][1];
		vertex.pos.z = (float)pCoord[i][2];
	}
}
//ÊÇ‚İ
void FbxLoader::ParseMeshFaces(FbxModel* model, FbxMesh* fbxMesh) {
	auto& vertices = model->vertices;
	auto& indices = model->indices;

	//1t@CÉ•bVÌƒfÍ”Î‰
	assert(indices.size() == 0);

	//Ê‚Ì
	const int polygonCount = fbxMesh->GetPolygonCount();
	//uvf[^Ì
	const int textureUVCount = fbxMesh->GetTextureUVCount();
	//uvXg
	FbxStringList uvNames;
	fbxMesh->GetUVSetNames(uvNames);

	//Ê‚Æ‚ÌÇ‚İ
	for (int i = 0; i < polygonCount; i++) {
		const int polygonSize = fbxMesh->GetPolygonSize(i);
		assert(polygonSize <= 4);

		for (int j = 0; j < polygonSize; j++) {
			int index = fbxMesh->GetPolygonVertex(i, j);
			assert(index >= 0);
			//_@Ç‚İ
			FbxModel::VertexPosNormalUvSkin& vertex = vertices[index];
			FbxVector4 normal;
			if (fbxMesh->GetPolygonVertexNormal(i, j, normal)) {
				vertex.normal.x = (float)normal[0];
				vertex.normal.y = (float)normal[1];
				vertex.normal.z = (float)normal[2];
			}
			//eNX`uvÇ‚İ
			if (textureUVCount > 0) {
				FbxVector2 uvs;
				bool lUnmappedUV;
				//0ÔŒß‘Å‚Å“Ç‚İ
				if (fbxMesh->GetPolygonVertexUV(i, j, uvNames[0], uvs, lUnmappedUV)) {
					vertex.uv.x = (float)uvs[0];
					vertex.uv.y = (float)uvs[1];
				}
			}

			//CfbNXzÉ’_CfbNXÇ‰
			if (j < 3) {
				indices.push_back(index);
			}
			//4_
			else {
				int index2 = indices[indices.size() - 1];
				int index3 = index;
				int index0 = indices[indices.size() - 3];
				indices.push_back(index2);
				indices.push_back(index3);
				indices.push_back(index0);
			}
		}
	}

}
//}eAÇ‚İ
void FbxLoader::ParseMatrial(FbxModel* model, FbxNode* fbxNode) {
	const int materialCount = fbxNode->GetMaterialCount();
	if (materialCount > 0) {
		FbxSurfaceMaterial* material = fbxNode->GetMaterial(0);
		bool textureLoaded = false;

		if (material) {
			if (material->GetClassId().Is(FbxSurfaceLambert::ClassId)) {
				FbxSurfaceLambert* lambert =
					static_cast<FbxSurfaceLambert*>(material);

				//Â‹W
				FbxPropertyT<FbxDouble3> ambient = lambert->Ambient;
				model->ambient.x = (float)ambient.Get()[0];
				model->ambient.y = (float)ambient.Get()[1];
				model->ambient.z = (float)ambient.Get()[2];

				//gUËŒW
				FbxPropertyT<FbxDouble3> diffuse = lambert->Diffuse;
				model->diffuse.x = (float)diffuse.Get()[0];
				model->diffuse.y = (float)diffuse.Get()[1];
				model->diffuse.z = (float)diffuse.Get()[2];
			}
			//fBt[YeNX`o
			const FbxProperty diffuseProperty =
				material->FindProperty(FbxSurfaceMaterial::sDiffuse);
			if (diffuseProperty.IsValid()) {
				const FbxFileTexture* texture = diffuseProperty.GetSrcObject<FbxFileTexture>();
				if (texture) {
					const char* filepath = texture->GetFileName();
					//t@CpXt@Co
					string path_str(filepath);
					string name = ExtracFileName(path_str);
					//eNX`Ç‚İ
					LoadTexture(model, baseDirectory + model->name + "/" + name);
					textureLoaded = true;
				}
			}
		}
		//eNX`È‚ê‡eNX`\
		if (!textureLoaded) {
			LoadTexture(model, baseDirectory + defaultTextureFileName);
		}
	}
}

//eNX`Ç‚İ
void FbxLoader::LoadTexture(FbxModel* model, const std::string& fullPath) {
	HRESULT result = S_FALSE;
	//WICeNX`Ìƒ[h
	DirectX::TexMetadata& metadata = model->metaData;
	DirectX::ScratchImage& scratchImage = model->scratchImg;
	//jR[hÉ•ÏŠ
	wchar_t wfilepath[128];
	MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, wfilepath, _countof(wfilepath));
	result = DirectX::LoadFromWICFile(wfilepath, DirectX::WIC_FLAGS_NONE, &metadata, scratchImage);

	if (FAILED(result)) {
		assert(0);
	}
}

//t@Co
std::string FbxLoader::ExtracFileName(const std::string& path) {
	size_t pos1;
	//Ø‚è•¶""oÄ‚ÔÅŒÌ•
	pos1 = path.rfind("\\");
	if (pos1 != string::npos) {
		return path.substr(pos1 + 1, path.size() - pos1 - 1);
	}
	//Ø‚è•¶'/'
	pos1 = path.rfind('/');
	if (pos1 != string::npos) {
		return path.substr(pos1 + 1, path.size() - pos1 - 1);
	}

	return path;
}

//n
void FbxLoader::Finalize() {
	//eCX^XÌ”j
	fbxImporter->Destroy();
	fbxManager->Destroy();
}

void FbxLoader::ConvertMatrixFromFbx(Matrix4 dst, const FbxAMatrix& src) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			dst.m[i][j] = (float)src.Get(i, j);
		}
	}
}

void FbxLoader::ParseSkin(FbxModel* model, FbxMesh* fbxMesh) {
	FbxSkin* fbxSkin =
	static_cast<FbxSkin*>(fbxMesh->GetDeformer(0, FbxDeformer::eSkin));
	//XLjOñ‚ª‚È‚ÎI
	if (fbxSkin == nullptr) {
		return;
	}
	//{[zÌQ
	std::vector<FbxModel::Bone>& bones = model->bones;
	//{[Ì
	int clusterCount = fbxSkin->GetClusterCount();
	bones.reserve(clusterCount);

	//SÄ‚Ìƒ{[É‚Â‚
	for (int i = 0; i < clusterCount; i++) {
		//FBX{[
		FbxCluster* fbxCluster = fbxSkin->GetCluster(i);
		//{[Ì‚Ìƒm[hÌ–Oæ“¾
		const char* boneName = fbxCluster->GetLink()->GetName();
		//V{[Ç‰Ç‰{[ÌQÆ‚ğ“¾‚
		bones.emplace_back(FbxModel::Bone(boneName));
		FbxModel::Bone& bone = bones.back();
		//{[FbxÌƒ{[RÃ‚
		bone.fbxCluster = fbxCluster;
		//FBXç‰psæ“¾
		FbxAMatrix fbxMat;
		fbxCluster->GetTransformLinkMatrix(fbxMat);
		//Matrix4^É•ÏŠ
		Matrix4 initialPose;
		ConvertMatrixFromFbx(initialPose, fbxMat);
		//psÌ‹tsğ“¾‚
		bone.inInitialPose.MakeInverse();
	}
	//{[ÔÆƒXLEFCgÌƒyA
	struct WeightSet {
		UINT index;
		float weight;
	};

	//ñŸŒz(WOz)
	//list:_eó‚¯‚{[Ì‘SXg
	//vector:S_
	std::vector<std::list<WeightSet>>
	weightLists(model->vertices.size());
	//SÄ‚Ìƒ{[É‚Â‚
	for (int i = 0; i < clusterCount; i++) {
		FbxCluster* fbxCluster = fbxSkin->GetCluster(i);
		//Ìƒ{[É‰eó‚¯‚é’¸_
		int controlPointIndicesCount = fbxCluster->GetControlPointIndicesCount();
		//Ìƒ{[É‰eó‚¯‚é’¸_Ì”z
		int* controlPointIndices = fbxCluster->GetControlPointIndices();
		double* controlPointWeights = fbxCluster->GetControlPointWeights();
		//eó‚¯‚S_É‚Â‚
		for (int j = 0; j < controlPointIndicesCount; j++) {
			int vertIndex = controlPointIndices[j];
			//XLEFCg
			float weight = (float)controlPointWeights[j];
			//Ì’_Ì‰eó‚¯‚{[XgÉƒ{[ÆƒEFCgÌƒyAÇ‰
			weightLists[vertIndex].emplace_back(WeightSet{ (UINT)i,weight });
		}

		auto& vertices = model->vertices;
		for (int i = 0; i < vertices.size(); i++) {
			auto& weightList = weightLists[i];
			weightList.sort([](auto const& lhs, auto const& rhs) {
			//Ì—vfÌ•å‚«true Å‚È‚falseÔ‚
			return lhs.weight > rhs.weight;
			});

			int weightArrayIndex = 0;
			//~\[gÏ‚İ‚ÌƒEFCgXg
			for (auto& weightSet : weightList) {
				vertices[i].boneIndex[weightArrayIndex] = weightSet.index;
				vertices[i].boneWeight[weightArrayIndex] = weightSet.weight;
				//4Â‚É’BI
				if (++weightArrayIndex >= FbxModel::MAX_BONE_INDICES) {
					float weight = 0.0f;
					//2Ô–ÚˆÈ~ÌƒEFCgv
					for (int j = 1; j < FbxModel::MAX_BONE_INDICES; j++) {
						weight += vertices[i].boneWeight[j];
					}
					//v1.0f(100%)É‚È‚æ‚¤É’
					vertices[i].boneWeight[0] = 1.0f - weight;
					break;
				}
			}
		}
	}
}
</file_content>

<file_content path="engine/3d/FbxLoader.h">
#pragma once
#pragma warning(push)
#pragma	warning(disable:26495)
#pragma	warning(disable:26451)
#include <fbxsdk.h>
#pragma warning(pop)

#include "d3d12.h"
#include "d3dx12.h"
#include <string>
#include "FbxModel.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma	warning(disable:26813)
#include "DirectXTex.h"
#pragma warning(pop)

class FbxLoader {
	//GCAX
private:
	using string = std::string;

public:
	//VOgCX^XÌæ“¾
	//<return>CX^X</return>
	static FbxLoader* GetInstance();

	//
	void Initialize(ID3D12Device* device);

	//fbxt@Cçƒ‚fÇ‚İ
	FbxModel* LoadModelFlomFile(const string& modelName);

	//m[h
	void ParseNodeRecursive(FbxModel* model, FbxNode* fbxNode,Node* parent = nullptr);

	//bV
	void ParseMesh(FbxModel* model, FbxNode* fbxNode);
	//Tu
	void ParseMeshVertices(FbxModel* model, FbxMesh* fbxMesh);
	void ParseMeshFaces(FbxModel* model, FbxMesh* fbxMesh);
	void ParseMatrial(FbxModel* model, FbxNode* fbxNode);
	void LoadTexture(FbxModel* model, const std::string& fullPath);

	static void ConvertMatrixFromFbx(Matrix4 dst, const FbxAMatrix& src);

	//t@Co
	std::string ExtracFileName(const std::string& path);

	//n
	void Finalize();

	//XLjOÌ“Ç‚İ
	void ParseSkin(FbxModel* model, FbxMesh* fbxMesh);

private:
	//D3D12foCX
	ID3D12Device* device = nullptr;
	//FBX}l[W[
	FbxManager* fbxManager = nullptr;
	//FBXC|[^[
	FbxImporter* fbxImporter = nullptr;

private:
	//privateÈƒRXgN^
	FbxLoader() = default;
	//privateÈƒfXgN^
	~FbxLoader() = default;
	//Rs[RXgN^Ö~
	FbxLoader(const FbxLoader& obj) = delete;
	//Rs[ZqÖ~
	void operator=(const FbxLoader& obj) = delete;

//privateÃ“IÖ
private:
	static const string defaultTextureFileName;
public:
	static const string baseDirectory;
};
</file_content>

<file_content path="engine/3d/FbxModel.cpp">
#include "FbxModel.h"

FbxModel::~FbxModel() {
	//FBXV[Ì‰
	fbxScene->Destroy();
}

void FbxModel::CreateBuffers(ID3D12Device* device)
{
	HRESULT result;

	//_f[^SÌ‚ÌƒTCY
	UINT sizeVB =
		static_cast<UINT>(sizeof(VertexPosNormalUvSkin) * vertices.size());

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// _obt@
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));
	//_obt@Ö‚Ìƒf[^]
	VertexPosNormalUvSkin* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		std::copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}
	//_obt@r[(VBV)Ì
	vbView.BufferLocation =
		vertBuff->GetGPUVirtualAddress();
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	//_CfbNXSÌ‚ÌƒTCY
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());
	// \[Xİ’
	resourceDesc.Width = sizeIB;

	// CfbNXobt@
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&indexBuff));
	//CfbNXobt@Ö‚Ìƒf[^]
	unsigned short* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result)) {
		std::copy(indices.begin(), indices.end(), indexMap);
		indexBuff->Unmap(0, nullptr);
	}
	//CfbNXobt@r[(IBV)Ìì¬
	ibView.BufferLocation =
		indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	ibView.SizeInBytes = sizeIB;

	//eNX`æ‘œf[^Ìæ“¾
	const DirectX::Image* img = scratchImg.GetImage(0, 0, 0);
	assert(img);
	//\[Xİ’
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metaData.format, metaData.width,
		(UINT)metaData.height, (UINT16)metaData.arraySize,
		(UINT16)metaData.mipLevels);
	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps1 = CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);
	//eNX`pobt@Ì
	result = device->CreateCommittedResource(
		&heapProps1,
		D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr, IID_PPV_ARGS(&texBuff));
	//eNX`obt@Éƒf[^]
	result = texBuff->WriteToSubresource(
		0, nullptr,
		img->pixels,
		(UINT)img->rowPitch, (UINT)img->slicePitch);

	//SRVpfXNv^[q[vÌ
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	descHeapDesc.NumDescriptors = 1;
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeapSRV));
	//VF[_[\[Xr[(SRV)ì¬
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	D3D12_RESOURCE_DESC resDesc = texBuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texBuff.Get(),
		&srvDesc, descHeapSRV->GetCPUDescriptorHandleForHeapStart()
	);
}

void FbxModel::Draw(ID3D12GraphicsCommandList* cmdList)
{
	assert(cmdList);
	//_obt@Zbg
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	//CfbNXobt@Zbg
	cmdList->IASetIndexBuffer(&ibView);

	//fXNv^q[vÌƒZbg
	ID3D12DescriptorHeap* ppheaps[] = { descHeapSRV.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppheaps), ppheaps);

	//VF[_[\[Xr[Zbg
	cmdList->SetGraphicsRootDescriptorTable(3, descHeapSRV->GetGPUDescriptorHandleForHeapStart());
	//`R}h
	cmdList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}

</file_content>

<file_content path="engine/3d/FbxModel.h">
#pragma once
#include <string>
#include <vector>
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#pragma warning(push)
#pragma	warning(disable:26495)
#pragma	warning(disable:26451)
#include <fbxsdk.h>
#pragma warning(pop)

//m[h
struct Node {
	//O
	std::string name;
	//XP[
	Vector4 scaling = { 1,1,1,0 };
	//]p
	Vector4 rotation = { 0,0,0,0 };
	//[JÚ“
	Vector4 translation = { 0,0,0,1 };
	//[JÏŒ`s
	Matrix4 tranform;
	//O[oÏŒ`s
	Matrix4 globalTransform;
	//em[h
	Node* parent = nullptr;
};

class FbxModel {
public:
	friend class FbxLoader;
public://è”
	//{[CfbNXÌÅ‘å”
	static const int MAX_BONE_INDICES = 4;
//TuNX
public:
	struct VertexPosNormalUvSkin {
		Vector3 pos;
		Vector3 normal;
		Vector2 uv;
		UINT boneIndex[MAX_BONE_INDICES];
		float boneWeight[MAX_BONE_INDICES];
	};
	//{[
	struct Bone {
		std::string name;
		//pÌ‹ts
		Matrix4 inInitialPose;
		//NX^[
		FbxCluster* fbxCluster;
		//RXgN^
		Bone(const std::string& name) {
			this->name = name;
		}
	};

private://GCAX
	template <class T> using ComPtr =
		Microsoft::WRL::ComPtr<T>;
	//DirectX::È—
	using TexMetadata = DirectX::TexMetadata;
	using sSratchImage = DirectX::ScratchImage;
	//std::È—
	using string = std::string;
	template <class T> using vector =
		std::vector<T>;
private:
	//fÌ–O
	std::string name;
	//m[hz
	std::vector<Node> nodes;
	//bVÂƒm[h
	Node* meshNode = nullptr;
	//_f[^
	std::vector<VertexPosNormalUvSkin> vertices;
	//_CfbNX
	std::vector<unsigned int>indices;
	//ArGg
	Vector3 ambient = { 1,1,1 };
	//fBt[Y
	Vector3 diffuse = { 1,1,1 };
	//eNX`^f[^
	DirectX::TexMetadata metaData = {};
	//XNb`C[W
	DirectX::ScratchImage scratchImg = {};
	//_obt@
	ComPtr<ID3D12Resource> vertBuff;
	//CfbNXobt@
	ComPtr<ID3D12Resource> indexBuff;
	//eNX`obt@
	ComPtr<ID3D12Resource> texBuff;
	//_obt@r[
	D3D12_VERTEX_BUFFER_VIEW vbView = {};
	//CfbNXobt@r[
	D3D12_INDEX_BUFFER_VIEW ibView = {};
	//SRVpfXNv^[q[v
	ComPtr<ID3D12DescriptorHeap> descHeapSRV;
	//{[z
	std::vector<Bone> bones;
	//FBXV[
	FbxScene* fbxScene = nullptr;

public://Ö
	~FbxModel();
	void CreateBuffers(ID3D12Device* device);
	//`
	void Draw(ID3D12GraphicsCommandList* cmdList);
	//fÌ•ÏŒ`sæ“¾
	const Matrix4& GetModelTransform() { return meshNode->globalTransform; }
	//getter
	std::vector<Bone>& GetBones() { return bones; }
	FbxScene* GetFbxScene() { return fbxScene; }
};
</file_content>

<file_content path="engine/3d/FbxObject3d.cpp">
#include "FbxObject3d.h"
#include <d3dcompiler.h>
#pragma comment(lib, "d3dcompiler.lib")

using namespace Microsoft::WRL;

ID3D12Device* FbxObject3d::device = nullptr;
ViewProjection* FbxObject3d::view = nullptr;
ComPtr<ID3D12RootSignature> FbxObject3d::rootsignature;
ComPtr<ID3D12PipelineState> FbxObject3d::pipelinestate;
ID3D12GraphicsCommandList* FbxObject3d::cmdList = nullptr;

void FbxObject3d::CreateGraphicsPipeline()
{

	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // _VF[_IuWFNg
	ComPtr<ID3DBlob> psBlob;	// sNZVF[_IuWFNg
	ComPtr<ID3DBlob> errorBlob; // G[IuWFNg

	// _VF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/Shaders/FBXVS.hlsl",	// VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "vs_5_0",	// Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// sNZVF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/Shaders/FBXPS.hlsl",	// VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "ps_5_0",	// Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// _CAEg
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyW(1sÅÙ‚â‚·)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // @xNg(1sÅÙ‚â‚·)
			"NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // uvW(1sÅÙ‚â‚·)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// OtBbNXpCvCÌ—İ’
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// Tv}XN
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // Wİ’
	// X^CUXe[g
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// fvXXeVXe[g
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);

	// _[^[QbgÌƒuhİ’
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGASÄ‚Ìƒ`l`
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// uhXe[gÌİ’
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// [xobt@ÌƒtH[}bg
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// _CAEgÌİ’
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// }`ÌŒ`İ’iOp`j
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	gpipeline.NumRenderTargets = 1;	// `ÎÛ‚1
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0`255wRGBA
	gpipeline.SampleDesc.Count = 1; // 1sNZÉ‚Â‚1TvO

	// fXNv^W
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 WX^

	// [gp[^
	#pragma warning(push)
	#pragma	warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[4];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsConstantBufferView(1, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[2].InitAsConstantBufferView(2, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[3].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// X^eBbNTv[
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// [gVOl`Ìİ’
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// o[WÌƒVACY
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// [gVOl`Ì
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// OtBbNXpCvCÌ
	result = device->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}

void FbxObject3d::Initialize()
{
	HRESULT result;
	//è”obt@Ì
		// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataTransform) + 0xff) & ~0xff);

	// è”obt@Ì
	result = device->CreateCommittedResource(
		&heapProps,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffTransform)
	);

	worldTransform.Initialize();
}

void FbxObject3d::Update()
{
	// [hgXtH[ÌsXVÆ“]
	worldTransform.UpdateMatrix();
}

void FbxObject3d::Draw(ViewProjection* viewProjection)
{
		// nullptr`FbN
	assert(device);
	assert(FbxObject3d::cmdList);

	// fZbgÄ‚È‚Î•`XLbv
	if (model == nullptr) return;

	// è”obt@r[Zbg
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform.GetBuff()->GetGPUVirtualAddress());

	// r[vWFNVÏŠf[^è”obt@r[Zbg
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());
	// f`
	model->Draw(cmdList);
}

void FbxObject3d::StaticInitialize(ID3D12Device* device)
{
	// nullptr`FbN
	assert(device);

	FbxObject3d::device = device;

	// [hgXtH[ÉƒfoCXİ‚
	WorldTransform::StaticInitialize(device);
}

void FbxObject3d::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	// PreDrawPostDrawyAÅŒÄ‚Î‚Ä‚È‚ÎƒG[
	assert(FbxObject3d::cmdList == nullptr);

	// R}hXgZbg
	FbxObject3d::cmdList = cmdList;


	// pCvCXe[gÌİ’
	cmdList->SetPipelineState(pipelinestate.Get());
	// [gVOl`Ìİ’
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// v~eBu`İ’
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

}

void FbxObject3d::PostDraw()
{
	// R}hXg
	FbxObject3d::cmdList = nullptr;
}
</file_content>

<file_content path="engine/3d/FbxObject3d.h">
#pragma once

#include "FbxModel.h"
#include "ViewProjection.h"
#include "WorldTransform.h"
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#include <string>

class FbxObject3d {
protected://GCAX
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
public:
	static void StaticInitialize(ID3D12Device* device);
	static void SetCamera(ViewProjection* view_) { FbxObject3d::view = view_; }

	/// `O
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);
	/// `ãˆ
	static void PostDraw();
	
	static void CreateGraphicsPipeline();
private://Ã“IoÏ
	static ID3D12Device* device;
	static ViewProjection* view;
public://TuNX
	struct ConstBufferDataTransform {
		Matrix4 viewproj;
		Matrix4 world;
		Vector3 cameraPos;
	};
public://oÖ
	void Initialize();

	void Update();

	void SetModel(FbxModel* model) { this->model = model; }

	void Draw(ViewProjection* viewProjection);

	const Vector3& GetPosition() const { return worldTransform.position_; }
	void SetPosition(const Vector3& position) { this->worldTransform.position_ = position; }
	// IuWFNgÌ‘å‚«
	void SetScale(const Vector3& scale) { this->worldTransform.scale_ = scale; }
	const Vector3& GetScale() const { return worldTransform.scale_; }
	// IuWFNgÌ‰]
	void SetRotation(const Vector3& rotation) { this->worldTransform.rotation_ = rotation; }
	const Vector3& GetRotation() const { return worldTransform.rotation_; }

protected://oÏ
	ComPtr<ID3D12Resource> constBuffTransform;
private:
	static ComPtr<ID3D12RootSignature> rootsignature;
	static ComPtr<ID3D12PipelineState> pipelinestate;
	// R}hXg
	static ID3D12GraphicsCommandList* cmdList;

	WorldTransform worldTransform;
	FbxModel* model = nullptr;
};
</file_content>

<file_content path="engine/3d/Model.cpp">
#include "Model.h"

#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <fstream>
#include <sstream>
#include <vector>
#include <cassert>

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;

// Ã“IoÏÌ
ID3D12Device* Model::device = nullptr;

Model* Model::LoadFromOBJ(const string& modelname, const string& texname)
{
	// VModel^ÌƒCX^XÌƒm
	Model* model = new Model();

	// fXNv^q[vÌ
	model->InitializeDescriptorHeap();

	// OBJt@Cf[^Ç‚İ
	model->LoadFromOBJInternal(modelname);

	// obt@
	model->CreateBuffers();

	//model->LoadTexture(texname);
	
	return model;
}

void Model::LoadMaterial(const std::string& directoryPath, const std::string& filename)
{
	// t@CXg[
	std::ifstream file;
	// }eAt@CJ
	file.open(directoryPath + filename);
	// t@CI[vs`FbN
	if (file.fail()) {
		assert(0);
	}

	// 1sÂ“Ç‚İ
	string line;
	while (getline(file, line)) {
		// 1sÌ•Xg[É•ÏŠ
		std::istringstream line_stream(line);

		// pXy[XØ‚ÅsÌæ“ªæ“¾
		string key;
		getline(line_stream, key, ' ');

		// æ“ªÌƒ^uÍ–
		if (key[0] == '\t')
		{
			key.erase(key.begin()); // æ“ªÌ•íœ
		}
		// æ“ªnewmtlÈ‚}eA
		if (key == "newmtl")
		{
			// }eAÇ‚İ
			line_stream >> material.name;
		}
		// æ“ªKaÈ‚ArGgF
		if (key == "Ka")
		{
			line_stream >> material.ambient.x;
			line_stream >> material.ambient.y;
			line_stream >> material.ambient.z;
		}
		// æ“ªKdÈ‚fBt[YF
		if (key == "Kd")
		{
			line_stream >> material.diffuse.x;
			line_stream >> material.diffuse.y;
			line_stream >> material.diffuse.z;
		}
		// æ“ªKsÈ‚XyL[F
		if (key == "Ks")
		{
			line_stream >> material.specular.x;
			line_stream >> material.specular.y;
			line_stream >> material.specular.z;
		}
		// æ“ªmap_KdÈ‚eNX`t@C
		if (key == "map_Kd") {
			// eNX`Ìƒt@CÇ‚İ
			line_stream >> material.textureFilename;
			// eNX`Ç‚İ
			LoadTexture(directoryPath, material.textureFilename);
		}
	}
	// t@CÂ‚
	file.close();
}

void Model::LoadTexture(const std::string& directoryPath, const std::string& filename)
{
	HRESULT result = S_FALSE;

	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// t@CpX
	string filepath = directoryPath + filename;

	// jR[hÉ•ÏŠ
	wchar_t wfilepath[128];
	int iBufferSize = MultiByteToWideChar(CP_ACP, 0, filepath.c_str(), -1, wfilepath, _countof(wfilepath));
#pragma warning(push)
#pragma warning(disable:6054)
#pragma warning(disable:6001)
	result = LoadFromWICFile(
		wfilepath, WIC_FLAGS_NONE,
		&metadata, scratchImg
	);
	assert(SUCCEEDED(result));
#pragma warning(pop)

	ScratchImage mipChain{};
	// ~bv}bv
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// Ç‚İñ‚¾ƒfBt[YeNX`SRGBÆ‚Äˆ
	metadata.format = MakeSRGB(metadata.format);

	// \[Xİ’
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// eNX`pobt@Ì
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // eNX`pw
		nullptr, IID_PPV_ARGS(&texbuff));
	assert(SUCCEEDED(result));

	// eNX`obt@Éƒf[^]
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // f[^o
		result = texbuff->WriteToSubresource(
			(UINT)i,
			nullptr,              // SÌˆÖƒRs[
			img->pixels,          // f[^AhX
			(UINT)img->rowPitch,  // 1CTCY
			(UINT)img->slicePitch // 1TCY
		);
		assert(SUCCEEDED(result));
	}

	// VF[_\[Xr[ì¬
	cpuDescHandleSRV = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);
	gpuDescHandleSRV = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // İ’\
	D3D12_RESOURCE_DESC resDesc = texbuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2DeNX`
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texbuff.Get(), //r[ÆŠÖ˜Atobt@
		&srvDesc, //eNX`İ’
		cpuDescHandleSRV
	);

}

void Model::LoadTexture(const std::string& filename)
{
	HRESULT result = S_FALSE;

	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// t@CpX
	string filepath = filename;

	// jR[hÉ•ÏŠ
	wchar_t wfilepath[128];
	int iBufferSize = MultiByteToWideChar(CP_ACP, 0, filepath.c_str(), -1, wfilepath, _countof(wfilepath));

	result = LoadFromWICFile(
		wfilepath, WIC_FLAGS_NONE,
		&metadata, scratchImg
	);
	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	// ~bv}bv
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// Ç‚İñ‚¾ƒfBt[YeNX`SRGBÆ‚Äˆ
	metadata.format = MakeSRGB(metadata.format);

	// \[Xİ’
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// eNX`pobt@Ì
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // eNX`pw
		nullptr, IID_PPV_ARGS(&texbuff));
	assert(SUCCEEDED(result));

	// eNX`obt@Éƒf[^]
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // f[^o
		result = texbuff->WriteToSubresource(
			(UINT)i,
			nullptr,              // SÌˆÖƒRs[
			img->pixels,          // f[^AhX
			(UINT)img->rowPitch,  // 1CTCY
			(UINT)img->slicePitch // 1TCY
		);
		assert(SUCCEEDED(result));
	}

	// VF[_\[Xr[ì¬
	cpuDescHandleSRV = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);
	gpuDescHandleSRV = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // İ’\
	D3D12_RESOURCE_DESC resDesc = texbuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2DeNX`
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texbuff.Get(), //r[ÆŠÖ˜Atobt@
		&srvDesc, //eNX`İ’
		cpuDescHandleSRV
	);

}

void Model::Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndexMaterial,float alpha_)
{
	// nullptr`FbN
	assert(device);
	assert(cmdList);

	// _obt@r[Ìİ’
	cmdList->IASetVertexBuffers(0, 1, &vbView);
	// CfbNXobt@Ìİ’
	cmdList->IASetIndexBuffer(&ibView);
	//alphalİ’
	SetAlpha(alpha_);
	// è”obt@r[Zbg
	cmdList->SetGraphicsRootConstantBufferView(rootParamIndexMaterial,
		constBuffB1->GetGPUVirtualAddress());

	// fXNv^q[vÌ”z
	ID3D12DescriptorHeap* ppHeaps[] = { descHeap.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	if (material.textureFilename.size() > 0) {
		// VF[_\[Xr[Zbg
		cmdList->SetGraphicsRootDescriptorTable(3, gpuDescHandleSRV);
	}

	// `R}h
	cmdList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}

void Model::LoadFromOBJInternal(const string& modelname)
{
	HRESULT result = S_FALSE;

	// t@CXg[
	std::ifstream file;
	// .objt@CJ
	const string filename = modelname + ".obj"; // "modelname.obj"
	const string directoryPath = "Resources/" + modelname + "/"; // "Resources/modelname/"
	file.open(directoryPath + filename); // "Resources/modelname.obj"
	// t@CI[vs`FbN
	if (file.fail()) {
		assert(0);
	}
	vector<Vector3> positions; // _W
	vector<Vector3> normals;   // @xNg

	vector<Vector2> texcoords; // eNX`UV
	// PsÂ“Ç‚İ
	string line;
	while (getline(file, line)) {

		// PsÌ•Xg[É•ÏŠÄ‰Í‚â‚·
		std::istringstream line_stream(line);

		// pXp[XØ‚ÅsÌæ“ªæ“¾
		string key;
		getline(line_stream, key, ' ');

		// æ“ªñ‚ª‚È‚ç’¸_W
		if (key == "v") {
			// X,Y,ZWÇ‚İ
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// Wf[^É’Ç‰
			positions.emplace_back(position);
			// _f[^É’Ç‰
			/*VertexPosNormalUvSkin vertex{};
			vertex.pos = position;
			vertices.emplace_back(vertex);*/
		}

		// æ“ªñ‚ª‚È‚|SiOp`j
		if (key == "f") {
			// pXy[XØ‚ÅsÌ‘Ç‚İ
			string index_string;
			while (getline(line_stream, index_string, ' ')) {
				// _CfbNXPÂ•Ì•Xg[É•ÏŠÄ‰Í‚â‚·
				std::istringstream index_stream(index_string);
				unsigned short indexPosition, indexNormal, indexTexcoord;
				index_stream >> indexPosition;
				index_stream.seekg(1, ios_base::cur); // XbVÎ‚
				index_stream >> indexTexcoord;
				index_stream.seekg(1, ios_base::cur); // XbVÎ‚
				index_stream >> indexNormal;
				// _f[^Ì’Ç‰
				VertexPosNormalUvSkin vertex{};
				vertex.pos = positions[indexPosition - 1];
				vertex.normal = normals[indexNormal - 1];
				vertex.uv = texcoords[indexTexcoord - 1];
				vertices.emplace_back(vertex);
				// _CfbNXÉ’Ç‰
				//indices.emplace_back(indexPosition - 1);
				indices.emplace_back((unsigned short)indices.size());
			}
		}

		// æ“ªvtÈ‚eNX`
		if (key == "vt")
		{
			// U,VÇ‚İ
			Vector2 texcoord{};
			line_stream >> texcoord.x;
			line_stream >> texcoord.y;
			// V]
			texcoord.y = 1.0f - texcoord.y;
			// eNX`Wf[^É’Ç‰
			texcoords.emplace_back(texcoord);
		}

		// æ“ªvnÈ‚@xNg
		if (key == "vn") {
			// X,Y,ZÇ‚İ
			Vector3 normal{};
			line_stream >> normal.x;
			line_stream >> normal.y;
			line_stream >> normal.z;
			// @xNge[^É’Ç‰
			normals.emplace_back(normal);
		}

		// æ“ªmtllibÈ‚}eA
		if (key == "mtllib")
		{
			// }eAÌƒt@CÇ‚İ
			string filename;
			line_stream >> filename;
			// }eAÇ‚İ
			LoadMaterial(directoryPath, filename);
		}
	}
	// t@CÆ•Â‚
	file.close();
}

void Model::InitializeDescriptorHeap()
{
	assert(device);

	HRESULT result = S_FALSE;

	// fXNv^q[vğ¶	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//VF[_çŒ©æ‚¤
	descHeapDesc.NumDescriptors = 1; // VF[_[\[Xr[1
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap));//
	if (FAILED(result)) {
		assert(0);
	}

	// fXNv^TCYæ“¾
	descriptorHandleIncrementSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

void Model::CreateBuffers()
{
	HRESULT result = S_FALSE;

	std::vector<VertexPosNormalUvSkin> realVertices;

	/*UINT sizeVB = static_cast<UINT>(sizeof(vertices));*/
	UINT sizeVB = static_cast<UINT>(sizeof(VertexPosNormalUvSkin) * vertices.size());

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// _obt@
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	// _obt@Ö‚Ìƒf[^]
	VertexPosNormalUvSkin* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		/*memcpy(vertMap, vertices, sizeof(vertices));*/
		std::copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}

	// _obt@r[Ìì¬
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	/*vbView.SizeInBytes = sizeof(vertices);*/
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	/*UINT sizeIB = static_cast<UINT>(sizeof(indices));*/
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());
	// \[Xİ’
	resourceDesc.Width = sizeIB;

	// CfbNXobt@
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&indexBuff));

	// CfbNXobt@Ö‚Ìƒf[^]
	unsigned short* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result)) {

		// SCfbNXÉ‘Î‚
		//for (int i = 0; i < _countof(indices); i++)
		//{
		//	indexMap[i] = indices[i];	// CfbNXRs[
		//}

		std::copy(indices.begin(), indices.end(), indexMap);

		indexBuff->Unmap(0, nullptr);
	}

	// CfbNXobt@r[Ìì¬
	ibView.BufferLocation = indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	/*ibView.SizeInBytes = sizeof(indices);*/
	ibView.SizeInBytes = sizeIB;

	// nullptr`FbN
	assert(device);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps1 = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);

	//HRESULT result;

	resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB1) + 0xff) & ~0xff);

	// è”obt@Ì
	result = device->CreateCommittedResource(
		&heapProps1,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB1)
	);

	// è”obt@Öƒf[^]
	ConstBufferDataB1* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	if (SUCCEEDED(result)) {
		constMap1->ambient = material.ambient;
		constMap1->diffuse = material.diffuse;
		constMap1->specular = material.specular;
		constMap1->alpha = material.alpha;
		constBuffB1->Unmap(0, nullptr);
	}
}

void Model::SetAlpha(float alpha_) {

	HRESULT result = S_FALSE;

	// è”obt@Öƒf[^]
	ConstBufferDataB1* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	if (SUCCEEDED(result)) {
		constMap1->alpha = alpha_;
		constBuffB1->Unmap(0, nullptr);
	}
}
</file_content>

<file_content path="engine/3d/Model.h">
#pragma once

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#include <string>
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma warning(disable:26495)
class Model 
{
private: // GCAX
	// Microsoft::WRL::È—
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // TuNX
	// _f[^\
	struct VertexPosNormalUvSkin
	{
		Vector3 pos; // xyzW
		Vector3 normal; // @xNg
		Vector2 uv;  // uvW
	};

	// è”obt@pf[^\B0
	struct ConstBufferDataB0
	{
		//XMFLOAT4 color;	// F (RGBA)
		Matrix4 mat;	// RcÏŠs
	};

	// è”obt@pf[^\B1
	struct ConstBufferDataB1
	{
		Vector3 ambient; // ArGgW
		float pad1;       // pfBO
		Vector3 diffuse; // fBt[YW
		float pad2;       // pfBO
		Vector3 specular; // XyL[W
		float alpha;       // At@
	};

	// }eA
	struct Material
	{
		std::string name; // }eA
		Vector3 ambient; // ArGgex
		Vector3 diffuse; // fBtF[Yex
		Vector3 specular;// XyL[ex
		float alpha;      // At@
		std::string textureFilename; // eNX`t@C
		// RXgN^
		Material() {
			ambient = { 0.3f,0.3f,0.3f };
			diffuse = { 0.0f,0.0f,0.0f };
			specular = { 0.0f,0.0f,0.0f };
			alpha = 1.0f;
		}
	};

private: // è”
	static const int division = 50; // 
	static const float radius; // Ê‚Ì”a
	static const float prizmHeight; // Ì
	static const int planeCount = division * 2 + division * 2; // Ê‚Ì
	static const int vertexCount = planeCount * 3; // _

public: // Ã“IoÖ
	
	// OBJt@C3DfÇ‚İ
	static Model* LoadFromOBJ(const std::string& modelname, const std::string& texname = "Resources");

	// }eAÇ‚İ
	void LoadMaterial(const std::string& directoryPath, const std::string& filename);

	// eNX`Ç‚İ
	void LoadTexture(const std::string& directoryPath, const std::string& filename);
	void LoadTexture(const std::string& filename = "Resources");

	// `
	/// <param name="cmdList">`R}hXg</param>
	/// <param name="rootParamIndexMaterial">}eAp[gp[^Ô</param>
	void Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndexMaterial,float alpha_ = 1);

	// setter
	static void SetDevice(ID3D12Device* device) { Model::device = device; }

	void SetAlpha(float alpha_);


private: // Ã“IoÏ
	// foCX
	static ID3D12Device* device;
	// _f[^z
	std::vector<VertexPosNormalUvSkin> vertices;
	// _CfbNXz
	std::vector<unsigned short> indices;
	// }eA
	Material material;
	// eNX`obt@
	ComPtr<ID3D12Resource> texbuff;
	// fXNv^q[v
	ComPtr<ID3D12DescriptorHeap> descHeap;
	// VF[_\[Xr[Ìƒnh(CPU)
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuDescHandleSRV;
	// VF[_\[Xr[Ìƒnh(CPU)
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuDescHandleSRV;
	// fXNv^TCY
	UINT descriptorHandleIncrementSize;
	// _obt@
	ComPtr<ID3D12Resource> vertBuff;
	// CfbNXobt@
	ComPtr<ID3D12Resource> indexBuff;
	// _obt@r[
	D3D12_VERTEX_BUFFER_VIEW vbView;
	// CfbNXobt@r[
	D3D12_INDEX_BUFFER_VIEW ibView;
	// è”obt@i}eAj
	ComPtr<ID3D12Resource> constBuffB1; // è”obt@

private:// Ã“IoÖ
	// OBJt@C3DfÇ‚İ(J)
	void LoadFromOBJInternal(const std::string& modelname);

	// fXNv^q[vÌ
	void InitializeDescriptorHeap();

	// eobt@
	void CreateBuffers();

};
</file_content>

<file_content path="engine/3d/Object3d.cpp">
ï»¿#include "Object3d.h"
#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <fstream>
#include <sstream>
#include <vector>
#include <CollisionManager.h>

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;

/// <summary>
/// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®Ÿä½“
/// </summary>
ID3D12Device* Object3d::device = nullptr;
ID3D12GraphicsCommandList* Object3d::cmdList = nullptr;
ComPtr<ID3D12RootSignature> Object3d::rootsignature;
ComPtr<ID3D12PipelineState> Object3d::pipelinestate;

Object3d::~Object3d()
{
	if (collider)
	{
		//ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã‹ã‚‰ç™»éŒ²ã‚’è§£é™¤ã™ã‚‹
		CollisionManager::GetInstance()->RemoveCollider(collider);

		delete collider;
	}
}

void Object3d::StaticInitialize(ID3D12Device * device, int window_width, int window_height)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);

	Object3d::device = device;

	// ãƒ¢ãƒ‡ãƒ«ã«ãƒ‡ãƒã‚¤ã‚¹ã‚’ã‚»ãƒƒãƒˆ
	Model::SetDevice(device);

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã«ãƒ‡ãƒã‚¤ã‚¹ã‚’è²¸ã™
	WorldTransform::StaticInitialize(device);

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åˆæœŸåŒ–
	InitializeGraphicsPipeline();
}

void Object3d::PreDraw(ID3D12GraphicsCommandList * cmdList)
{
	// PreDrawã¨PostDrawãŒãƒšã‚¢ã§å‘¼ã°ã‚Œã¦ã„ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼
	assert(Object3d::cmdList == nullptr);

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ã‚»ãƒƒãƒˆ
	Object3d::cmdList = cmdList;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	cmdList->SetPipelineState(pipelinestate.Get());
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã‚’è¨­å®š
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

void Object3d::PostDraw()
{
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’è§£é™¤
	Object3d::cmdList = nullptr;
}

Object3d * Object3d::Create()
{
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	Object3d* object3d = new Object3d();
	if (object3d == nullptr) {
		return nullptr;
	}

	// åˆæœŸåŒ–
	if (!object3d->Initialize()) {
		delete object3d;
		assert(0);
		return nullptr;
	}


	return object3d;
}

void Object3d::InitializeGraphicsPipeline()
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/OBJVS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/OBJPS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // uvåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æµã‚Œã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¹ã‚¯
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // æ¨™æº–è¨­å®š
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®šï¼ˆä¸‰è§’å½¢ï¼‰
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	gpipeline.NumRenderTargets = 1;	// æç”»å¯¾è±¡ã¯1ã¤
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½255æŒ‡å®šã®RGBA
	gpipeline.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 ãƒ¬ã‚¸ã‚¹ã‚¿

	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	#pragma warning(push)
	#pragma warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[4];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsConstantBufferView(1, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[2].InitAsConstantBufferView(2, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[3].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è‡ªå‹•åˆ¤å®šã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}

bool Object3d::Initialize()
{
	//worldTransformåˆæœŸåŒ–
	worldTransform_.Initialize();

	//ã‚¯ãƒ©ã‚¹åã®æ–‡å­—åˆ—ã‚’å–å¾—
	name = typeid(*this).name();

	isLocked = false;

	return true;
}

void Object3d::Update()
{
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¡Œåˆ—æ›´æ–°ã¨è»¢é€
	worldTransform_.UpdateMatrix();

	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}

}

void Object3d::Draw(ViewProjection* viewProjection)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(Object3d::cmdList);

	// ãƒ¢ãƒ‡ãƒ«ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (model == nullptr) return;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform_.GetBuff()->GetGPUVirtualAddress());

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›ãƒ‡ãƒ¼ã‚¿å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());

	// ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
	model->Draw(cmdList, 2,1);
}

void Object3d::Draw(ViewProjection* viewProjection,float alpha_)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(Object3d::cmdList);
		
	// ãƒ¢ãƒ‡ãƒ«ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (model == nullptr) return;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform_.GetBuff()->GetGPUVirtualAddress());

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›ãƒ‡ãƒ¼ã‚¿å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());

	// ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
	model->Draw(cmdList, 2,alpha_);
}

void Object3d::SetCollider(BaseCollider* collider)
{
	collider->SetObject(this);
	this->collider = collider;
	//ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã«ç™»éŒ²
	CollisionManager::GetInstance()->AddCollider(collider);
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ›´æ–°ã—ã¦ãŠã
	collider->Update();
}

Vector3 Object3d::GetWorldPos() {
	Vector3 worldPos{ 0,0,0 };

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰åº§æ¨™ã‚’å–å¾—
	worldPos.x = worldTransform_.matWorld_.m[3][0];
	worldPos.y = worldTransform_.matWorld_.m[3][1];
	worldPos.z = worldTransform_.matWorld_.m[3][2];

	return worldPos;
}
</file_content>

<file_content path="engine/3d/Object3d.h">
ï»¿#pragma once

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include <d3dx12.h>
#include <string>
#include "WorldTransform.h"
#include "ViewProjection.h"
#include "Model.h"
#include "CollisionInfo.h"

class BaseCollider;

/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
class Object3d
{
private: // ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	/// é™çš„åˆæœŸåŒ–
	static void StaticInitialize(ID3D12Device* device, int window_width, int window_height);

	/// æç”»å‰å‡¦ç†
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);

	/// æç”»å¾Œå‡¦ç†
	static void PostDraw();

	/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	static Object3d* Create();

private: // é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ‡ãƒã‚¤ã‚¹
	static ID3D12Device* device;
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	static ID3D12GraphicsCommandList* cmdList;
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	static ComPtr<ID3D12RootSignature> rootsignature;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	static ComPtr<ID3D12PipelineState> pipelinestate;

private:// é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°

	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	static void InitializeGraphicsPipeline();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	//ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Object3d() = default;

	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~Object3d();

	//åˆæœŸåŒ–
	virtual bool Initialize();

	/// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†
	virtual void Update();

	/// æç”»
	void Draw(ViewProjection* viewProjection);
	void Draw(ViewProjection* viewProjection, float alpha_);

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®å–å¾—
	const Matrix4& GetMatWorld() { return matWorld; }

	// ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
	void SetModel(Model* model) { this->model = model; }

	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚»ãƒƒãƒˆ
	void SetCollider(BaseCollider* collider);

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	virtual void OnCollision(const CollisionInfo& info) {}
	virtual void OffCollision(const CollisionInfo& info) {}

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åº§æ¨™
	Vector3 GetWorldPos();
	const Vector3& GetPosition() const { return worldTransform_.position_; }
	bool GetIsLocked() { return isLocked; }
	void SetIsLocked(bool isLock) { isLocked = isLock; }
	const float& GetPositionZ() const { return worldTransform_.position_.z; }
	void SetPosition(const Vector3& position) { this->worldTransform_.position_ = position; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤§ãã•
	void SetScale(const Vector3& scale) { this->worldTransform_.scale_ = scale; }
	const Vector3& GetScale() const { return worldTransform_.scale_; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å›è»¢
	void SetRotation(const Vector3& rotation) { this->worldTransform_.rotation_ = rotation; }
	const Vector3& GetRotation() const { return worldTransform_.rotation_; }
	void SetRotationX(const float& rotation) { this->worldTransform_.rotation_.x = rotation; }
	void SetRotationY(const float& rotation) { this->worldTransform_.rotation_.y = rotation; }

	const char* GetName() const { return name; }
public:
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ãƒ‡ãƒ¼ã‚¿
	WorldTransform worldTransform_;
	const char* toCollisionName = nullptr;

protected: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	//ã‚¯ãƒ©ã‚¹å
	const char* name = nullptr;
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
	BaseCollider* collider = nullptr;
	// ãƒ¢ãƒ‡ãƒ«
	Model* model = nullptr;
	// ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›è¡Œåˆ—
	Matrix4 matWorld;
	//ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool isLocked;
};


</file_content>

<file_content path="engine/3d/Player.cpp">
#include "Player.h"
#include "string.h"
#include "RailCamera.h"
#include "SphereCollider.h"
#include"Input.h"

//fXgN^
Player::~Player() {
	delete playerModel;
}

//
bool Player::PlayerInitialize() {
	if (!Object3d::Initialize()) {
		return false;
	}

	input = Input::GetInstance();
	Initialize();

	// OBJçƒ‚ff[^Ç‚İ
	playerModel = Model::LoadFromOBJ("box");
	// 3DIuWFNg
	Create();
	// IuWFNgÉƒfĞ‚t
	SetModel(playerModel);
	SetPosition(Vector3(0, 0, 500));
	SetRotation(Vector3(0, 270, 0));

	hp = 100;
	coolTime = 0;
	len = 6.0f;
	pTimer = 0;
	isHit = false;
	isShooted = false;
	hitTime = 0;
	alpha = 1.0f;
	energy = 0;
	isUltimate = false;
	ultTime = 0;
	pos_ = { 0,0,0 };
	rot_ = { 0,0,0 };

	return true;
}

void Player::Update(Vector3 velo, std::vector<LockInfo>& info)
{
	if (isShooted == true) {
		isShooted = false;
	}


	Move();
	LockAttack(info);
	Attack(velo);
	//ULT
	if (energy >= 100) {
		if (input->TriggerKey(DIK_Q)) {
			if (isUltimate == false) {
				pos_ = GetPosition();
				rot_ = GetRotation();
				isUltimate = true;
			}
		}
	}
	for (std::unique_ptr<PlayerBullet>& bullet : bullets_) {
		if (bullet->GetIsHoming() == true) {
			bullet->HomingVec(GetWorldPos());
		}
		bullet->Update();
	}
	//fXtOÌ—Gíœ
	bullets_.remove_if([](std::unique_ptr < PlayerBullet>& bullets_) {
		return bullets_->IsDead();
		});

	if (isHit == true) {
		hitTime++;
		if (hitTime == 15) {
			hitTime = 0;
			isHit = false;
		}
	}

	worldTransform_.UpdateMatrix();
	//è”»XV
	if (collider)
	{
		collider->Update();
	}
	if (alpha < 1.0f) {
		alpha += 0.01f;
	}
}

void Player::Move()
{
	move = { 0,0,0 };

	//playerÚ“
	if (input->PushKey(DIK_W)) {
		if (input->PushKey(DIK_A) == true && input->PushKey(DIK_D) == false) {
			move = { -0.03f, 0.03f, 0 };
		}
		else if (input->PushKey(DIK_A) == false && input->PushKey(DIK_D) == true) {
			move = { 0.03f, 0.03f, 0 };
		}
		else {
			move = { 0, 0.04f, 0 };
		}
	}
	else if (input->PushKey(DIK_A)) {
		if (input->PushKey(DIK_S) == true && input->PushKey(DIK_W) == false) {
			move = { -0.03f, -0.03f, 0 };
		}
		else {
			move = { -0.04f, 0, 0 };
		}
	}
	else if (input->PushKey(DIK_D)) {
		if (input->PushKey(DIK_S) == true && input->PushKey(DIK_W) == false) {
			move = { 0.03f, -0.03f, 0 };
		}
		else {
			move = { 0.04f, 0, 0 };
		}
	}
	else if (input->PushKey(DIK_S)) {
		move = { 0, -0.04f, 0 };
	}

	Vector3 floating(0, 0, 0);
	//playerÓ‚Ó‚
	if (pTimer < 75) {
		floating += Vector3(0, 0.005f, 0);
	}
	else if (pTimer < 150) {
		floating += Vector3(0, -0.005f, 0);
	}
	else {
		pTimer = 0;
	}

	Vector3 tmp = GetPosition() + move + floating;
	//
	if (abs(tmp.x) <= 3.0f) {
		if (tmp.y >= -1.5f && tmp.y <= 2.0f) {
			if (GetPosition().z < -1.6f) {
				SetPosition(GetPosition() + move + floating + Vector3(0.0f,0.0f,0.05f));
			}
			else {
				SetPosition(GetPosition() + move + floating);
			}
		}
	}
	else {
		move = { 0,0,0 };
	}
	pTimer++;
}

void Player::Attack(Vector3 velo) {
	
	if (Input::GetInstance()->PushMouseLeft()) {
		if (coolTime == 0) {
			//eğ¶
		//
			std::unique_ptr<PlayerBullet> newBullet = std::make_unique<PlayerBullet>();

			//P
			newBullet->BulletInitialize(velo + Vector3(0,0.05f,0));
			newBullet->SetCollider(new SphereCollider());

			//eÌ“o^
		   //
			newBullet->SetPosition(GetWorldPos());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			bullets_.push_back(std::move(newBullet));


			//N[^Cİ’
			coolTime = 6;
		}
		else if (coolTime > 0) {
			coolTime--;
		}

	}
}

void Player::LockAttack(std::vector<LockInfo>& info)
{
	if (Input::GetInstance()->TriggerMouseRight() == true) {
		for (int i = 0; i < info.size(); i++) {
			//eğ¶
			std::unique_ptr<PlayerBullet> newBullet = std::make_unique<PlayerBullet>();
			Vector3 shotVec = (info[i].vec - GetWorldPos());
			//P
			newBullet->BulletInitialize(shotVec);
			newBullet->SetCollider(new SphereCollider());

			//eÌ“o^
		   //
			newBullet->SetPosition(GetWorldPos());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			newBullet->SetLock(info[i].obj);
			newBullet->SetisHoming(true);
			bullets_.push_back(std::move(newBullet));
		}
		isShooted = true;
	}
}

void Player::Ultimate()
{
	if (ultTime > 50 && ultTime < 175) {
		SetPosition(GetPosition() + Vector3(0.0f, 0.05f, 0.0f));
	}
	else if (ultTime == 175) {
		ultTime = 0;
		isUltimate = false;
		energy = 0;
	}
	worldTransform_.UpdateMatrix();
	ultTime++;
}

void Player::PlayerDraw(ViewProjection* viewProjection_) {
	if (hitTime % 5 == 0) {
		Draw(viewProjection_,alpha);
	}
	//e`
	for (std::unique_ptr<PlayerBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}

void Player::BackRail()
{
	SetPosition(pos_);
	SetRotation(rot_);
}

void Player::OnCollision(const CollisionInfo& info)
{
	//Õ“Ë‘Ì–O
	const char* str1 = "class Enemy";
	const char* str2 = "class EnemyBullet";
	const char* str3 = "class BossBullet";
	const char* str4 = "class Energy";

	//è‚ªenemy
	if (strcmp(toCollisionName, str1) == 0) {
	}
	//è‚ªenemyÌ’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (isHit == false) {
			hp-=10;
			isHit = true;
		}
	}
	//è‚ªbossÌ’e
	if (strcmp(toCollisionName, str3) == 0) {
		if (isHit == false) {
			hp-=25;
			isHit = true;
		}
	}

	//è‚ªenergy
	if (strcmp(toCollisionName, str4) == 0) {
		if (energy < 100) {
			energy += 5;
		}
	}
}
</file_content>

<file_content path="engine/3d/Player.h">
ï»¿#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "input.h"
#include "Spline.h"
#include "Model.h"
#include "Particle.h"
#include "PlayerBullet.h"

struct LockInfo {
	Vector3 vec = {0,0,0};
	 Object3d* obj = nullptr;
};

class Player : public Object3d
{
public:
	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Player();
	//åˆæœŸåŒ–
	bool PlayerInitialize();

	void Update(Vector3 velo, std::vector<LockInfo>& info);

	void Move();
	///</summary>
	void Attack(Vector3 velo);
	void LockAttack(std::vector<LockInfo>& info);
	void Ultimate();
	void PlayerDraw(ViewProjection* viewProjection_);
	void BackRail();

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void OnCollision(const CollisionInfo& info) override;


	/////getter/////
	//hp
	float GetHP() { return hp; }
	float GetEnergy() { return energy; }
	bool GetIsHit() { return isHit; }
	bool GetIsShooted() { return isShooted; }
	float GetLen() { return len; }
	bool GetIsUltimate() { return isUltimate; }
	Vector3 GetMove() { return move; }
	//setter
	void SetIsHit(bool isHit_) { isHit = isHit_; }
	void SetAlpha(float a) { alpha = a; }
	void SetIsUltimate(bool ult) { isUltimate = ult; }

	//å¼¾ãƒªã‚¹ãƒˆã‚’å–å¾—
	const std::list<std::unique_ptr<PlayerBullet>>& GetBullets() { return bullets_; }


private:
	Input* input = nullptr;
	// ãƒ¢ãƒ‡ãƒ«
	Model* playerModel = nullptr;
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	Particle* particle = nullptr;
	//å¼¾ 
	std::list<std::unique_ptr<PlayerBullet>> bullets_;
	//HP
	float hp;
	int coolTime = 0;
	float len = 6;
	int pTimer = 0;
	bool isHit;
	bool isShooted;
	int hitTime;
	float alpha;
	float energy;
	bool isUltimate;
	int ultTime;
	Vector3 pos_;
	Vector3 rot_;
	Vector3 move;
};

</file_content>

<file_content path="engine/3d/PlayerBullet.cpp">
#include "PlayerBullet.h"
#include "BaseCollider.h"

void PlayerBullet::BulletInitialize(const Vector3& velocity) {

	Initialize();

	// OBJçƒ‚ff[^Ç‚İ
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	// 3DIuWFNg
	Create();
	// IuWFNgÉƒfĞ‚t
	SetModel(bulletModel);

	//Åó‚¯xoÏÉ‘
	velocity_ = velocity;
}

void PlayerBullet::Update() {

	SetPosition(GetPosition() + velocity_);

	worldTransform_.UpdateMatrix();

	//è”»XV
	if (collider)
	{
		collider->Update();
	}
	//ÔŒoß‚ÅƒfX
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}

}

void PlayerBullet::HomingVec(Vector3 pos)
{
	if (isHoming == true) {
		velocity_ = lockObj->GetWorldPos() - GetPosition();
		velocity_ = velocity_ * 0.25f;
	}
}

void PlayerBullet::OnCollision(const CollisionInfo& info)
{
	//Õ“Ë‘Ì–O
	const char* str1 = "class Enemy";
	const char* str2 = "class EnemyBullet";
	const char* str3 = "class Boss";
	const char* str4 = "class BossBullet";

	//è‚ªenemy
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

	//è‚ªenemyÌ’e
	if (strcmp(toCollisionName, str2) == 0) {
		if (isDead_ == false && isHoming == false) {
			isDead_ = true;
		}
	}
	//è‚ª{X
	if (strcmp(toCollisionName, str3) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

	//è‚ª{XÌ’e
	if (strcmp(toCollisionName, str4) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

}
</file_content>

<file_content path="engine/3d/PlayerBullet.h">
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class PlayerBullet : public Object3d 
{
  public:
	///< summary>
	///
	///</summary>
	void BulletInitialize(const Vector3& velocity);

	///< summary>
	///
	///</summary>
	void Update();
	void HomingVec(Vector3 pos);


	//Õ“Ë‚oÄ‚ÑoR[obNÖ
	void OnCollision(const CollisionInfo& info) override;


  public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }
	bool GetIsHoming() { return isHoming; }
	void SetisHoming(bool isHoming_) { isHoming = isHoming_; }
	void SetLock(Object3d* obj) { lockObj = obj; }

  private:
	//f
	Model* bulletModel = nullptr;
	
	//x
	Vector3 velocity_;
	
	//
	static const int32_t kLifeTime = 60 * 8;
	//fX^C}[
	int32_t deathTimer_ = kLifeTime;
	//fXtO
	bool isDead_ = false;
	bool isHoming = false;
	Object3d* lockObj = nullptr;
};

</file_content>

<file_content path="engine/3d/RailCamera.cpp">
#include "RailCamera.h"

RailCamera::RailCamera() {
	isEnd = false;
}

RailCamera::~RailCamera() {
	delete viewProjection;
	delete camera;
}

//
void RailCamera::Initialize(Player* player_) {
	viewProjection = new ViewProjection;
	input = Input::GetInstance();
	viewProjection->Initialize();
	camera = Object3d::Create();
	viewProjection->eye = { 0, 1, 505 };
	viewProjection->target = { 0.3f,0.5f,499 };
	camera->SetPosition({0,0,500});
	camera->SetRotation(Vector3(0, 0, 0));
	SetPlayer(player_);
	oldCamera = { 0,0,0 };
	isEnd = false;
	OnRail = true;
	playerMoveVel = { 0,0,0 };
	cameraDelay = { 0,0,0 };
}

void RailCamera::ViewUpdate() {
	viewProjection->UpdateMatrix();
}

//XV
void RailCamera::Update(Player* player_, std::vector<Vector3>& point) {

	if (OnRail == true) {
		Vector3 target_ = spline_.Update(point, 0.00001f);
		camera->SetPosition(splineCam.Update(point, 0.0f));
		//Å1[vÌ‚İŒİˆÊ’u
		if (oldCamera.x == 0 && oldCamera.y == 0 && oldCamera.z == 0) {
			oldCamera = camera->GetPosition();
		}

		//xNgÌæ“¾
		GetVec(camera->GetPosition(), target_);

		//JÉí‚¹YÌ‰]
		float radY = std::atan2(frontVec.x, frontVec.z);
		camera->SetRotationY(radY * 180.0f / 3.1415f);
		//JÉí‚¹XÌ‰]
		Vector3 rotaVec = { frontVec.x,0,frontVec.z };
		float length = rotaVec.length();
		float radX = std::atan2(-frontVec.y, length);
		camera->SetRotationX(radX * 180.0f / 3.1415f);

		if (spline_.GetIsEnd() == true) {
			OnRail = false;
		}
		Vector3 eyeTmp = camera->GetPosition() - frontVec * player_->GetLen();

		//XV
		camera->Update();
		viewProjection->target = ((target_ + frontVec));
		//playerÌˆÚ“Æ‚ÉƒfBCÄXV
		viewProjection->eye = ((camera->GetPosition() + cameraDelay) - frontVec * player_->GetLen());
		if (viewProjection->eye.y > (eyeTmp.y + 1)) {
			viewProjection->eye.y += 0.05f;
		}

		viewProjection->UpdateMatrix();
		oldCamera = camera->GetPosition();
	}
	else {
		viewProjection->UpdateMatrix();
		camera->Update();
	}
	//cameraDelay
	playerMoveVel += (player_->GetMove() *= Vector3(1,-1,1));
	//
	if (playerMoveVel.x > 2.0f) {
		playerMoveVel.x = 2.0f;
	}
	else if (playerMoveVel.x < -2.0f) {
		playerMoveVel.x = -2.0f;
	}
	if (playerMoveVel.y > 1.2f) {
		playerMoveVel.y = 1.2f;
	}
	else if (playerMoveVel.y < -1.2f) {
		playerMoveVel.y = -1.2f;
	}
	//
	if (abs((playerMoveVel.x - cameraDelay.x)) > abs(0.05f)) {
		if (playerMoveVel.x > cameraDelay.x) {
			cameraDelay.x += 0.02f;
		}
		else if (playerMoveVel.x < cameraDelay.x) {
			cameraDelay.x += -0.02f;
		}
		else{}
	}
	if (abs((playerMoveVel.y - cameraDelay.y)) > abs(0.05f)) {
		if (playerMoveVel.y > cameraDelay.y) {
			cameraDelay.y += 0.02f;
		}
		else if (playerMoveVel.y < cameraDelay.y) {
			cameraDelay.y += -0.02f;
		}
		else {}
	}

}

void RailCamera::TitleR(Player* player_)
{
	viewProjection->eye.z -= 1.5;
}

void RailCamera::RailReset()
{
	splineCam.Reset();
	spline_.Reset();
}

////////////////////--------NXÖ—Ö--------///////////////////////

//xNgæ“¾
void RailCamera::GetVec(Vector3 a, Vector3 b) {
	Vector3 yTmpVec = { 0, 1, 0 };
	Vector3 frontTmp = { 0, 0, 0 };
	Vector3 a_ = { a.x,a.y,a.z };
	Vector3 b_ = { b.x,b.y,b.z };

	//YxNg
	yTmpVec.normalize();
	//Ê‰xNg
	frontTmp = b_ - a_;
	frontTmp.normalize();
	//ExNg
	rightVec = yTmpVec.cross(frontTmp);
	rightVec.normalize();
	//xNg
	leftVec = frontTmp.cross(yTmpVec);
	leftVec.normalize();
	//ÊƒxNg(YW0É‚)
	frontVec = rightVec.cross(yTmpVec);
	frontVec.normalize();
}

void RailCamera::SetPlayer(Player* player_) {
	//eq\ÌƒZbg
	player_->worldTransform_.SetParent3d(&camera->worldTransform_);
	//g]WÏŠ
	player_->SetPosition(Vector3(0, 0, -1.5f));
	player_->SetScale(Vector3(0.3f, 0.3f, 0.3f));
}

void RailCamera::SetEye(Vector3 view) {
	this->viewProjection->eye = view;
	viewProjection->UpdateMatrix();
}

void RailCamera::SetTarget(Vector3 target_)
{
	this->viewProjection->target = target_;
	viewProjection->UpdateMatrix();
}

void RailCamera::ShakeCamera(float x, float y) {

	//u
	std::random_device seed_gen;
	std::mt19937_64 engine(seed_gen());
	std::uniform_real_distribution<float>dist(x, y);
	std::uniform_real_distribution<float>dist2(x, y);


	viewProjection->eye = viewProjection->eye + Vector3(dist(engine), dist2(engine), dist2(engine));
	viewProjection->UpdateMatrix();
}
</file_content>

<file_content path="engine/3d/RailCamera.h">
#pragma once
#include "ViewProjection.h"
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "input.h"
#include "Spline.h"
#include "Player.h"

class RailCamera {
public:
	//CX^X
	RailCamera();
	~RailCamera();
	//
	void Initialize(Player* player_);
	//XV
	void Update(Player* player_, std::vector<Vector3>& point);
	void ViewUpdate();

	void ShakeCamera(float x, float y);

	void TitleR(Player* player_);
	void RailReset();

	//Setter
	void SetPlayer(Player* player_);
	void SetEye(Vector3 view);
	void SetTarget(Vector3 target_);
	void SetOnRail(bool onrail) { OnRail = onrail; }

	//xNgæ“¾
	void GetVec(Vector3 a, Vector3 b);

	//Getter
	ViewProjection* GetView() { return viewProjection; }
	bool GetIsEnd() { return isEnd; }
	bool GetOnRail() { return OnRail; }
	Vector3 GetFrontVec() { return frontVec; }
	Object3d* GetCamera() { return camera; }
	Vector3 GetCameraPos() { return camera->worldTransform_.position_; }
	float GetPasPoint() { return splineCam.GetT(); }
private:
	Input* input_ = nullptr;
	ViewProjection* viewProjection = nullptr;
	Object3d* camera = nullptr;
	Input* input = nullptr;

	//XvC
	Spline spline_;
	Spline splineCam;

	Vector3 rightVec = { 0, 0, 0 };
	Vector3 leftVec = { 0, 0, 0 };
	Vector3 frontVec = { 0,0,0 };
	Vector3 oldCamera = { 0,0,0 };

	//JfBC
	Vector3 playerMoveVel;
	Vector3 cameraDelay;

	//tmp
	Vector3 eyeTmp{};
	Vector3 targetTmp{};

	bool isEnd;
	bool OnRail;
};


</file_content>

<file_content path="engine/3d/ViewProjection.cpp">
#include "ViewProjection.h"
#include <d3dx12.h>
#include <cassert>
#include "WinApp.h"

Microsoft::WRL::ComPtr<ID3D12Device> ViewProjection::device_ = nullptr;

void ViewProjection::StaticInitialize(ID3D12Device* device)
{
	assert(device);
	device_ = device;
}

void ViewProjection::Initialize()
{
	CreateConstBuffer();
	Map();
	UpdateMatrix();
}

void ViewProjection::SetEye(Vector3 eye_)
{
	eye = eye_;
	UpdateMatrix();
}

void ViewProjection::SetTarget(Vector3 target_)
{
	target = target_;
	UpdateMatrix();
}

void ViewProjection::CreateConstBuffer()
{
	HRESULT result;

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataViewProjection) + 0xff) & ~0xff);

	// è”obt@Ì
	result = device_->CreateCommittedResource(
		&heapProps, // Abv[hÂ”\
		D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));
}

void ViewProjection::Map()
{
	// è”obt@Æ‚Ìƒf[^N
	HRESULT result = constBuff->Map(0, nullptr, (void**)&constMap);
	assert(SUCCEEDED(result));
}

void ViewProjection::UpdateMatrix()
{
	// r[sÌì¬
	matView.ViewMat(eye, target, up);
	// Ë‰esÌì¬
	matProjection.ProjectionMat(fovAngleY, aspectRatio, nearZ, farZ);

	// è”obt@Ö‚Ì
	constMap->view = matView;
	constMap->projection = matProjection;
	constMap->cameraPos = eye;
}
</file_content>

<file_content path="engine/3d/ViewProjection.h">
#pragma once
#include"Vector3.h"
#include "Vector4.h"
#include"Matrix4.h"
#include "WinApp.h"
#include<d3d12.h>
#include<wrl.h>

class ViewProjection
{
public:// TuNX
	// è”obt@pf[^\
	struct ConstBufferDataViewProjection {
		Matrix4 view;       // [h  r[ÏŠs
		Matrix4 projection; // r[  vWFNVÏŠs
		Vector3 cameraPos;  // JWi[hWj
	};
public:// oÖ
	// Ã“I
	static void StaticInitialize(ID3D12Device* device);

	/// 
	void Initialize();

	void SetEye(Vector3 eye_);
	Vector3 GetEye() { return eye; }
	void SetTarget(Vector3 terget_);
	Vector3 GetTarget() { return target; }
	Matrix4 GetMatView() { return matView; }
	Matrix4 GetMatProjection() { return matProjection; }


	/// sXV
	void UpdateMatrix();

	// obt@ÌƒQb^[
	ID3D12Resource* GetBuff() { return constBuff.Get(); }


private:// vCx[gÖ
	// ~
	const float PI = 3.141592f;

	/// è”obt@
	void CreateConstBuffer();

	/// }bsO
	void Map();

	// xçƒ‰WAÉ•ÏŠ
	float ToRadian(float angle) { return angle * (PI / 180); }


public:// pubNÏ
#pragma region r[sÌİ’
	// _W
	Vector3 eye = { 0, 5, -10.0f };
	// _W
	Vector3 target = { 0, 0, 0 };
	// xNg
	Vector3 up = { 0, 1, 0 };
#pragma endregion

#pragma region Ë‰esÌİ’
	// p
	float fovAngleY = ToRadian(45.0f);
	// r[|[gÌƒAXyNg
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	// [xEiOj
	float nearZ = 0.1f;
	// [xEij
	float farZ = 1000.0f;
#pragma endregion

	// r[s
	Matrix4 matView;
	// Ë‰es
	Matrix4 matProjection;

private:// oÏ

	// foCXiØ‚Ä‚j
	static Microsoft::WRL::ComPtr<ID3D12Device> device_;

	// è”obt@
	Microsoft::WRL::ComPtr<ID3D12Resource> constBuff;

	// }bsOÏ‚İƒAhX
	ConstBufferDataViewProjection* constMap = nullptr;

};


</file_content>

<file_content path="engine/3d/WorldTransform.cpp">
#include "WorldTransform.h"
#include<cassert>
#include <d3dx12.h>

Microsoft::WRL::ComPtr<ID3D12Device> WorldTransform::device_ = nullptr;

void WorldTransform::StaticInitialize(ID3D12Device* device)
{
	assert(device);
	device_ = device;
}

void WorldTransform::Initialize()
{
	CreateConstBuffer();
	Map();
	UpdateMatrix();
}

void WorldTransform::CreateConstBuffer()
{
	assert(device_);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB0) + 0xff) & ~0xff);

	HRESULT result;

	// è”obt@Ì
	result = device_->CreateCommittedResource(
		&heapProps, // Abv[hÂ”\
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB0));

	assert(SUCCEEDED(result));
}

void WorldTransform::Map()
{
	//è”obt@Ìƒ}bsO
	HRESULT result = constBuffB0->Map(0, nullptr, (void**)&constMap);//}bsO
	assert(SUCCEEDED(result));
}

void WorldTransform::UpdateMatrix()
{

	Matrix4 matScale, matRot, matTrans;
	Matrix4 matRotX, matRotY, matRotZ;

	//esvZ
	matScale = Matrix4::identity();
	matScale.scale(scale_);
	matRot = Matrix4::identity();
	matRot *= matRotZ.rotateZ(ToRadian(rotation_.z));
	matRot *= matRotX.rotateX(ToRadian(rotation_.x));
	matRot *= matRotY.rotateY(ToRadian(rotation_.y));
	matTrans = Matrix4::identity();
	matTrans.translate(position_);

	//[hsÌ
	matWorld_ = Matrix4::identity();
	matWorld_ *= matScale;
	matWorld_ *= matRot;
	matWorld_ *= matTrans;

	//eq\
	if (parent_ != nullptr) 
	{
		matWorld_ *= parent_->matWorld_;
	}

	//è”obt@É“]
	constMap->matWorld = matWorld_;
}

</file_content>

<file_content path="engine/3d/WorldTransform.h">
#pragma once
#include"Vector3.h"
#include "Vector4.h"
#include"Matrix4.h"
#include<d3d12.h>
#include<wrl.h>

class WorldTransform
{
private:
	// Microsoft::WRL::È—
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;


public:// TuNX
	//è”obt@pf[^\
	struct ConstBufferDataB0 {
		Matrix4 matWorld;// s
	};
public:// oÖ
	// Ã“I
	static void StaticInitialize(ID3D12Device* device);

	/// 
	void Initialize();

	/// sXV
	void UpdateMatrix();

	// è”obt@ÌƒQb^[
	ID3D12Resource* GetBuff() { return constBuffB0.Get(); }

	/// è”obt@
	void CreateConstBuffer();

	/// }bsO
	void Map();

	const Vector3& GetPosition()const { return position_; }

	// xçƒ‰WAÉ•ÏŠ
	float ToRadian(float angle) { return angle * (PI / 180); }

	void SetParent3d(WorldTransform* parent) { this->parent_ = parent; }

public:// pubNÏ
	// [JXP[
	Vector3 scale_ = { 1.0f, 1.0f, 1.0f };

	// X,Y,ZÌƒ[J]p
	Vector3 rotation_ = { 0, 0, 0 };

	// [JW
	Vector3 position_ = { 0, 0, 0 };

	// F
	Vector4 color_ = { 1,1,1,1 };

	// [J  [hÏŠs
	Matrix4 matWorld_;

	// eÆ‚È‚éƒ[hÏŠÖ‚Ìƒ|C^
	const WorldTransform* parent_ = nullptr;

	// ~
	const float PI = 3.141592f;

private:// oÏ
	// foCX
	static ComPtr<ID3D12Device> device_;

	// è”obt@
	ComPtr<ID3D12Resource> constBuffB0;

	// }bsOÏ‚İƒAhX
	ConstBufferDataB0* constMap = nullptr;
};


</file_content>

<file_content path="engine/3d/XMViewProjection.cpp">
#include "XMViewProjection.h"
#include "WinApp.h"

using namespace DirectX;
XMViewProjection::XMViewProjection()
{
	// r[sÌ
	UpdateViewMatrix();

	// eÉ‚Ë‰esÌ
	UpdateProjectionMatrix();

	matViewProjection_ = matView_ * matProjection_;

}

XMViewProjection::~XMViewProjection()
{
}

void XMViewProjection::Update()
{
	// r[sÌ
	UpdateViewMatrix();

	// eÉ‚Ë‰esÌ
	UpdateProjectionMatrix();

	matViewProjection_ = matView_ * matProjection_;
}

void XMViewProjection::UpdateViewMatrix()
{
	// r[sÌXV
	matView_ = XMMatrixLookAtLH(XMLoadFloat3(&eye_), XMLoadFloat3(&target_), XMLoadFloat3(&up_));
	//_W
	XMVECTOR eyePosition = XMLoadFloat3(&eye_);
	//_W
	XMVECTOR targetPosition = XMLoadFloat3(&target_);
	//()
	XMVECTOR upVector = XMLoadFloat3(&up_);

	//JZ()
	XMVECTOR cameraAxisZ = XMVectorSubtract(targetPosition, eyePosition);
	//0xNgÆŒÜ‚È‚Ì‚ÅO
	assert(!XMVector3Equal(cameraAxisZ, XMVectorZero()));
	assert(!XMVector3IsInfinite(cameraAxisZ));
	assert(!XMVector3Equal(upVector, XMVectorZero()));
	assert(!XMVector3IsInfinite(upVector));

	//xNgğ³‹K
	cameraAxisZ = XMVector3Normalize(cameraAxisZ);

	//JX(E)
	XMVECTOR cameraAxisX;
	//XÍZÌŠOÏ‚ÅŒÜ‚
	cameraAxisX = XMVector3Cross(upVector, cameraAxisZ);
	//xNgğ³‹K
	cameraAxisX = XMVector3Normalize(cameraAxisX);

	//JY()
	XMVECTOR cameraAxisY;
	//YZXÌŠOÏ‚ÅŒÜ‚
	cameraAxisY = XMVector3Cross(cameraAxisZ, cameraAxisX);

	//J]s
	XMMATRIX matCameraRot;
	//JWn[hWnÌ•ÏŠs
	matCameraRot.r[0] = cameraAxisX;
	matCameraRot.r[1] = cameraAxisY;
	matCameraRot.r[2] = cameraAxisZ;
	matCameraRot.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);

	//]uÉ‚ts(t])vZ
	matView_ = XMMatrixTranspose(matCameraRot);

	//_W-1|W
	XMVECTOR reverseEyePosition = XMVectorNegate(eyePosition);
	//JÌˆÊ’uçƒ[h_Ö‚ÌƒxNg(JWn)
	XMVECTOR tX = XMVector3Dot(cameraAxisX, reverseEyePosition);	//X
	XMVECTOR tY = XMVector3Dot(cameraAxisY, reverseEyePosition);	//Y
	XMVECTOR tZ = XMVector3Dot(cameraAxisZ, reverseEyePosition);	//Z
	//Â‚ÌƒxNgÉ‚Ü‚Æ‚ß‚
	XMVECTOR translation = XMVectorSet(tX.m128_f32[0], tY.m128_f32[1], tZ.m128_f32[2], 1.0f);

	//r[sÉ•sÚ“İ’
	matView_.r[3] = translation;

#pragma region Sr{[hsÌŒvZ
	//r{[hs
	matBillboard_.r[0] = cameraAxisX;
	matBillboard_.r[1] = cameraAxisY;
	matBillboard_.r[2] = cameraAxisZ;
	matBillboard_.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);
#pragma endregion

#pragma region Yr{[hsÌŒvZ
	//JX,Y,Z
	XMVECTOR yBillCameraAxisX, yBillCameraAxisY, yBillCameraAxisZ;

	//XÍ‹
	yBillCameraAxisX = cameraAxisX;
	//YÍƒ[hWnY
	yBillCameraAxisY = XMVector3Normalize(upVector);
	//ZXYÌŠOÏ‚ÅŒÜ‚
	yBillCameraAxisZ = XMVector3Cross(yBillCameraAxisX, yBillCameraAxisY);

	//Yr{[hs
	matBillboardY_.r[0] = yBillCameraAxisX;
	matBillboardY_.r[1] = yBillCameraAxisY;
	matBillboardY_.r[2] = yBillCameraAxisZ;
	matBillboardY_.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);

#pragma endregion

}
void XMViewProjection::UpdateProjectionMatrix()
{
	matProjection_ = XMMatrixPerspectiveFovLH(
		XMConvertToRadians(45.0f),
		(float)WinApp::window_width / WinApp::window_height,
		0.1f, 1000.0f
	);
}
void XMViewProjection::CameraMoveVector(const XMFLOAT3& move)
{
	XMFLOAT3 eye_moved = eye_;
	XMFLOAT3 target_moved = target_;

	eye_moved.x += move.x;
	eye_moved.y += move.y;
	eye_moved.z += move.z;

	target_moved.x += move.x;
	target_moved.y += move.y;
	target_moved.z += move.z;

	SetEye(eye_moved);
	SetTarget(target_moved);
}

void XMViewProjection::CameraMoveVectorEye(const XMFLOAT3& move)
{
	XMFLOAT3 eye_moved = eye_;

	eye_moved.x += move.x;
	eye_moved.y += move.y;
	eye_moved.z += move.z;

	SetEye(eye_moved);
}



void XMViewProjection::SetEye(const XMFLOAT3& eye)
{
	this->eye_ = eye;
}

void XMViewProjection::SetTarget(const XMFLOAT3& target) {
	this->target_ = target;
}

void XMViewProjection::SetUp(const XMFLOAT3& up)
{
	this->up_ = up;
}
</file_content>

<file_content path="engine/3d/XMViewProjection.h">
#pragma once
#include <DirectXMath.h>
#include <wrl.h>

class XMViewProjection
{
private:
	// Microsoft::WRL::È—
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::È—
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMMATRIX = DirectX::XMMATRIX;
public:
	XMViewProjection();
	~XMViewProjection();
	//XV
	void Update();
	//r[sXV
	void UpdateViewMatrix();
	//vWFNVsXV
	void UpdateProjectionMatrix();
	//JÚ“
	void CameraMoveVector(const XMFLOAT3& move);
	//J_Ú“
	void CameraMoveVectorEye(const XMFLOAT3& move);

protected:
	// r[s
	XMMATRIX matView_ = {};
	// Ë‰es
	XMMATRIX matProjection_ = {};

	XMMATRIX matViewProjection_ = {};

	// r{[hs
	XMMATRIX matBillboard_ = {};
	// Yr{[hs
	XMMATRIX matBillboardY_ = {};
	// _W
	XMFLOAT3 eye_ = { 0.0f, 0.0f, -100.0f };
	// _W
	XMFLOAT3 target_ = { 0.0f,0.0f,0.0f };
	// xNg
	XMFLOAT3 up_ = { 0.0f,1.0f,0.0f };

public://ANZbT
	//r[s
	const XMMATRIX& GetMatView() { return matView_; }

	//vWFNVs
	const XMMATRIX& GetMatProjection() { return matProjection_; }

	const XMMATRIX& GetMatViewProjection() { return matViewProjection_; }

	//r{[hs
	const XMMATRIX& GetMatBillboard() { return matBillboard_; }
	const XMMATRIX& GetMatBillboardY() { return matBillboardY_; }

	//_
	const XMFLOAT3& GetEye() { return eye_; }
	void SetEye(const XMFLOAT3& eye);

	//_
	const XMFLOAT3& GetTarget() { return target_; }
	void SetTarget(const XMFLOAT3& target);

	//xNg
	const XMFLOAT3& GetUp() { return up_; }
	void SetUp(const XMFLOAT3& up);
};

</file_content>

<file_content path="engine/base/DirectXCommon.cpp">
#include "DirectXCommon.h"
#include <vector>
#include <cassert>
#include <vector>
#include <string>

#pragma comment(lib, "d3d12.lib")
#pragma comment(lib, "dxgi.lib")

using namespace Microsoft::WRL;

DirectXCommon* DirectXCommon::GetInstance() 
{
	static DirectXCommon instance;

	return &instance;
}

void DirectXCommon::Initialize(WinApp* winApp) 
{
	// NULLo
	assert(winApp);

	// oÏÉ‹L^
	this->winApp = winApp;

	// FPSÅ’è‰
	fpsFixed = new FPSFixed();
	fpsFixed->InitializeFixFPS();
	// foCXÌ
	InitializeDevice();
	// R}hÖ˜AÌ
	InitializeCommand();
	// Xbv`F[Ì
	InitializeSwapchain();
	// _[^[Qbgr[Ì
	InitializeRenderTargetView();
	// [xobt@Ì
	InitializeDepthBuffer();
	// tFXÌ
	InitializeFence();
}

void DirectXCommon::InitializeDevice()
{

#ifdef _DEBUG
	// fobNC[I
	ID3D12Debug1* debugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {
		debugController->EnableDebugLayer();
		debugController->SetEnableGPUBasedValidation(TRUE);
	}

#endif

	// DXGIt@Ng[Ì
	result = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));
	assert(SUCCEEDED(result));

	// A_v^[Ì—ñ‹“—p
	std::vector<IDXGIAdapter4*> adapters;
	// É“Ì–OÂƒA_v^[IuWFNg
	IDXGIAdapter4* tmpAdapter = nullptr;

	// ptH[}XÌ‚ç‡ÉASÄ‚ÌƒA_v^[ñ‹“‚
	for (UINT i = 0;
		dxgiFactory->EnumAdapterByGpuPreference(i,
			DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE,
			IID_PPV_ARGS(&tmpAdapter)) != DXGI_ERROR_NOT_FOUND;
		i++) {
		// IzÉ’Ç‰
		adapters.push_back(tmpAdapter);
	}

	// Ã“ÈƒA_v^[IÊ‚
	for (size_t i = 0; i < adapters.size(); i++) {
		DXGI_ADAPTER_DESC3 adapterDesc;
		// A_v^[Ìæ“¾
		adapters[i]->GetDesc3(&adapterDesc);

		// \tgEFAfoCX
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE)) {
			// foCXÌ—pÄƒ[vğ”²‚
			tmpAdapter = adapters[i];
			break;
		}
	}

	// Î‰xÌ”z
	D3D_FEATURE_LEVEL levels[] = {
		D3D_FEATURE_LEVEL_12_1,
		D3D_FEATURE_LEVEL_12_0,
		D3D_FEATURE_LEVEL_11_1,
		D3D_FEATURE_LEVEL_11_0,
	};

	D3D_FEATURE_LEVEL featureLevel;

	for (size_t i = 0; i < _countof(levels); i++) {
		// Ì—pA_v^[ÅƒfoCXğ¶
		result = D3D12CreateDevice(tmpAdapter, levels[i],
			IID_PPV_ARGS(&device));
		if (result == S_OK) {
			// foCXğ¶Å‚_Åƒ[vğ”²‚
			featureLevel = levels[i];
			break;
		}
	}

#ifdef _DEBUG
	ComPtr<ID3D12InfoQueue> infoQueue;
	if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true); // G[É~Ü‚

		// }G[
		D3D12_MESSAGE_ID denyIds[] = {
			/*
			* Windows11Å‚DXGIfobNC[DX12fobNC[Ì‘İpoOÉ‚G[bZ[W
			* https://stackoverflow.com/questions/69805245/directx-12-application-is-crashing-in-windows-11
			*/
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE
		};
		// }\x
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;
		// wè‚µG[Ì•\}
		infoQueue->PushStorageFilter(&filter);

		//infoQueue->Release();
	}
#endif
}

void DirectXCommon::InitializeCommand()
{
	// R}hAP[^[ğ¶
	result = device->CreateCommandAllocator(
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		IID_PPV_ARGS(&commandAllocator));
	assert(SUCCEEDED(result));

	// R}hXgğ¶
	result = device->CreateCommandList(0,
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		commandAllocator.Get(), nullptr,
		IID_PPV_ARGS(&commandList));
	assert(SUCCEEDED(result));

	// R}hL[Ìİ’
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};

	// R}hL[ğ¶
	result = device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&commandQueue));
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeSwapchain()
{
	// Xbv`F[Ìİ’
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
	swapChainDesc.Width = 1280;
	swapChainDesc.Height = 720;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//FÌ
	swapChainDesc.SampleDesc.Count = 1;//}`TvÈ‚
	swapChainDesc.BufferUsage = DXGI_USAGE_BACK_BUFFER;//obNobt@p
	swapChainDesc.BufferCount = 2;//obt@2Â‚Éİ’
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;// tbvpÍ”j
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// IDXGISwapChain1Comptrp
	ComPtr<IDXGISwapChain1> swapChain1;

	// Xbv`F[Ì
	result = dxgiFactory->CreateSwapChainForHwnd(
		commandQueue.Get(), winApp->GetHwnd(), &swapChainDesc, nullptr, nullptr,
		&swapChain1
	);
	//IDXGISwapChain1ÌƒIuWFNgIDXGISwapChain4É•ÏŠ
	swapChain1.As(&swapChain);
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeRenderTargetView()
{
	DXGI_SWAP_CHAIN_DESC swcDesc = {};
    result = swapChain->GetDesc(&swcDesc);
    assert(SUCCEEDED(result));

	// Xbv`F[Ìİ’
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
	swapChainDesc.Width = 1280;
	swapChainDesc.Height = 720;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;// FÌ
	swapChainDesc.SampleDesc.Count = 1;// }`TvÈ‚
	swapChainDesc.BufferUsage = DXGI_USAGE_BACK_BUFFER;// obNobt@p
	swapChainDesc.BufferCount = 2;// obt@2Â‚Éİ’
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;// tbvpÍ”j
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// fXNv^q[vÌİ’
	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc{};
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;//Q[^[Qbgr[
	rtvHeapDesc.NumDescriptors = swapChainDesc.BufferCount;//\2

	rtvHD = device->GetDescriptorHandleIncrementSize(rtvHeapDesc.Type);

	// fXNv^q[vÌ
	device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&rtvHeap));

	// obNobt@
	backBuffers.resize(swapChainDesc.BufferCount);

	// \2Â•
	for (int i = 0; i < 2; i++) {
		// Xbv`F[Ì‘SÄ‚Ìƒobt@É‚Â‚Ä
		for (size_t i = 0; i < backBuffers.size(); i++) {
			// Xbv`F[obt@æ“¾
			swapChain->GetBuffer((UINT)i, IID_PPV_ARGS(&backBuffers[i]));
			// fNv^q[vobt@æ“¾
			D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = rtvHeap->GetCPUDescriptorHandleForHeapStart();
			// \ÅƒAhX
			rtvHandle.ptr += i * device->GetDescriptorHandleIncrementSize(rtvHeapDesc.Type);
			// _[^[Qbgr[Ìİ’
			D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
			// VF[_[ÌŒvZÊ‚SRGBÉ•ÏŠÄ
			rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
			rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
			// _[^[Qbgr[Ì
			device->CreateRenderTargetView(backBuffers[i].Get(), &rtvDesc, rtvHandle);
		}
	}
}

void DirectXCommon::InitializeDepthBuffer()
{
	// \[Xİ’
	D3D12_RESOURCE_DESC depthResourceDesc{};
	depthResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	depthResourceDesc.Width = WinApp::window_width;// _[^[QbgÉí‚¹
	depthResourceDesc.Height = WinApp::window_height;// _[^[QbgÉí‚¹
	depthResourceDesc.DepthOrArraySize = 1;
	depthResourceDesc.Format = DXGI_FORMAT_D32_FLOAT;//[xtH[}bg
	depthResourceDesc.SampleDesc.Count = 1;
	depthResourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;//evXXeV

	// [xlpq[vvpeB
	D3D12_HEAP_PROPERTIES depthHeapProp{};
	depthHeapProp.Type = D3D12_HEAP_TYPE_DEFAULT;
	// [xlÌƒNAİ’
	D3D12_CLEAR_VALUE depthClearValue{};//[xl1.0f(Å‘l)ÅƒNA
	depthClearValue.Format = DXGI_FORMAT_D32_FLOAT; //[xltH[}bg
	depthClearValue.DepthStencil.Depth = 1.0f;

	// \[Xİ’
	ID3D12Resource* depthBuff = nullptr;
	result = device->CreateCommittedResource(
		&depthHeapProp,
		D3D12_HEAP_FLAG_NONE,
		&depthResourceDesc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&depthClearValue,
		IID_PPV_ARGS(&depthBuff));

	// [xr[pfXNv^q[vì¬
	D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc{};
	dsvHeapDesc.NumDescriptors = 1;//[xr[1
	dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	/*ID3D12DescriptorHeap* dsvHeap = nullptr;*/
	result = device->CreateDescriptorHeap(&dsvHeapDesc, IID_PPV_ARGS(&dsvHeap));

	// [xr[ì¬
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	device->CreateDepthStencilView(
		depthBuff,
		&dsvDesc,
		dsvHeap->GetCPUDescriptorHandleForHeapStart());
}

void DirectXCommon::InitializeFence()
{
	result = device->CreateFence(fenceVal, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence));
}

void DirectXCommon::PreDraw()
{
	// obNobt@Ì”Ôæ“¾(QÂ‚È‚Ì‚0Ô‚1)
	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	// 1.\[XoAÅİ‰Â”\É•ÏX
	D3D12_RESOURCE_BARRIER barrierDesc{};
	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();// obNobt@w
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;// \Ô‚
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;// `Ô‚
	commandList->ResourceBarrier(1, &barrierDesc);
	//commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(backBuffers[bbIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

	// 2.`Ì•ÏX
	// _[^[Qbgr[Ìƒnhæ“¾
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle =
		CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeap->GetCPUDescriptorHandleForHeapStart(), bbIndex, rtvHD);
	/*rtvHandle.ptr += bbIndex * rtvH;*/
	// [xXeVr[pfXNv^q[vÌƒnhæ“¾
	CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle = 
		CD3DX12_CPU_DESCRIPTOR_HANDLE(dsvHeap->GetCPUDescriptorHandleForHeapStart());
	// `w
	commandList->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);

	// 3.`NA@@@@@
	// Ê‚hÂ‚Ô‚F    R    G      B     A
	FLOAT clearcolor[] = { 0.1f, 0.25f, 0.5f, 0.0f };// Â‚Û‚F
	// _[^[QbgNA
	commandList->ClearRenderTargetView(rtvHandle, clearcolor, 0, nullptr);
	// kxobt@NA
	commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

	bool L[Ô‚(uint8_t L[Ô);
	bool L[ğ—£‚Ô‚(uint8_t L[Ô);
	bool L[uÔ‚(uint8_t L[Ô);
	bool L[ğ—£‚uÔ‚(uint8_t L[Ô);

	//4.`R}hÍ‚
	// r[|[gİ’R}h
	D3D12_VIEWPORT viewport{};
	viewport.Width = WinApp::window_width;
	viewport.Height = WinApp::window_height;
	viewport.TopLeftX = 0;
	viewport.TopLeftY = 0;
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;
	// r[|[gİ’R}hAR}hXgÉÏ‚
	commandList->RSSetViewports(1, &viewport);
	//commandList->RSSetViewports(1, &CD3DX12_VIEWPORT(0.0f, 0.0f, WinApp::window_width, WinApp::window_height));

	// VU[`
	D3D12_RECT scissorRect{};
	scissorRect.left = 0;// Ø‚è”²W
	scissorRect.right = scissorRect.left + WinApp::window_width;// Ø‚è”²WE
	scissorRect.top = 0;// Ø‚è”²W
	scissorRect.bottom = scissorRect.top + WinApp::window_height;// Ø‚è”²W
	// VU[`İ’R}hAR}hXgÉÏ‚
	commandList->RSSetScissorRects(1, &scissorRect);
	//commandList->RSSetScissorRects(1, &CD3DX12_RECT(0, 0, WinApp::window_width, WinApp::window_height));
}

void DirectXCommon::PostDraw()
{
	// obNobt@Ì”Ôæ“¾(QÂ‚È‚Ì‚0Ô‚1)
	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	// 5.\[XoAß‚
	D3D12_RESOURCE_BARRIER barrierDesc{};
	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();// obNobt@w
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET; // \Ô‚
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT; // `Ô‚
	commandList->ResourceBarrier(1, &barrierDesc);

	// ß‚ÌƒN[Y
	result = commandList->Close();
	assert(SUCCEEDED(result));

	// R}hXgÌs
	ID3D12CommandList* commandLists[] = { commandList.Get()};
	commandQueue->ExecuteCommandLists(1, commandLists);

	// Ê‚É•\obt@Nbv(\Ì“Ö‚)
	result = swapChain->Present(1, 0);
	assert(SUCCEEDED(result));

	// R}hÌs
	commandQueue->Signal(fence.Get(), ++fenceVal);
	if (fence->GetCompletedValue() != fenceVal) {
		HANDLE event = CreateEvent(nullptr, false, false, nullptr);
		fence->SetEventOnCompletion(fenceVal, event);
		WaitForSingleObject(event, INFINITE);
		CloseHandle(event);
	}

	// FPSÅ’
	fpsFixed->UpdateFixFPS();

	// L[NA
	result = commandAllocator->Reset();
	assert(SUCCEEDED(result));

	// Ä‚ÑƒR}hXgğ’™‚ß‚é€
	result = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(result));
}

void DirectXCommon::fpsFixedFinalize()
{
	safe_delete(fpsFixed);
}

</file_content>

<file_content path="engine/base/DirectXCommon.h">
#pragma once 
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>
#include <d3dx12.h>
#include <chrono>
#include <thread>

#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)

#include "WinApp.h"
#include "FPSFixed.h"

using namespace Microsoft::WRL;

// DirectX
class DirectXCommon final
{
public: // oÖ
	// 
	void Initialize(WinApp* winApp);
	// foCXÌ
	void InitializeDevice();
	// R}hÖ˜AÌ
	void InitializeCommand();
	// Xbv`F[Ì
	void InitializeSwapchain();
	// _[^[Qbgr[Ì
	void InitializeRenderTargetView();
	// [xobt@Ì
	void InitializeDepthBuffer();
	// tFXÌ
	void InitializeFence();
	// `O
	void PreDraw();
	// `ãˆ
	void PostDraw();
	// I
	void fpsFixedFinalize();

private: // oÖ
	template <class T>
	inline void safe_delete(T*& p) {
		delete p;
		p = nullptr;
	}

public:
	static DirectXCommon* GetInstance();

private:
	DirectXCommon() = default;
	~DirectXCommon() = default;
	DirectXCommon(const DirectXCommon&) = delete;
	DirectXCommon& operator=(const DirectXCommon&) = delete;
	

public: // Getter
	// foCXÌæ“¾
	ID3D12Device* GetDevice() const { return device.Get(); }
	// R}hXgæ“¾
	ID3D12GraphicsCommandList* GetCommandList() const { return commandList.Get(); }
	// obNobt@Ìæ“¾
	size_t GetBackBufferCount() const { return backBuffers.size(); }

private: 
	// WindowsAPI
	WinApp* winApp = nullptr;
	// FPS
	FPSFixed* fpsFixed = nullptr;

	HRESULT result;
	// DirectX12foCX
	ComPtr<ID3D12Device> device;
	// DXGIt@Ng
	ComPtr<IDXGIFactory7> dxgiFactory;
	// Xbv`FC
	ComPtr<IDXGISwapChain4> swapChain;
	// R}hAP[^
	ComPtr<ID3D12CommandAllocator> commandAllocator;
	// R}hXg
	ComPtr<ID3D12GraphicsCommandList> commandList;
	// R}hL[
	ComPtr<ID3D12CommandQueue> commandQueue;
	ComPtr<ID3D12DescriptorHeap> rtvHeap;
	ComPtr<ID3D12DescriptorHeap> dsvHeap;


	//obNobt@
	std::vector<ComPtr<ID3D12Resource>> backBuffers;
	// tFXÌ
	ComPtr<ID3D12Fence> fence;

	UINT rtvHD;
	UINT64 fenceVal = 0;
};
</file_content>

<file_content path="engine/base/FPSFixed.cpp">
#include "FPSFixed.h"

void FPSFixed::InitializeFixFPS() {
	// İÔ‚L^
	reference_ = std::chrono::steady_clock::now();
}

void FPSFixed::UpdateFixFPS() {
	// 1/60bÒ‚Ì
	const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 105.0f));
	// 1/60bí‚¸É’Z
	const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 100.0f));

	// İ‚ÌÔ‚æ“¾
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
	// OL^ÌŒoßÔ‚æ“¾
	std::chrono::microseconds elapsed =
		std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

	// 1/60b(í‚¸É’Z)oÄ‚È‚ê‡
	if (elapsed < kMinCheckTime) {
		// 1/60boß‚Ü‚Å”X[vJÔ‚
		while (std::chrono::steady_clock::now() - reference_ < kMinTime) {
			// 1}CNbX[v
			std::this_thread::sleep_for(std::chrono::microseconds(1));
		}
	}
	// İ‚ÌÔ‚L^
	reference_ = std::chrono::steady_clock::now();
}
</file_content>

<file_content path="engine/base/FPSFixed.h">
#pragma once

#include <chrono>
#include <thread>

class FPSFixed 
{
public: // oÖ
	// FPSÅ’è‰
	void InitializeFixFPS();
	// FPSÅ’XV
	void UpdateFixFPS();

	// L^(FPSÅ’p)
	std::chrono::steady_clock::time_point reference_;
};
</file_content>

<file_content path="engine/base/Input.cpp">
#include "Input.h"
#include <cassert>

#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")

//using namespace Microsoft::WRL;

Input* Input::GetInstance()
{
	static Input instance;

	return &instance;
}

void Input::Initialize(WinApp* winApp)
{
	// Ø‚Ä‚WinAppÌƒCX^XL^
	this->winApp = winApp;

	HRESULT result;

	// DirectInputÌƒCX^X
	/*ComPtr<IDirectInput8> directInput = nullptr;*/
	result = DirectInput8Create(winApp->GetHInstance(), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&directInput, nullptr);
	assert(SUCCEEDED(result));

	// L[{[hfoCXÌ
	//ComPtr<IDirectInputDevice8> keyboard = nullptr;
	result = directInput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));

	// Íƒf[^`ÌƒZbg
	result = keyboard->SetDataFormat(&c_dfDIKeyboard); // W`
	assert(SUCCEEDED(result));

	// räƒŒxÌƒZbg
	result = keyboard->SetCooperativeLevel(winApp->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));

	//}EXfoCXÌƒZbg
	result = directInput->CreateDevice(GUID_SysMouse, &mouse, NULL);
	assert(SUCCEEDED(result));

	// Íƒf[^`ÌƒZbg
	result = mouse->SetDataFormat(&c_dfDIMouse); // W`
	assert(SUCCEEDED(result));
	
	// räƒŒxÌƒZbg
	result = keyboard->SetCooperativeLevel(winApp->GetHwnd(), DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
	assert(SUCCEEDED(result));

	//foCXÌİ’
	DIPROPDWORD diprop;
	diprop.diph.dwSize = sizeof(diprop);
	diprop.diph.dwHeaderSize = sizeof(diprop.diph);
	diprop.diph.dwObj = 0;
	diprop.diph.dwHow = DIPH_DEVICE;
	diprop.dwData = DIPROPAXISMODE_REL;

	result = mouse->SetProperty(DIPROP_AXISMODE, &diprop.diph);
	assert(SUCCEEDED(result));
	//}EXJ[\B
	ShowCursor(FALSE);
}

void Input::Update()
{
	HRESULT result;

	// OÌƒL[Í‚Û
	memcpy(keyPre, key, sizeof(key));

	// L[{[hÌæ“¾Jn
	result = keyboard->Acquire();

	// SL[Ì“ÍÔ‚æ“¾
	/*BYTE key[256] = {};*/
	result = keyboard->GetDeviceState(sizeof(key), key);

	//}EXJn
	memcpy(&mouseState_bak, &mouseState, sizeof(mouseState_bak));
	mouse->Acquire();

	result = mouse->GetDeviceState(sizeof(DIMOUSESTATE), &mouseState);
}

//}EX
bool Input::PushMouseLeft()
{
	if (mouseState.rgbButtons[0] != 0) {
		return true;
	}
	return false;
}

bool Input::TriggerMouseLeft()
{
	if (mouseState.rgbButtons[0] > 0 && mouseState_bak.rgbButtons[0] == 0) {
		return true;
	}
	return false;
}

bool Input::PushMouseRight()
{
	if (mouseState.rgbButtons[1] > 0) {
		return true;
	}
	return false;
}

bool Input::TriggerMouseRight()
{
	if (mouseState.rgbButtons[1] > 0 && mouseState_bak.rgbButtons[1] == 0) {
		return true;
	}
	return false;
}

Vector3 Input::GetMousePos()
{
	POINT p;
	GetCursorPos(&p);
	ScreenToClient(winApp->GetHwnd(), &p);

	//z0Å•Ô‚
	return Vector3((float)p.x,(float)p.y,0.0f);
}

Vector3 Input::GetMouseVelo()
{
	return Vector3((float)mouseState.lX - mouseState_bak.lX,(float)mouseState.lY - mouseState_bak.lY,0);
}

void Input::SetMousePos(Vector2 pos)
{
	POINT p{ (long)pos.x,(long)pos.y };
	SetCursorPos(p.x,p.y);
}

bool Input::PushKey(BYTE keyNumber) 
{
	// wL[Ä‚trueÔ‚
	if (key[keyNumber]) {
		return true;
	}
	// Å‚Í‚È‚falseÔ‚
	return false;
}

bool Input::TriggerKey(BYTE keyNumber)
{
	if (key[keyNumber] && keyPre[keyNumber] == false) {
		return true;
	}
	
	return false;
}

bool Input::AnyKey()
{
	for (int i = 0; i < sizeof(key); i++) {
		if (key[i] && keyPre[i] == false) {
			return true;
		}
	}

	return false;
}

</file_content>

<file_content path="engine/base/Input.h">
#pragma once
#include <windows.h>
#include <wrl.h>
#include <dinput.h>
#include "WinApp.h"
#include <dwrite.h>
#include <wchar.h>
#include <wrl/client.h>
#include <random>
#include <xinput.h>
#include "Vector3.h"
#include "Vector2.h"

#pragma comment(lib,"d3d11.lib")
#pragma comment(lib,"d2d1.lib")
#pragma comment(lib,"dwrite.lib")
#pragma comment (lib, "xinput.lib")

#define MaxCountrollers 4  
#define MaxVibration 65535
//#define DIRECTINPUT_VERSION 0x0800 // DirectInputÌƒo[Ww

// 
class Input final
{
public:
	static Input* GetInstance();

public:
	struct CountrolerState
	{
		XINPUT_STATE state; // Rg[[ÌÔ‚Ìæ“¾
		XINPUT_VIBRATION vibration;  // oCu[V
		//bool Connected;
	};
	/*CountrolerState GamePad;*/

public:
	// namespace
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // oÖ
	// 
	void Initialize(WinApp* winApp);

	// XV
	void Update();

	//}EX
	bool PushMouseLeft();
	bool TriggerMouseLeft();
	bool PushMouseRight();
	bool TriggerMouseRight();
	//W
	Vector3 GetMousePos();
	Vector3 GetMouseVelo();

	void SetMousePos(Vector2 pos);

	/// <summary>
	/// L[Ì‰`FbN
	/// </summary>
	/// <param name = "keyNumber">L[Ô(DIK_0 )</param>
	/// <returns>Ä‚é‚©</returns>
	bool PushKey(BYTE keyNumber);

	/// <summary>
	/// L[ÌƒgK[`FbN
	/// </summary>
	/// </param name="keyNumber">L[Ô( DIK_0 )</param>
	/// <reutrns>gK[</params>
	bool TriggerKey(BYTE keyNumber);
	bool AnyKey();

private:
	Input() = default;
	~Input() = default;
	Input(const Input&) = delete;
	Input& operator=(const Input&) = delete;

private: // oÏ
	// L[{[hÌƒfoCX
	ComPtr<IDirectInputDevice8> keyboard;
	//}EXÌƒfoCX
	ComPtr<IDirectInputDevice8> mouse;
	// DirectInputÌƒCX^X
	ComPtr<IDirectInput8> directInput;
	// SL[Ì
	BYTE key[256] = {};
	// OÌ‘SL[Ì
	BYTE keyPre[256] = {};
	//}EXÌ
	DIMOUSESTATE mouseState = {};
	DIMOUSESTATE mouseState_bak = {};	// }EX(Ï‰mp)
	// WindowsAPI
	WinApp* winApp = nullptr;
};
</file_content>

<file_content path="engine/base/JsonLoader.cpp">
#include "JsonLoader.h"

#pragma warning(push)
#pragma	warning(disable:4281)
#include <json.hpp>
#pragma warning(pop)
#include <fstream>
#include <cassert>

const std::string JsonLoader::kDefaultBaseDirectory = "Resources/levels/";
const std::string JsonLoader::kExtension = ".json";

//t@CÇ‚İ
LevelData* JsonLoader::LoadFile(const std::string& fileName) {
	// AÄƒtpXğ“¾‚
	const std::string fullpath = kDefaultBaseDirectory + fileName + kExtension;

	// t@CXg[
	std::ifstream file;

	// t@CJ
	file.open(fullpath);
	// t@CI[vs`FbN
	if (file.fail()) {
		assert(0);
	}

	// JSONñ‚©‚ğ“€‚f[^
	nlohmann::json deserialized;

	// 
	file >> deserialized;

	// xf[^t@C`FbN
	assert(deserialized.is_object());
	assert(deserialized.contains("name"));
	assert(deserialized["name"].is_string());

	// "name"ğ•¶Æ‚Äæ“¾
	std::string name = deserialized["name"].get<std::string>();
	// xf[^t@C`FbN
	assert(name.compare("scene") == 0);

	// xf[^i[pCX^Xğ¶
	LevelData* levelData = new LevelData();

	// "objects"Ì‘SIuWFNgğ‘–
	for (nlohmann::json& object : deserialized["objects"]) {
		assert(object.contains("type"));

		// Ê‚æ“¾
		std::string type = object["type"].get<std::string>();

		// MESH
		if (type.compare("MESH") == 0) {
			// vfÇ‰
			levelData->objects.emplace_back(LevelData::ObjectData{});
			// Ç‰vfÌQÆ‚ğ“¾‚
			LevelData::ObjectData& objectData = levelData->objects.back();

			if (object.contains("file_name")) {
				// t@C
				objectData.fileName = object["file_name"];
			}

			// gXtH[Ìƒp[^Ç‚İ
			nlohmann::json& transform = object["transform"];
			// sÚ“
			objectData.translation.x = (float)transform["translation"][1];
			objectData.translation.y = (float)transform["translation"][2];
			objectData.translation.z = (float)transform["translation"][0] * -1;
			objectData.translation.w = 1.0f;
			// ]p
			objectData.rotation.x = (float)transform["rotation"][1] * -1;
			objectData.rotation.y = (float)transform["rotation"][2] * -1;
			objectData.rotation.z = (float)transform["rotation"][0];
			objectData.rotation.w = 0.0f;
			// XP[O
			objectData.scaling.x = (float)transform["scaling"][1];
			objectData.scaling.y = (float)transform["scaling"][2];
			objectData.scaling.z = (float)transform["scaling"][0];
			objectData.scaling.w = 0.0f;

			// TODO: RC_[Ìƒp[^Ç‚İ
		}

		// TODO: IuWFNgÄ‹AÖÉ‚Ü‚Æ‚ßAÄ‹AÄoÅ}ğ‘–
		if (object.contains("children")) {

		}
	}

	return levelData;
}
</file_content>

<file_content path="engine/base/JsonLoader.h">
#pragma once
#include "Vector4.h"
#pragma warning(push)
#pragma	warning(disable:4282)
#pragma	warning(disable:4283)
#pragma	warning(disable:4285)
#include <json.hpp>
#pragma warning(pop)
#include <string>
#include <vector>
#include "Matrix4.h"

// xf[^
struct LevelData {

	struct ObjectData {
		// t@C
		std::string fileName;
		// sÚ“
		Vector4 translation;
		// ]p
		Vector4 rotation;
		// XP[O
		Vector4 scaling;
	};

	// IuWFNgz
	std::vector<ObjectData> objects;
};

class JsonLoader {
public:
	//t@CÇ‚İ
	LevelData* LoadFile(const std::string& fileName);
public:
	// ftHgÌ“Ç‚İİƒfBNg
	static const std::string kDefaultBaseDirectory;
	// t@Cgq
	static const std::string kExtension;

};
</file_content>

<file_content path="engine/base/WinApp.cpp">
#include "WinApp.h"

WinApp* WinApp::GetInstance() 
{
	static WinApp instance;

	return &instance;
}

LRESULT WinApp::WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{

	// bZ[WÅ•
	switch (msg) {
	case WM_DESTROY: // EBhEjê‚½
		PostQuitMessage(0); // OSÉ‘Î‚ÄAAvÌI`
		return 0;
	}
	return DefWindowProc(hwnd, msg, wparam, lparam); // WÌs
}

void WinApp::Initialize()
{
	// EBhENXÌİ’
	//WNDCLASSEX w{};
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.lpfnWndProc = (WNDPROC)WindowProc;    // EBhEvV[Wİ’
	wc.lpszClassName = L"DirectXGame";       // EBhNX
	wc.hInstance = GetModuleHandle(nullptr); // EBhnh
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);// J[\w

	// EBhNXOSÉ“o^
	RegisterClassEx(&wc);
	// EBhTCY{XW@YW@@c}
	RECT wrc = { 0, 0, window_width, window_height };
	// ÅƒTCYâ³
	AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);

	// EBhEIuWFNgÌ
	hwnd = CreateWindow(wc.lpszClassName, // NX
		L"DirectXGame",       // ^Cgo[Ì•
		WS_OVERLAPPEDWINDOW,  // WIÈƒEBhEX^C
		CW_USEDEFAULT,        // WXW (05É”C)
		CW_USEDEFAULT,        // WYW (05É”C)
		wrc.right - wrc.left, // EBhE
		wrc.bottom - wrc.top, // EBhEc
		nullptr,
		nullptr,
		wc.hInstance,
		nullptr);

	// EBhE\Ô‚É‚
	ShowWindow(hwnd, SW_SHOW);

}

void WinApp::Finalize()
{
	// EBhENXo^
	UnregisterClass(wc.lpszClassName, wc.hInstance);
}

bool WinApp::ProcessMessage()
{
	MSG msg{};// bZ[W

	if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg); //L[ÍƒbZ[WÌ
		DispatchMessage(&msg);  //vV[W[ÉƒbZ[Wğ‘—‚
	}

	if (msg.message == WM_QUIT) {
		return true;
	}

	return false;
}

</file_content>

<file_content path="engine/base/WinApp.h">
#pragma once
#include <Windows.h>

// WindowsAPI
class WinApp final
{
public: // Ã“IoÖ
	static LRESULT WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

public: // oÖ
	// WindowsAPIÌ
	void Initialize();

	// I
	void Finalize();

	// getter
	HWND GetHwnd() const { return hwnd; }
	HINSTANCE GetHInstance() const { return wc.hInstance; }

	// bZ[WÌ
	bool ProcessMessage();

public:
	static WinApp* GetInstance();

private:
	WinApp() = default;
	~WinApp() = default;
	WinApp(const WinApp&) = delete;
	WinApp& operator=(const WinApp&) = delete;

public: // è”
	// EBhE
	static const int window_width = 1280;
	// EBhEc
	static const int window_height = 720;

private:
	// EBhEnh
	HWND hwnd = nullptr;
	// EBhENXÌİ’
	WNDCLASSEX wc{};
};
</file_content>

<file_content path="engine/collision/BaseCollider.h">
#pragma once

#include "CollisionTypes.h"
#include "Object3d.h"
#include "CollisionInfo.h"

//RC_[NX
class BaseCollider
{
public:
	BaseCollider() = default;
	//zfXgN^
	virtual ~BaseCollider() = default;

	inline void SetObject(Object3d* object)
	{
		this->object3d = object;
		collname = object->GetName();
	}
	inline Object3d* GetObject3d()
	{
		return object3d;
	}
	void SetName(const char* name_) {
		this->collname = name_;
	}
	const char* GetName() {
		return collname;
	}

	//XV
	virtual void Update() = 0;

	//`^Cvæ“¾
	inline CollisionShapeType GetShapeType()
	{
		return shapeType;
	}

	//Õ“ËR[obNÖ
	inline void OnCollision(const CollisionInfo& info)
	{
		object3d->OnCollision(info);
	}

	//Õ“ËR[obNÖ
	inline void OffCollision(const CollisionInfo& info)
	{
		object3d->OffCollision(info);
	}

protected:
	Object3d* object3d = nullptr;
	//`^Cv
	CollisionShapeType shapeType = SHAPE_UNKNOWN;
	//Õ“ËNX
	const char* collname = nullptr;
};
</file_content>

<file_content path="engine/collision/Collision.cpp">
#include "Collision.h"
using namespace DirectX;


bool Collision::CheckSphere2Sphere(const Sphere& sphereA, const Sphere& sphereB, Vector3* inter, Vector3* reject)
{
	float x = (sphereB.center.x - sphereA.center.x) * (sphereB.center.x - sphereA.center.x);
	float y = (sphereB.center.y - sphereA.center.y) * (sphereB.center.y - sphereA.center.y);
	float z = (sphereB.center.z - sphereA.center.z) * (sphereB.center.z - sphereA.center.z);

	float dist = x + y + z;
	float radius = (sphereA.radius + sphereB.radius) * (sphereA.radius + sphereB.radius);

	if (dist <= radius) {
		if (inter) {
			// AÌ”a0ÌWBÌ’S  BÌ”a0ÌWAÌ’S  Æ‚È‚æ‚¤É•
			float t = sphereB.radius / (sphereA.radius + sphereB.radius);
			*inter = Vector3::lerp(sphereA.center, sphereB.center, t);
		}
		if (reject) {
			float rejectLen = sphereA.radius + sphereB.radius - sqrtf(dist);
			Vector3 center = sphereA.center - sphereB.center;
			*reject = center.normalize();
			*reject *= rejectLen;

		}
		return true;
	}
	return false;
}

bool Collision::CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter)
{
	// WnÌŒ_ç‹…Ì’SWÖ‚Ì‹
	Vector3 V;
	float distV = V.dot(sphere.center, plane.normal);
	// Ê‚ÌŒ_Zé‚±Æ‚ÅAÊ‚Æ‹Ì’SÆ‚Ì‹o
	float dist = distV - plane.distance;
	// ÌÎ’laå‚«Î“Ä‚È‚
	if (fabsf(dist) > sphere.radius) return false;

	// ^_vZ
	if (inter) {
		// ÊÌÅ‹ßÚ“_A^_Æ‚
		*inter = -dist * plane.normal + sphere.center;
	}

	return true;
}

void Collision::ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest)
{
	// pointp0ÌŠOÌ’_ÌˆÌ’É‚é‚©Ç‚`FbN
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	Vector3 p0_p2 = triangle.p2 - triangle.p0;
	Vector3 p0_pt = point - triangle.p0;

	Vector3 V;
	float d1 = V.dot(p0_p1, p0_pt);
	float d2 = V.dot(p0_p2, p0_pt);

	if (d1 <= 0.0f && d2 <= 0.0f)
	{
		// p0Å‹ß–T
		*closest = triangle.p0;
		return;
	}

	// pointp1ÌŠOÌ’_ÌˆÌ’É‚é‚©Ç‚`FbN
	Vector3 p1_pt = point - triangle.p1;

	float d3 = V.dot(p0_p1, p1_pt);
	float d4 = V.dot(p0_p2, p1_pt);

	if (d3 >= 0.0f && d4 <= d3)
	{
		// p1Å‹ß–T
		*closest = triangle.p1;
		return;
	}

	// pointp0_p1Ì•Ó—ÌˆÌ’É‚é‚©Ç‚`FbNApointp0_p1É‘Î‚Ë‰eÔ‚
	float vc = d1 * d4 - d3 * d2;
	if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
	{
		float v = d1 / (d1 - d3);
		*closest = triangle.p0 + v * p0_p1;
		return;
	}

	// pointp2ÌŠOÌ’_ÌˆÌ’É‚é‚©Ç‚`FbN
	Vector3 p2_pt = point - triangle.p2;

	float d5 = V.dot(p0_p1, p2_pt);
	float d6 = V.dot(p0_p2, p2_pt);
	if (d6 >= 0.0f && d5 <= d6)
	{
		*closest = triangle.p2;
		return;
	}

	// pointp0_p2Ì•Ó—ÌˆÌ’É‚é‚©Ç‚`FbNApointp0_p2É‘Î‚Ë‰eÔ‚
	float vb = d5 * d2 - d1 * d6;
	if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
	{
		float w = d2 / (d2 - d6);
		*closest = triangle.p0 + w * p0_p2;
		return;
	}

	// pointp1_p2Ì•Ó—ÌˆÌ’É‚é‚©Ç‚`FbNApointp1_p2É‘Î‚Ë‰eÔ‚
	float va = d3 * d6 - d5 * d4;
	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
	{
		float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
		*closest = triangle.p1 + w * (triangle.p2 - triangle.p1);
		return;
	}

	float denom = 1.0f / (va + vb + vc);
	float v = vb * denom;
	float w = vc * denom;
	*closest = triangle.p0 + p0_p1 * v + p0_p2 * w;
}

bool Collision::CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter, Vector3* reject)
{
	Vector3 p;
	// Ì’SÉ‘Î‚Å‹ßÚ“_Å‚Op`É‚_pÂ‚
	ClosestPtPoint2Triangle(sphere.center, triangle, &p);

	// _pÆ‹Ì’SÌxNg
	Vector3 v = p - sphere.center;
	Vector3 VV;
	// Ì“ß‚
	// ixNgmÌ“Ï‚ÍOÌ’è—Ìƒ[gÌÆˆvj
	float vvv = VV.dot(v, v);

	// ÆOp`Ì‹aÈ‰È‚ç“–Ä‚È‚
	if (vvv > sphere.radius * sphere.radius)return false;

	// ^_vZ
	if (inter) {
		// Op`ÌÅ‹ßÚ“_p^_Æ‚
		*inter = p;
	}
	// oxNgvZ
	if (reject) {
		float ds = Vector3::dot(sphere.center, triangle.normal);
		float dt = Vector3::dot(triangle.p0, triangle.normal);
		float rejectLen = dt - ds + sphere.radius;
		*reject = triangle.normal * rejectLen;
	}
	return true;
}

bool Collision::CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance, Vector3* inter)
{
	const float epsilon = 1.0e-5f; // ë·zpÌ”È’l
	// Ê–@gCÌ•xNgÌ“
	Vector3 V;
	float d1 = V.dot(plane.normal, ray.dir);
	// Ê‚É‚Í“È‚
	if (d1 > -epsilon) { return false; }
	// n_ÆŒ_Ì‹iÊ‚Ì–@j
	// Ê–@gCÌ_WiÊ’uxNgjÌ“
	float d2 = V.dot(plane.normal, ray.start);
	// n_Æ•Ê‚Ì‹iÊ‚Ì–@j
	float dist = d2 - plane.distance;
	// n_Æ•Ê‚Ì‹iCj
	float t = dist / -d1;
	// _n_É‚Ì‚ÅAÈ‚
	if (t < 0)return false;
	// 
	if (distance) { *distance = t; }

	// _vZ
	if (inter) { *inter = ray.start + t * ray.dir; }

	return true;
}

bool Collision::CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance, Vector3* inter)
{
	// Op`Ä‚é•½Ê‚Zo
	Plane plane;
	Vector3 interPlane;
	Vector3 V;
	plane.normal = triangle.normal;
	plane.distance = V.dot(triangle.normal, triangle.p0);

	// CÆ•Ê‚Ä‚È‚ÎAÄ‚È‚
	if (!CheckRay2Plane(ray, plane, distance, &interPlane)) { return false; }

	// CÆ•Ê‚Ä‚Ì‚ÅAÆŒ_Ü‚ê‚½
	// CÆ•Ê‚ÌŒ_Op`Ì“É‚é‚©
	const float epsilon = 1.0e-5f;// ë·zpÌ”È’l
	Vector3 m;

	// p0_p1É‚Â‚
	Vector3 pt_p0 = triangle.p0 - interPlane;
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	m = pt_p0.cross(p0_p1);

	// Ó‚ÌŠOÅ‚Î“Ä‚È‚Ì‚Å”Å‚Ø‚
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// p1_p2É‚Â‚
	Vector3 pt_p1 = triangle.p1 - interPlane;
	Vector3 p1_p2 = triangle.p2 - triangle.p1;
	m = pt_p1.cross(p1_p2);

	// Ó‚ÌŠOÅ‚Î“Ä‚È‚Ì‚Å”Å‚Ø‚
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// p2_p0É‚Â‚
	Vector3 pt_p2 = triangle.p2 - interPlane;
	Vector3 p2_p0 = triangle.p0 - triangle.p2;
	m = pt_p2.cross(p2_p0);

	// Ó‚ÌŠOÅ‚Î“Ä‚È‚Ì‚Å”Å‚Ø‚
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// È‚Ì‚ÅAÄ‚
	if (inter) {
		*inter = interPlane;
	}

	return true;
}

bool Collision::CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance, Vector3* inter)
{
	Vector3 m = ray.start - sphere.center;
	Vector3 V;
	float b = V.dot(m, ray.dir);
	float c = V.dot(m, m) - sphere.radius * sphere.radius;

	// rayÌn_sphereÌŠOÉ‚(c>0)Araysphereç—£Ä‚Ä‚ê‡(b>0)AÈ‚
	if (c > 0.0f && b > 0.0f) { return false; }

	float discr = b * b - c;

	// Ì”ÊÍ—á‚ªOÄ‚é‚±Æ‚Éˆv
	if (discr < 0.0f) { return false; }

	// CÍ‹ÆŒÄ‚
	// ÅÌ’ltvZ
	float t = -b - sqrtf(discr);

	// Å‚ê‡ACÍ‹Ì“JnÄ‚Ì‚Å‚[ÉƒNv
	if (t < 0)t = 0.0f;
	if (distance) { *distance = t; }

	if (inter) { *inter = ray.start + t * ray.dir; }

	return true;
}

</file_content>

<file_content path="engine/collision/Collision.h">
#pragma once

#include "CollisionPrimitive.h"

class Collision
{
public:
	//Æ‹Ì“è”»
	static bool CheckSphere2Sphere(const Sphere& sphereA, const Sphere& sphereB, Vector3* inter = nullptr, Vector3* reject = nullptr);
	//Æ•Ê‚Ì“è”»
	static bool CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter = nullptr);

	//_ÆOp`ÌÅ‹ß‚Ä‚ß‚
	static void ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest);

	//Æ–@tOp`Ì“`FbN
	static bool CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter = nullptr, Vector3* reject = nullptr);

	//CÆ•Ê‚Ì“è”»
	static bool CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance = nullptr, Vector3* inter = nullptr);

	//CÆ–@tOp`Ì“è”»
	static bool CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance = nullptr, Vector3* inter = nullptr);

	//CÆ‹Ì“è”»
	static bool CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance = nullptr, Vector3* inter = nullptr);
};


</file_content>

<file_content path="engine/collision/CollisionInfo.h">
#pragma once
#include"Vector3.h"

class Object3d;
class BaseCollider;


struct CollisionInfo
{
public:
	CollisionInfo(Object3d* object, BaseCollider* collider, const Vector3& inter) {
		this->object = object;
		this->collider = collider;
		this->inter = inter;
	}

	// Õ“Ë‘ÌƒIuWFNg
	Object3d* object = nullptr;
	// Õ“Ë‘ÌƒRC_[
	BaseCollider* collider = nullptr;
	// Õ“Ë“_
	Vector3 inter;

};
</file_content>

<file_content path="engine/collision/CollisionManager.cpp">
#include "CollisionManager.h"
#include "BaseCollider.h"
#include "Collision.h"

using namespace DirectX;

CollisionManager* CollisionManager::GetInstance()
{
	static CollisionManager instance;
	return &instance;
}

void CollisionManager::CheckAllCollisions()
{
	std::forward_list<BaseCollider*>::iterator itA;
	std::forward_list<BaseCollider*>::iterator itB;

	//SÄ‚Ì‘gİí‚¹É‚Â‚Ä‘`FbN
	itA = colliders.begin();
	for (; itA != colliders.end(); ++itA)
	{
		itB = itA;
		++itB;
		for (; itB != colliders.end(); ++itB)
		{
			BaseCollider* colA = *itA;
    		BaseCollider* colB = *itB;
			//Õ“Ë‘L
			colA->GetObject3d()->toCollisionName = colB->GetName();
			colB->GetObject3d()->toCollisionName = colA->GetName();
			

			// Æ‚É‹
			if (colA->GetShapeType() == COLLISIONSHAPE_SPHERE &&
				colB->GetShapeType() == COLLISIONSHAPE_SPHERE) {
				Sphere* SphereA = dynamic_cast<Sphere*>(colA);
				Sphere* SphereB = dynamic_cast<Sphere*>(colB);
				Vector3 inter;
				Vector3 reject;
				if (Collision::CheckSphere2Sphere(*SphereA, *SphereB, &inter,&reject)) {
					colA->OnCollision(CollisionInfo(colB->GetObject3d(), colB, inter));
					colB->OnCollision(CollisionInfo(colA->GetObject3d(), colA, inter));
				}
			}
		}
	}
}

bool CollisionManager::Raycast(const Ray& ray, RaycastHit* hitInfo, float maxDistance)
{
	bool result = false;
	//pÌƒCe[^
	std::forward_list<BaseCollider*>::iterator it;
	//Ü‚Å‚ÅÅ‚ß‚RC_[L^é‚½ß‚ÌƒCe[^
	std::forward_list<BaseCollider*>::iterator it_hit;
	//Ü‚Å‚ÅÅ‚ß‚RC_[Ì‹L^Ï
	float distance = maxDistance;
	//Ü‚Å‚ÅÅ‚ß‚RC_[Æ‚ÌŒ_L^Ï
	Vector3 inter;

	//SÄ‚ÌƒRC_[Æ‘`FbN
	it = colliders.begin();
	for (; it != colliders.end(); ++it)
	{
		BaseCollider* colA = *it;
		//Ìê‡
		if (colA->GetShapeType() == COLLISIONSHAPE_SPHERE)
		{
			Sphere* sphere = dynamic_cast<Sphere*>(colA);
			float tempDistance;
			Vector3 tempInter;
			//È‚ÎO
			if (!Collision::CheckRay2Sphere(ray, *sphere, &tempDistance, &tempInter))continue;
			//ÅoÈ‚ÎO
			if (tempDistance >= distance)continue;
			//Ü‚Å‚ÅÅ‚ß‚Ì‚Å‹L^Æ‚
			result = true;
			distance = tempDistance;
			inter = tempInter;
			it_hit = it;
			//ÅIIÉ‰É“Ä‚çŒ‹Ê‚
			if (result && hitInfo)
			{
				hitInfo->distance = distance;
				hitInfo->inter = inter;
				hitInfo->collider = *it_hit;
				hitInfo->object = hitInfo->collider->GetObject3d();
			}
			return result;
		}
	}
	return false;
}
</file_content>

<file_content path="engine/collision/CollisionManager.h">
#pragma once
#include "CollisionPrimitive.h"
#include "RaycastHit.h"

#include <forward_list>
#include <d3d12.h>

class BaseCollider;

class CollisionManager
{
public://Ã“IoÖ
	static CollisionManager* GetInstance();

public://oÖ
	//RC_[Ì’Ç‰
	inline void AddCollider(BaseCollider* collider)
	{
		colliders.push_front(collider);
	}
	//RC_[Ìíœ
	inline void RemoveCollider(BaseCollider* collider)
	{
		colliders.remove(collider);
	}
	//SÄ‚ÌÕ“Ëƒ`FbN
	void CheckAllCollisions();
	//CLXg
	bool Raycast(const Ray& ray, RaycastHit* hitInfo = nullptr, float maxDistance = D3D12_FLOAT32_MAX);
private:
	CollisionManager() = default;
	CollisionManager(const CollisionManager&) = delete;
	~CollisionManager() = default;
	CollisionManager& operator = (const CollisionManager&) = delete;
	//RC_[ÌƒXg
	std::forward_list<BaseCollider*>colliders;
};


</file_content>

<file_content path="engine/collision/CollisionPrimitive.cpp">
#include "CollisionPrimitive.h"

void Triangle::ComputeNormal()
{
	Vector3 p0_p1 = p1 - p0;
	Vector3 p0_p2 = p2 - p0;
	Vector3 V;

	// OÏ‚É‚AQÓ‚ÉÈƒxNgZo
	normal = p0_p1.cross(p0_p2);
	normal.normalize();
}
</file_content>

<file_content path="engine/collision/CollisionPrimitive.h">
#pragma once
#pragma once
#include<DirectXMath.h>
#include "Vector3.h"

//
struct Sphere
{
	//SW
	Vector3 center = { 0,0,0 };
	//a
	float radius = 1.0f;
	//W
	Vector3 position = { 0,0,0 };
};
//
struct Plane
{
	//@xNg
	Vector3 normal = { 0,1,0 };
	//_(0,0,0)Ì‹
	float distance = 0.0f;
};
//C
struct Ray
{
	//n_W
	Vector3 start = { 0,0,0 };

	//
	Vector3 dir = { 1,0,0 };
};

//@tOp`(vè‚ª\)
class Triangle
{
public:
	//_3
	Vector3 p0;
	Vector3 p1;
	Vector3 p2;
	//@xNg
	Vector3 normal;

	//@ÌŒvZ
	void ComputeNormal();
};

class CollisionPrimitive
{
public:
};


</file_content>

<file_content path="engine/collision/CollisionTypes.h">
#pragma once

//Õ“Ë”pÌŒ^`

enum CollisionShapeType
{
	SHAPE_UNKNOWN = -1,//İ’

	COLLISIONSHAPE_SPHERE,//
};
</file_content>

<file_content path="engine/collision/RaycastHit.h">
#pragma once
#include "BaseCollider.h"
#include <DirectXMath.h>

class Object3d;

//CLXgÉ‚ğ“¾‚é‚½ß‚Ì\
struct RaycastHit
{
	//Õ“Ë‘ÌƒIuWFNg
	Object3d* object = nullptr;
	//Õ“Ë‘ÌƒRC_[
	BaseCollider* collider = nullptr;
	//Õ“Ë“_
	Vector3 inter;
	//Õ“Ë“_Ü‚Å‚Ì‹
	float distance = 0.0f;
};
</file_content>

<file_content path="engine/collision/SphereCollider.cpp">
#include "SphereCollider.h"

void SphereCollider::Update()
{
	// [hsñ‚©‚Wğ’Šo
	const Matrix4& matWorld = object3d->worldTransform_.matWorld_;

	const Vector3& position = { matWorld.m[3][0],matWorld.m[3][1] ,matWorld.m[3][2] };

	//Vector4 matVec;
	//matVec.x = matWorld.m[3][0];
	//matVec.y = matWorld.m[3][1];
	//matVec.z = matWorld.m[3][2];
	//matVec.w = matWorld.m[3][3];

	// ÌƒoÏXV
	Sphere::center = position + offset;
	Sphere::radius = radius;
}
</file_content>

<file_content path="engine/collision/SphereCollider.h">
#pragma once
#include "BaseCollider.h"
#include "CollisionPrimitive.h"

#include "Vector3.h"
#include "Matrix4.h"


class SphereCollider :public BaseCollider, public Sphere
{
private:// GCAX
public:
	SphereCollider(Vector3 offset = { 0,0,0 }, float radius = 1.0f) :offset(offset), radius(radius) {
		// `Zbg
		shapeType = COLLISIONSHAPE_SPHERE;
	}

	// XV
	void Update()override;

	inline const Vector3& GetOffset() { return offset; }

	inline void SetOffset(const Vector3& offset) { this->offset = offset; }

	inline float GetRadius() { return radius; }

	inline void SetRadius(float radius) { this->radius = radius; }

private:
	// IuWFNgSÌƒItZbg
	Vector3 offset;
	// a
	float radius;
};
</file_content>

<file_content path="engine/effect/Particle.cpp">
#include "Particle.h"
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <Windows.h>
#include <cassert>
#include <sstream>
#include <string>
#include <fstream>
#include <vector>

using namespace DirectX;
using namespace std;

//Ã“IoÏÌ
ID3D12Device* Particle::device_ = nullptr;
std::string Particle::defaultTextureDirectoryPath_ = "Resources/";

Particle* Particle::LoadParticleTexture(const std::string& fileName)
{
	//VModel^ÌƒCX^XÌƒm
	Particle* particle = new Particle();

	//fXNv^q[v
	particle->InitializeDescriptorHeap();

	//OBJt@CÌƒf[^Ç‚İ
	particle->LoadTexture(fileName);

	//Ç‚İñ‚¾ƒf[^ÉŠeobt@
	particle->CreateBuffers();

	return particle;
}

void Particle::InitializeDescriptorHeap()
{

	HRESULT result = S_FALSE;

	// fXNv^q[vğ¶	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//VF[_çŒ©æ‚¤
	descHeapDesc.NumDescriptors = 1; // VF[_[\[Xr[1
	result = device_->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap_));//
	if (FAILED(result)) {
		assert(0);
	}

	// fXNv^TCYæ“¾
	descriptorHandleIncrementSize_ = device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

void Particle::LoadTexture(const std::string& fileName)
{
	HRESULT result;

	//fBNgpXÆƒt@CAÄƒtpXğ“¾‚
	std::string fullPath = defaultTextureDirectoryPath_ + fileName;

	//ChÉ•ÏŠÛ‚Ì•obt@TCYvZ
	int filePathBufferSize = MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, nullptr, 0);

	//ChÉ•ÏŠ
	std::vector<wchar_t> wfilePath(filePathBufferSize);
	MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, wfilePath.data(), filePathBufferSize);

	//æ‘œt@CÌ—p
	TexMetadata metadata{};
	ScratchImage scratchImg{};
	//WICeNX`Ìƒ[h
	result = LoadFromWICFile(
		wfilePath.data(),	//ResourcestH_texture.png
		WIC_FLAGS_NONE,
		&metadata, scratchImg);

	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	//~bv}bv
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result))
	{
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}
	//Ç‚İñ‚¾ƒfBt[YeNX`SRGBÆ‚Äˆ
	metadata.format = MakeSRGB(metadata.format);

	// q[vİ’
	D3D12_HEAP_PROPERTIES textureHeapProp{};
	textureHeapProp.Type = D3D12_HEAP_TYPE_CUSTOM;
	textureHeapProp.CPUPageProperty =
		D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
	textureHeapProp.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;
	//\[Xİ’
	D3D12_RESOURCE_DESC textureResourceDesc{};
	textureResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	textureResourceDesc.Format = metadata.format;
	textureResourceDesc.Width = metadata.width;							//
	textureResourceDesc.Height = (UINT)metadata.height;				//
	textureResourceDesc.DepthOrArraySize = (UINT16)metadata.arraySize;
	textureResourceDesc.MipLevels = (UINT16)metadata.mipLevels;
	textureResourceDesc.SampleDesc.Count = 1;

	//eNX`obt@Ì
	result = device_->CreateCommittedResource(
		&textureHeapProp,
		D3D12_HEAP_FLAG_NONE,
		&textureResourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&texBuff_));
	assert(SUCCEEDED(result));

	for (size_t i = 0; i < metadata.mipLevels; i++)
	{
		//~bv}bvxwè‚µÄƒC[Wæ“¾
		const Image* img = scratchImg.GetImage(i, 0, 0);
		//eNX`obt@Éƒf[^]
		result = texBuff_->WriteToSubresource(
			(UINT)i,
			nullptr,							//SÌˆÖƒRs[
			img->pixels,						//f[^AhX
			(UINT)img->rowPitch,				//1CTCY
			(UINT)img->slicePitch				//1TCY
		);
		assert(SUCCEEDED(result));
	}


	//SRVq[vÌƒnhæ“¾
	cpuDescHandleSRV_ = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap_->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize_);
	gpuDescHandleSRV_ = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap_->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize_);

	//VF[_[\[Xr[İ’
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};				//İ’\
	srvDesc.Format = textureResourceDesc.Format;
	srvDesc.Shader4ComponentMapping =
		D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;	//2DeNX`
	srvDesc.Texture2D.MipLevels = textureResourceDesc.MipLevels;

	//nhÌwÊ’uÉƒVF[_[\[Xr[ì¬
	device_->CreateShaderResourceView(texBuff_.Get(), &srvDesc, cpuDescHandleSRV_);

}

void Particle::CreateBuffers()
{
	HRESULT result = S_FALSE;

	std::vector<VertexPosScale> realVertices;

	UINT sizeVB = static_cast<UINT>(sizeof(vertices_));

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// _obt@
	result = device_->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff_));
	assert(SUCCEEDED(result));

	// _obt@Ö‚Ìƒf[^]
	VertexPosScale* vertMap = nullptr;
	result = vertBuff_->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		memcpy(vertMap, vertices_, sizeof(vertices_));
		vertBuff_->Unmap(0, nullptr);
	}

	// _obt@r[Ìì¬
	vbView_.BufferLocation = vertBuff_->GetGPUVirtualAddress();
	vbView_.SizeInBytes = sizeof(vertices_);
	vbView_.StrideInBytes = sizeof(vertices_[0]);


}

void Particle::Update()
{
	HRESULT result;
	//sp[eBNSíœ
	particles_.remove_if([](OneParticle& x) {return x.frame >= x.num_frame; });
	//Sp[eBNXV
	for (std::forward_list<OneParticle>::iterator it = particles_.begin();
		it != particles_.end(); it++)
	{
		//oßƒt[JEg
		it->frame++;
		//xÉ‰xZ
		it->velocity = it->velocity + it->accel;
		//xÉ‚Ú“
		it->position = it->position + it->velocity;

		//isx0~1Ì”ÍˆÍ‚ÉŠZ
		float f = (float)it->frame / it->num_frame;
		//XP[Ì`
		it->scale = (it->e_Scale - it->s_Scale) * f;
		it->scale += it->s_Scale;
	}
	//_obt@Öƒf[^]
	VertexPosScale* vertMap = nullptr;
	result = vertBuff_->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result))
	{
		//p[eBNÌ1Â‚Â”f
		for (std::forward_list<OneParticle>::iterator it = particles_.begin();
			it != particles_.end(); it++)
		{
			//W
			vertMap->pos = it->position;
			//XP[
			vertMap->scale = it->scale;
			//Ì’_
			vertMap++;
		}
		vertBuff_->Unmap(0, nullptr);
	}

}

void Particle::Draw(ID3D12GraphicsCommandList* cmdList)
{
	// nullptr`FbN
	assert(device_);
	assert(cmdList);

	// _obt@Ìİ’
	cmdList->IASetVertexBuffers(0, 1, &vbView_);

	// fXNv^q[vÌ”z
	ID3D12DescriptorHeap* ppHeaps[] = { descHeap_.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	// VF[_\[Xr[Zbg
	cmdList->SetGraphicsRootDescriptorTable(1, gpuDescHandleSRV_);

	// `R}h
	cmdList->DrawInstanced((UINT)std::distance(particles_.begin(), particles_.end()), 1, 0, 0);

}

void Particle::Add(int life, XMFLOAT3 position, XMFLOAT3 velocity, XMFLOAT3 accel, float start_scale, float end_scale)
{
	//XgÉ—vfÇ‰
	particles_.emplace_front();
	//Ç‰vfÌQ
	OneParticle& p = particles_.front();
	//lZbg
	p.position = position;
	p.velocity = velocity;
	p.accel = accel;
	p.num_frame = life;

	p.s_Scale = start_scale;
	p.e_Scale = end_scale;
	p.scale = p.s_Scale;
}

const DirectX::XMFLOAT3 operator+(const DirectX::XMFLOAT3& lhs, const DirectX::XMFLOAT3& rhs)
{
	XMFLOAT3 result;

	result.x = lhs.x + rhs.x;
	result.y = lhs.y + rhs.y;
	result.z = lhs.z + rhs.z;
	return result;
}
</file_content>

<file_content path="engine/effect/Particle.h">
#pragma once
#include <d3d12.h>
#include <d3dx12.h>
#include <DirectXMath.h>
#include <wrl.h>
#include <forward_list>

class Particle
{
private://GCAX
	// Microsoft::WRL::È—
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::È—
	using XMFLOAT2 = DirectX::XMFLOAT2;
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMFLOAT4 = DirectX::XMFLOAT4;
	using XMMATRIX = DirectX::XMMATRIX;

public://TuNX

	struct VertexPosScale
	{
		XMFLOAT3 pos; // xyzW
		float scale;  //XP[
	};

	//p[eBNê—±
	struct OneParticle
	{
		//DirectX::È—
		using XMFLOAT3 = DirectX::XMFLOAT3;

		//W
		XMFLOAT3 position = {};
		//x
		XMFLOAT3 velocity = {};
		//x
		XMFLOAT3 accel = {};
		//İƒt[
		int frame = 0;
		//It[
		int num_frame = 0;

		//XP[
		float scale = 1.0f;
		//l
		float s_Scale = 1.0f;
		//ÅIl
		float e_Scale = 0.0f;
	};

private://è”
	static const int vertexCount = 1024;		// _

public://oÖ

	//OBJt@Cp[eBNfÇ‚İ
	static Particle* LoadParticleTexture(const std::string& fileName);
	// fXNv^q[vÌ
	void InitializeDescriptorHeap();
	// eNX`Ç‚İ
	void LoadTexture(const std::string& fileName);

	//eobt@
	void CreateBuffers();
	//XV
	void Update();
	// `
	void Draw(ID3D12GraphicsCommandList* cmdList);

	//p[eBNÌ’Ç‰
	void Add(int life, XMFLOAT3 position, XMFLOAT3 velocity, XMFLOAT3 accel,
		float start_scale, float end_scale);

private://oÏ
	// foCX
	static ID3D12Device* device_;
	//ftHgeNX`i[fBNg
	static std::string defaultTextureDirectoryPath_;

	// fXNv^TCY
	UINT descriptorHandleIncrementSize_;
	// fXNv^q[v
	ComPtr<ID3D12DescriptorHeap> descHeap_;
	// eNX`obt@
	ComPtr<ID3D12Resource> texBuff_;
	// VF[_\[Xr[Ìƒnh(CPU)
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuDescHandleSRV_;
	// VF[_\[Xr[Ìƒnh(CPU)
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuDescHandleSRV_;
	// _obt@
	ComPtr<ID3D12Resource> vertBuff_;
	// _obt@r[
	D3D12_VERTEX_BUFFER_VIEW vbView_;
	//_f[^z
	VertexPosScale vertices_[vertexCount];

	std::forward_list<OneParticle> particles_;

public://setter
	//foCX
	static void SetDevice(ID3D12Device* device) { Particle::device_ = device; }

};

const DirectX::XMFLOAT3 operator+(const DirectX::XMFLOAT3& lhs, const DirectX::XMFLOAT3& rhs);
</file_content>

<file_content path="engine/effect/ParticleManager.cpp">
#include "ParticleManager.h"
#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;

/// Ã“IoÏÌ
ID3D12Device* ParticleManager::device_ = nullptr;
ID3D12GraphicsCommandList* ParticleManager::cmdList = nullptr;
ComPtr<ID3D12RootSignature> ParticleManager::rootsignature;
ComPtr<ID3D12PipelineState> ParticleManager::pipelinestate;

void ParticleManager::StaticInitialize(ID3D12Device* device)
{
	// nullptr`FbN
	assert(device);

	device_ = device;

	Particle::SetDevice(device_);

	// pCvC
	InitializeGraphicsPipeline();
}

void ParticleManager::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	// PreDrawPostDrawyAÅŒÄ‚Î‚Ä‚È‚ÎƒG[
	assert(ParticleManager::cmdList == nullptr);

	// R}hXgZbg
	ParticleManager::cmdList = cmdList;

	// pCvCXe[gÌİ’
	cmdList->SetPipelineState(pipelinestate.Get());
	// [gVOl`Ìİ’
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// v~eBu`İ’
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_POINTLIST);
}

void ParticleManager::PostDraw()
{
	// R}hXg
	ParticleManager::cmdList = nullptr;
}

ParticleManager* ParticleManager::Create()
{
	// 3DIuWFNgÌƒCX^Xğ¶
	ParticleManager* object3d = new ParticleManager();
	if (object3d == nullptr) {
		return nullptr;
	}

	// 
	if (!object3d->Initialize()) {
		delete object3d;
		assert(0);
		return nullptr;
	}

	return object3d;
}

void ParticleManager::InitializeGraphicsPipeline()
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // _VF[_IuWFNg
	ComPtr<ID3DBlob> gsBlob; // WIgVF[_IuWFNg
	ComPtr<ID3DBlob> psBlob;	// sNZVF[_IuWFNg
	ComPtr<ID3DBlob> errorBlob; // G[IuWFNg

	// _VF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticleVS.hlsl",	// VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "vs_5_0",	// Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// WIgVF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticleGS.hlsl", // VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "gs_5_0", // Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobNpİ’
		0,
		&gsBlob, &errorBlob
	);
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "/n";
		//G[eoÍƒEBhEÉ•\
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}
	// sNZVF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticlePS.hlsl",	// VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "ps_5_0",	// Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// _CAEg
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyW(1sÅÙ‚â‚·)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{//XP[
			"TEXCOORD", 0, DXGI_FORMAT_R32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

	};

	// OtBbNXpCvCÌ—İ’
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.GS = CD3DX12_SHADER_BYTECODE(gsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// Tv}XN
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // Wİ’
	// X^CUXe[g
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// fvXXeVXe[g
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	//fvXÌİ‚Ö~
	gpipeline.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	// _[^[QbgÌƒuhİ’
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGASÄ‚Ìƒ`l`
	blenddesc.BlendEnable = true;
	//
	/*blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;*/

	//Z
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_ONE;
	blenddesc.DestBlend = D3D12_BLEND_ONE;
	//Z
	/*blenddesc.BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
	blenddesc.SrcBlend = D3D12_BLEND_ONE;
	blenddesc.DestBlend = D3D12_BLEND_ONE;*/

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// uhXe[gÌİ’
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// [xobt@ÌƒtH[}bg
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// _CAEgÌİ’
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// }`ÌŒ`İ’iOp`j
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;

	gpipeline.NumRenderTargets = 1;	// `ÎÛ‚1
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0`255wRGBA
	gpipeline.SampleDesc.Count = 1; // 1sNZÉ‚Â‚1TvO

	// fXNv^W
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 WX^

	// [gp[^
	#pragma warning(push)
	#pragma warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[2];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// X^eBbNTv[
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// [gVOl`Ìİ’
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// o[WÌƒVACY
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// [gVOl`Ì
	result = device_->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// OtBbNXpCvCÌ
	result = device_->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}


bool ParticleManager::Initialize()
{
	// nullptr`FbN
	assert(device_);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferData) + 0xff) & ~0xff);

	HRESULT result;

	// è”obt@Ì
	result = device_->CreateCommittedResource(
		&heapProps, // Abv[hÂ”\
		D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));

	return true;
}

void ParticleManager::Update()
{

	HRESULT result;

	particle->Update();
	XMMATRIX matView = xmViewProjection->GetMatViewProjection();
	XMMATRIX matBillboard = xmViewProjection->GetMatBillboard();

	// è”obt@Öƒf[^]
	ConstBufferData* constMap = nullptr;
	result = constBuff->Map(0, nullptr, (void**)&constMap);
	//sÌ
	constMap->mat = matView;
	constMap->matBillboard = matBillboard;
	constBuff->Unmap(0, nullptr);
}

void ParticleManager::Draw()
{
	// nullptr`FbN
	assert(device_);
	assert(ParticleManager::cmdList);

	// è”obt@r[Zbg
	cmdList->SetGraphicsRootConstantBufferView(0, constBuff->GetGPUVirtualAddress());

	particle->Draw(cmdList);
}

void ParticleManager::Fire(Particle* particle, const float& setpos, const float& setvel, const float& setacc, const int& setnum, const XMFLOAT2& setscale)
{
	for (int i = 0; i < setnum; i++)
	{
		//X,Y,ZS{-20.0f,20.0f}Åƒ_É•z
		const float md_pos = setpos;
		XMFLOAT3 pos{};
		pos.x = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		pos.y = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		pos.z = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		//X,Y,ZS{0.1f,0.1f}Åƒ_É•z
		const float md_vel = setvel;
		XMFLOAT3 vel{};
		vel.x = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		vel.y = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		vel.z = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		//dÍ‚ÉŒÄ‚YÌ‚{0.001f,0}Åƒ_É•z
		XMFLOAT3 acc{};
		const float md_acc = setacc;
		acc.y = -(float)rand() / RAND_MAX * md_acc;

		//Ç‰
		particle->Add(60, pos, vel, acc, setscale.x, setscale.y);
	}
}
</file_content>

<file_content path="engine/effect/ParticleManager.h">
#pragma once

#include "Particle.h"
#include "XMViewProjection.h"
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include <d3dx12.h>

/// 3DIuWFNg
class ParticleManager
{
private: // GCAX
	// Microsoft::WRL::È—
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::È—
	using XMFLOAT2 = DirectX::XMFLOAT2;
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMFLOAT4 = DirectX::XMFLOAT4;
	using XMMATRIX = DirectX::XMMATRIX;

public: // TuNX
	// è”obt@pf[^\
	struct ConstBufferData
	{
		//XMFLOAT4 color;	// F (RGBA)
		XMMATRIX mat;	// RcÏŠs
		XMMATRIX matBillboard;	//r{[hs
	};
public: // Ã“IoÖ
	/// Ã“I
	static void StaticInitialize(ID3D12Device* device);

	/// `O
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);

	/// `ãˆ
	static void PostDraw();

	/// 3DIuWFNg
	static ParticleManager* Create();

private: // Ã“IoÏ
	// foCX
	static ID3D12Device* device_;
	// R}hXg
	static ID3D12GraphicsCommandList* cmdList;
	// [gVOl`
	static ComPtr<ID3D12RootSignature> rootsignature;
	// pCvCXe[gIuWFNg
	static ComPtr<ID3D12PipelineState> pipelinestate;

private:// Ã“IoÖ

	/// OtBbNpCvC
	static void InitializeGraphicsPipeline();

public: // oÖ
	bool Initialize();
	/// t[
	void Update();

	/// `
	void Draw();

	/// p[eBN
	void Fire(Particle* particle, const float& setpos, const float& setvel, const float& setacc, const int& setnum, const XMFLOAT2& setscale);

private: // oÏ
	ComPtr<ID3D12Resource> constBuff; // è”obt@
	//XP[
	XMFLOAT3 scale = { 1,1,1 };

	//DirectXMathgViewProjection
	XMViewProjection* xmViewProjection = nullptr;
	//p[eBN
	Particle* particle = nullptr;

public://setter
	//p[eBNf
	void SetParticleModel(Particle* particlemodel) { this->particle = particlemodel; }
	//J
	void SetXMViewProjection(XMViewProjection* xmViewProjection) { this->xmViewProjection = xmViewProjection; }
};
</file_content>

<file_content path="engine/effect/PostEffect.cpp">
#include "PostEffect.h"
#include "WinApp.h"

const float PostEffect::clearColor[4] = { 0.25f,0.5f,0.1f,0.0f };

void PostEffect::Initialize(ID3D12Device* dev)
{
	device = dev;
	HRESULT result;

	//_f[^
	VertexPosUv vertices[] = {
		{{	-1.0f, -1.0f,	0.0f},{0.0f,1.0f}},
		{{	-1.0f,	+1.0f,	0.0f},{0.0f,0.0f}},
		{{	+1.0f, -1.0f,	0.0f},{1.0f,1.0f}},
		{{	+1.0f,	+1.0f,	0.0f},{1.0f,0.0f}},
	};

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapPropsVertexBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDescVertexBuffer =
		CD3DX12_RESOURCE_DESC::Buffer(sizeof(vertices));

	//_obt@
	result = device->CreateCommittedResource(
		&heapPropsVertexBuffer, // q[vİ’
		D3D12_HEAP_FLAG_NONE,
		&resourceDescVertexBuffer, // \[Xİ’
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	//_obt@Ö‚Ìƒf[^]
	VertexPosUv* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	vertBuff->Unmap(0, nullptr);

	// _obt@r[Ìì¬
// GPUzAhX
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	// _obt@ÌƒTCY
	vbView.SizeInBytes = sizeof(VertexPosUv) * 4;
	// _1Â•Ìƒf[^TCY
	vbView.StrideInBytes = sizeof(VertexPosUv);

	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapPropsConstantBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// \[Xİ’
	CD3DX12_RESOURCE_DESC resourceDescConstantBuffer =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferData) + 0xff) & ~0xff);

	// è”obt@Ì
	result = device->CreateCommittedResource(
		&heapPropsConstantBuffer, // q[vİ’
		D3D12_HEAP_FLAG_NONE,
		&resourceDescConstantBuffer, // \[Xİ’
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));

	// è”obt@Éƒf[^]
	ConstBufferData* constMap = nullptr;
	result = this->constBuff->Map(0, nullptr, (void**)&constMap); // }bsO
	if (SUCCEEDED(result)) {
		constMap->color = this->color;
		constMap->mat = this->mat.identity();
		this->constBuff->Unmap(0, nullptr);
	}


	//eNX`\[Xİ’
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
		WinApp::window_width, (UINT)WinApp::window_height,
		1, 0, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);
	// q[vvpeB
	CD3DX12_HEAP_PROPERTIES heapPropsTex = CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);
	CD3DX12_CLEAR_VALUE valTex = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, clearColor);

	//eNX`obt@Ì
	result = device->CreateCommittedResource(
		&heapPropsTex, D3D12_HEAP_FLAG_NONE,
		&texresDesc, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		&valTex, IID_PPV_ARGS(&texBuff));
	assert(SUCCEEDED(result));

	const UINT pixelCount = WinApp::window_width * WinApp::window_height;
	const UINT rowPitch = sizeof(UINT) * WinApp::window_width;
	const UINT depthPitch = rowPitch * WinApp::window_height;
	//æ‘œC[W
	UINT* img = new UINT[pixelCount];
	for (int i = 0; i < pixelCount; i++) {
		img[i] = 0xff0000ff;
	}
	//eNX`obt@Éƒf[^]
	result = texBuff->WriteToSubresource(0, nullptr, img, rowPitch, depthPitch);
	assert(SUCCEEDED(result));
	delete[] img;
	//SRVpfXNv^q[vİ’
	D3D12_DESCRIPTOR_HEAP_DESC srvDescHeapDesc = {};
	srvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	srvDescHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	srvDescHeapDesc.NumDescriptors = 1;
	//SRVpfXNv^q[vğ¶
	result = device->CreateDescriptorHeap(&srvDescHeapDesc, IID_PPV_ARGS(&descHeapSRV));
	assert(SUCCEEDED(result));
	//SRVÌİ’
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;
	//fXNv^q[vSRVì¬
	device->CreateShaderResourceView(texBuff.Get(), &srvDesc, descHeapSRV->GetCPUDescriptorHandleForHeapStart());
	
	//RTVpfXNv^q[vİ’
	D3D12_DESCRIPTOR_HEAP_DESC rtvDescHeapDesc{};
	rtvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvDescHeapDesc.NumDescriptors = 1;
	//RTVpfXNv^[q[vğ¶
	result = device->CreateDescriptorHeap(&rtvDescHeapDesc, IID_PPV_ARGS(&descHeapRTV));
	assert(SUCCEEDED(result));
	//_[^[Qbgr[Ìİ’
	D3D12_RENDER_TARGET_VIEW_DESC renderTargetViewDesc{};
	//VF[_[ÌŒvZÊ‚SRGBÉ•ÏŠÄ
	renderTargetViewDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	renderTargetViewDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
	//fXNv^[q[vRTVì¬
	device->CreateRenderTargetView(texBuff.Get(), &renderTargetViewDesc, descHeapRTV->GetCPUDescriptorHandleForHeapStart());

	//[xobt@\[Xİ’
	CD3DX12_RESOURCE_DESC depthResDesc =
		CD3DX12_RESOURCE_DESC::Tex2D(
			DXGI_FORMAT_D32_FLOAT, WinApp::window_width, WinApp::window_height,
			1, 0, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL
		);

	CD3DX12_CLEAR_VALUE valDepth = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_D32_FLOAT, 1.0f, 0);
	//[xobt@Ì
	CD3DX12_HEAP_PROPERTIES heapPropsDepth = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
	result = device->CreateCommittedResource(&heapPropsDepth, D3D12_HEAP_FLAG_NONE,
		&depthResDesc, D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&valDepth,
		IID_PPV_ARGS(&depthBuff));
	assert(SUCCEEDED(result));

	//DSVpfXNv^q[vİ’
	D3D12_DESCRIPTOR_HEAP_DESC DescHeapDesc{};
	DescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	DescHeapDesc.NumDescriptors = 1;

	//DSVpfXNv^q[vì¬
	result = device->CreateDescriptorHeap(&DescHeapDesc, IID_PPV_ARGS(&descHeapDSV));
	//fXNv^q[vDSVì¬
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	device->CreateDepthStencilView(depthBuff.Get(), &dsvDesc, descHeapDSV->GetCPUDescriptorHandleForHeapStart());
	
	CreateGraphicsPipelineState();

}

void PostEffect::Draw(ID3D12GraphicsCommandList* cmdList_)
{
	this->cmdList = cmdList_;
	 
	// pCvCXe[gÆƒ[gVOl`Ìİ’R}h
	cmdList->SetPipelineState(pipelinestate.Get());
	cmdList->SetGraphicsRootSignature(rootsignature.Get());

	// v~eBu`Ìİ’R}h
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); // Op`Xg

	//eNX`pÅƒXNv^q[vÌİ’
	ID3D12DescriptorHeap* ppHeaps[] = { descHeapSRV.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	// _obt@Ìİ’R}h
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	// è”obt@(CBV)Ìİ’R}h
	cmdList->SetGraphicsRootConstantBufferView(0, constBuff->GetGPUVirtualAddress());

	//VF[_[\[Xr[Zbg
	cmdList->SetGraphicsRootDescriptorTable(
		1, descHeapSRV->GetGPUDescriptorHandleForHeapStart());

	//|SÌ•`
	cmdList->DrawInstanced(4, 1, 0, 0);
}

void PostEffect::PreDrawScene(ID3D12GraphicsCommandList* cmdList_)
{
	CD3DX12_RESOURCE_BARRIER rb = CD3DX12_RESOURCE_BARRIER::Transition(texBuff.Get(),
		D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		D3D12_RESOURCE_STATE_RENDER_TARGET);
	cmdList_->ResourceBarrier(1, &rb);

	//_[^[Qbgr[pfXNv^q[vÌƒnhæ“¾
	D3D12_CPU_DESCRIPTOR_HANDLE rtvH =
		descHeapRTV->GetCPUDescriptorHandleForHeapStart();
	//[xXeVr[pfXNv^q[vÌƒnhæ“¾
	D3D12_CPU_DESCRIPTOR_HANDLE dsvH =
		descHeapDSV->GetCPUDescriptorHandleForHeapStart();
	//_[^[QbgZbg
	cmdList_->OMSetRenderTargets(1, &rtvH, false, &dsvH);
	//r[|[gÌİ’
	CD3DX12_VIEWPORT vp = CD3DX12_VIEWPORT(0.0f, 0.0f, WinApp::window_width, WinApp::window_height);
	cmdList_->RSSetViewports(1, &vp);
	//SÊƒNA
	cmdList_->ClearRenderTargetView(rtvH, clearColor, 0, nullptr);
	cmdList_->ClearDepthStencilView(dsvH, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
}

void PostEffect::PostDrawScene(ID3D12GraphicsCommandList* cmdList_)
{
	//\[XoAÏX(`Â”\->VF[_[\[X)
	CD3DX12_RESOURCE_BARRIER rb = CD3DX12_RESOURCE_BARRIER::Transition(texBuff.Get(),
		D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
	cmdList_->ResourceBarrier(1, &rb);
}

void PostEffect::CreateGraphicsPipelineState()
{
	HRESULT result;
	//pCvC
	ComPtr<ID3DBlob> vsBlob; // _VF[_IuWFNg
	ComPtr<ID3DBlob> psBlob; // sNZVF[_IuWFNg
	ComPtr<ID3DBlob> errorBlob; // G[IuWFNg

	// _VF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/Shaders/PostEffectVS.hlsl", // VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "vs_5_0", // Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&vsBlob, &errorBlob);

	// G[È‚
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// sNZVF[_Ì“Ç‚İİ‚ÆƒRpC
	result = D3DCompileFromFile(
		L"Resources/Shaders/PostEffectPS.hlsl",   // VF[_t@C
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // CN[hÂ”\É‚
		"main", "ps_5_0", // Gg[|CgAVF[_[fw
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // fobOpİ’
		0,
		&psBlob, &errorBlob);

	// G[È‚
	if (FAILED(result)) {
		// errorBlobG[estring^ÉƒRs[
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// G[eoÍƒEBhEÉ•\
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// _CAEg
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyzW(1sÅÙ‚â‚·)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

		{ // uvW(1sÅÙ‚â‚·)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// fXNv^WÌİ’
	CD3DX12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

	CD3DX12_ROOT_PARAMETER rootParams[2];
	rootParams[0].InitAsConstantBufferView(0);
	rootParams[1].InitAsDescriptorTable(1, &descriptorRange, D3D12_SHADER_VISIBILITY_ALL);

	// X^eBbNTv[Ìİ’
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //JÔ‚i^COj
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //cJÔ‚i^COj
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_BORDER; //sJÔ‚i^COj
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK; //{[_[ÌÍ
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; //SÄƒjA
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX; //~bv}bvÅ‘l
	samplerDesc.MinLOD = 0.0f; //~bv}bvÅl
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; //sNZVF[_Ì‚İgpÂ”\

	// OtBbNXpCvCİ’
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	// VF[_[Ìİ’
	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	// Tv}XNÌİ’
	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // Wİ’

	// X^CUÌİ’
	pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;  // JOÈ‚
	//pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // |ShÂ‚Ô‚
	//pipelineDesc.RasterizerState.DepthClipEnable = true; // [xNbsOL

	// _[^[QbgÌƒuhİ’
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; // RBGASÄ‚Ìƒ`l`

	blenddesc.BlendEnable = true;                   // uhLÉ‚
	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;    // Z
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;      // \[XÌ’l100% g
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;    // fXgÌ’l  0% g

	// 
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;             // Z
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;         // \[XÌƒAt@l
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;    // 1.0f-\[XÌƒAt@l

	// _CAEgÌİ’
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// }`ÌŒ`İ’
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// Ì‘Ìİ’
	pipelineDesc.NumRenderTargets = 1; // `ÎÛ‚1
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0`255wRGBA
	pipelineDesc.SampleDesc.Count = 1; // 1sNZÉ‚Â‚1TvO

	//fvXXeVXe[gÌİ’
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS; // Éã‘[

	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthEnable = false;

	// [gVOl`Ìİ’
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams; //[gp[^Ìæ“ªAhX
	rootSignatureDesc.NumParameters = _countof(rootParams);        //[gp[^

	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// pCvCÆƒ[gVOl`ÌƒZbg

	ComPtr<ID3DBlob> rootSigBlob;
	// o[WÅ‚ÌƒVACY
	result = D3D12SerializeRootSignature(
		&rootSignatureDesc,
		D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob,
		&errorBlob);
	assert(SUCCEEDED(result));
	// [gVOl`Ì
	result = device->CreateRootSignature(
		0,
		rootSigBlob->GetBufferPointer(),
		rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	// pCvCÉƒ[gVOl`Zbg
	pipelineDesc.pRootSignature = rootsignature.Get();

	// pCvXe[gÌ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));
}

</file_content>

<file_content path="engine/effect/PostEffect.h">
#pragma once
#include <Windows.h>
#include <D3dx12.h>
#include <d3dcompiler.h>
#include <cassert>
#include <DirectXTex.h>
#include <wrl.h>
#include <array>
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include"Matrix4.h"

#include "DirectXCommon.h"

#pragma comment(lib, "d3dcompiler.lib")

struct VertexPosUv {
	Vector3 pos;
	Vector2 uv;
};
class PostEffect
{
public:
	//
	void Initialize(ID3D12Device* dev);
	//`
	void Draw(ID3D12GraphicsCommandList* cmdList_);
	//`O
	void PreDrawScene(ID3D12GraphicsCommandList* cmdList_);
	void PostDrawScene(ID3D12GraphicsCommandList* cmdList_);
	//pCvC
	void CreateGraphicsPipelineState();


private:
	static const float clearColor[4];

private:
	//eNX`obt@
	ComPtr<ID3D12Resource> texBuff;
	//[xobt@
	ComPtr<ID3D12Resource> depthBuff;
	//SRVpfXNv^q[v
	ComPtr<ID3D12DescriptorHeap> descHeapSRV;
	//RTVpfXNv^q[v
	ComPtr<ID3D12DescriptorHeap> descHeapRTV;
	//DSVpfXNv^q[v
	ComPtr<ID3D12DescriptorHeap> descHeapDSV;
	//[gVOl`
	ComPtr<ID3D12RootSignature> rootsignature;
	//pCvC
	ComPtr<ID3D12PipelineState> pipelinestate;
	//cmdList
	ComPtr<ID3D12GraphicsCommandList> cmdList;
	//Device
	ComPtr<ID3D12Device> device;
	//_obt@
	ComPtr<ID3D12Resource> vertBuff;
	//_obt@r[
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	//è”obt@
	ComPtr<ID3D12Resource> constBuff;
	//è”obt@pf[^\
	struct ConstBufferData {
		Vector4 color; // F (RGBA)
		Matrix4 mat; //W
	};
	Vector4 color = { 1,1,1,1 }; // F (RGBA)
	Matrix4 mat; //W
};


</file_content>

<file_content path="engine/math/Matrix4.cpp">
// ========================
// Matrix4 ^ Matrix4.cpp
// ========================
#include "Matrix4.h"
#include "Vector3.h"
#include <cmath> // sin cos

const float EPSILON = 0.000001f;

Matrix4::Matrix4()
{
	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};
	// 
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}
}

// 
Matrix4::Matrix4(float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33)
{
	m[0][0] = m00, m[0][1] = m01, m[0][2] = m02, m[0][3] = m03,
		m[1][0] = m10, m[1][1] = m11, m[1][2] = m12, m[1][3] = m13,
		m[2][0] = m20, m[2][1] = m21, m[2][2] = m22, m[2][3] = m23,
		m[3][0] = m30, m[3][1] = m31, m[3][2] = m32, m[3][3] = m33;

}

// PÊsß‚
Matrix4 Matrix4::identity()
{
	static const Matrix4 result
	{
		1.0f, 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f, 0.0f, 0.0f,
		0.0f, 0.0f, 1.0f, 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	};

	return result;
}

// tsß‚
Matrix4 Matrix4::MakeInverse()
{
	Matrix4 temp;
	float mat[4][8] = { 0 };

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			mat[i][j] = m[i][j];
		}
	}

	mat[0][4] = 1;
	mat[1][5] = 1;
	mat[2][6] = 1;
	mat[3][7] = 1;

	for (int n = 0; n < 4; n++) {
		//Å‘ÌÎ’lT(Æ‚è‚ ÎÛÅ‘Æ‰è‚µÄ‚)
		float max = abs(mat[n][n]);
		int maxIndex = n;

		for (int i = n + 1; i < 4; i++) {
			if (abs(mat[i][n]) > max) {
				max = abs(mat[i][n]);
				maxIndex = i;
			}
		}

		float a = abs(mat[maxIndex][n]);
		//Å‘ÌÎ’l0tsÍ‹ß‚È‚
		if (abs(mat[maxIndex][n]) <= EPSILON) {
			return temp; //Æ‚è‚ PÊsÔ‚á‚¤
		}

		//Ö‚
		if (n != maxIndex) {
			for (int i = 0; i < 8; i++) {
				float f = mat[maxIndex][i];
				mat[maxIndex][i] = mat[n][i];
				mat[n][i] = f;
			}
		}

		//|1É‚È‚lZo
		float mul = 1 / mat[n][n];

		//|
		for (int i = 0; i < 8; i++) {
			mat[n][i] *= mul;
		}

		//S0É‚
		for (int i = 0; i < 4; i++) {
			if (n == i) {
				continue;
			}

			float mul = -mat[i][n];

			for (int j = 0; j < 8; j++) {
				mat[i][j] += mat[n][j] * mul;
			}
		}
	}

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++)
		{
			temp.m[i][j] = mat[i][j + 4];
		}
	}

	*this = temp;

	return *this;
}

// gksß‚
Matrix4 Matrix4::scale(const Vector3& s) {
	float result[4][4]
	{
		s.x ,0.0f,0.0f,0.0f,
		0.0f,s.y ,0.0f,0.0f,
		0.0f,0.0f,s.z ,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// 
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// xÜ‚Ì‰]sß‚
Matrix4 Matrix4::rotateX(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f, cos, sin,0.0f,
		0.0f,-sin, cos,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// 
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// yÜ‚Ì‰]sß‚
Matrix4 Matrix4::rotateY(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		cos ,0.0f,-sin,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		sin ,0.0f, cos,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// 
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// zÜ‚Ì‰]Ìsß‚
Matrix4 Matrix4::rotateZ(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		cos , sin,0.0f,0.0f,
		-sin, cos,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// 
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// sÚ“sÌİ’
Matrix4 Matrix4::translate(const Vector3& t)
{
	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		t.x ,t.y ,t.z ,1.0f
	};

	// 
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// WÏŠixNgÆsÌŠ|ZjstransformÖì¬B@iÏŠÉ‚Î‰Ä‚j
Vector3 Matrix4::transform(const Vector3& v, const Matrix4& m)
{
	float w = v.x * m.m[0][3] + v.y * m.m[1][3] + v.z * m.m[2][3] + m.m[3][3];

	Vector3 result
	{
		(v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0] + m.m[3][0]) / w,
		(v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1] + m.m[3][1]) / w,
		(v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2] + m.m[3][2]) / w
	};

	return result;
}

// r[sÌì¬
Matrix4 Matrix4::ViewMat(Vector3 eye, Vector3 target, Vector3 up)
{
	Vector3 zaxis = target - eye;
	zaxis.normalize();
	Vector3 xaxis = up.cross(zaxis);
	xaxis.normalize();
	Vector3 yaxis = zaxis.cross(xaxis);
	yaxis.normalize();

	Matrix4 LookAt = {
		xaxis.x,	xaxis.y,	xaxis.z,	0,
		yaxis.x,	yaxis.y,	yaxis.z,	0,
		zaxis.x,	zaxis.y,	zaxis.z,	0,
		eye.x,		eye.y,		eye.z,		1
	};

	LookAt.MakeInverse();

	*this = LookAt;

	return *this;
}

// Ë‰esÌì¬
Matrix4 Matrix4::ProjectionMat(float fovAngleY, float aspectRatio, float nearZ, float farZ)
{
	float h = 1 / tanf(fovAngleY / 2);
	float w = h / aspectRatio;
	float a = farZ / (farZ - nearZ);
	float b = (-nearZ * farZ) / (farZ - nearZ);

	Matrix4 perspectiveFovLH = {
		w,		 0,		 0,		 0,
		0,		 h,		 0,		 0,
		0,		 0,		 a,		 1,
		0,		 0,		 b,		 0
	};

	*this = perspectiveFovLH;

	return *this;
}

Matrix4 Matrix4::ViewPortMat(float width, float height, Vector2 offset)
{
	float w = width / 2;
	float h = height / 2;
	float a = width / 2 + offset.x;
	float b = height / 2 + offset.y;

	Matrix4 projectiveTlansformationLH = {
		w,		 0,		 0,		 0,
		0,		 -h,		 0,		 0,
		0,		 0,		 1,		 0,
		a,		 b,		 0,		 1
	};

	*this = projectiveTlansformationLH;

	return *this;
}

// Zq@*=@I[o[[hÖisÆsÌÏj
Matrix4& Matrix4::operator*=(const Matrix4& m1)
{
	Matrix4 result;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			float Total = 0.0f;
			for (int k = 0; k < 4; k++) {
				Total += m[i][k] * m1.m[k][j];
			}
			result.m[i][j] = Total;
		}
	}

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result.m[i][j];
		}
	}

	return *this;
}

// QZq@*@ÌƒI[o[[hÖisÆsÌÏj
Matrix4 Matrix4::operator*(const Matrix4& m1)
{
	return *this *= m1;
}

// QZq@*@ÌƒI[o[[hÖixNgÆsÌÏj
Vector3 operator*(const Vector3& v, const Matrix4& m)
{
	float W = v.x * m.m[0][3] + v.y * m.m[1][3] + v.z * m.m[2][3] + m.m[3][3];
	Vector3 result
	{
		(v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0] + m.m[3][0]) / W,
		(v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1] + m.m[3][1]) / W,
		(v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2] + m.m[3][2]) / W
	};
	return result;
}

float Matrix4::ConvertToRadian(float rad) {
	return rad * ((float)3.141592 / 180);
}
</file_content>

<file_content path="engine/math/Matrix4.h">
// ===============================
// Matrix4 ^ Matrix4.h
// ===============================
#pragma once

#include "Vector3.h"
#include "Vector2.h"

class Matrix4
{
public:

	// Matrix4 \
	float m[4][4];


	// RXgN^
	Matrix4();
	// wè‚µÄ‚Ì
	Matrix4(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33);

	// PÊsß‚
	static Matrix4 identity();

	// tsß‚
	Matrix4 MakeInverse();

	// gksÌİ’
	Matrix4 scale(const Vector3& s);

	// ]sÌİ’
	Matrix4 rotateX(float angle);
	Matrix4 rotateY(float angle);
	Matrix4 rotateZ(float angle);

	// sÚ“sÌì¬
	Matrix4 translate(const Vector3& t);

	// WÏŠixNgÆsÌŠ|Zj
	Vector3 transform(const Vector3& v, const Matrix4& m);

	// r[sì¬
	Matrix4 ViewMat(Vector3 eye, Vector3 target, Vector3 up);

	// Ë‰esì¬
	Matrix4 ProjectionMat(float fovAngleY, float aspectRatio, float nearZ, float farZ);
	Matrix4 ViewPortMat(float width, float height, Vector2 offset);

	// ZqI[o[[h
	Matrix4& operator*=(const Matrix4& m1);

	Matrix4 operator*(const Matrix4& m1);

	static float ConvertToRadian(float rad);

};

	// 2ZqI[o[[h
	Vector3 operator*(const Vector3& v, const Matrix4& m);


</file_content>

<file_content path="engine/math/Spline.cpp">
#include "Spline.h"
#include <windows.h>
#include <sysinfoapi.h>

void Spline::Initialize() {
	isEnd = false;
	t = 0.0f;
}

Vector3 Spline::Update(std::vector<Vector3>& points, float val) {

	t = t + val;

	//timeRate1.0fÈÉ‚È‚AÌ‹Ô‚Éi
	if (t >= 1.0f) {
		if (startIndex < points.size() - 3) {

			startIndex++;

			t -= 1.0f;
			integer += 1.0f;
		}
		else {
			isEnd = true;
			t = 1.0f;
		}
	}

	Vector3 pos = SplinePosition(points, startIndex, t);

	t += (float)0.002;
	//float integer = (float)floor(val);
	//float few = (float)fmod(val, 1);

	//Vector3 pos = SplinePosition(points, (size_t)integer, few);

	//if (integer >= (float)points.size() - 3.0f) {
	//	isEnd = true;
	//}
	
	return pos;
}

Vector3 Spline::EnemyPosition(std::vector<Vector3>& points, float val)
{
	float integer = (float)floor(val);
	float few = (float)fmod(val, 1);

	Vector3 pos = SplinePosition(points, (size_t)integer, few);

	return pos;
}

Vector3 Spline::pointCal(std::vector<Vector3>& points) {

	const int INDEXMAX = (int)points.size() - 1;

	float nowPoint = (float)startIndex / (float)INDEXMAX;

	Vector3 pos = SplinePosition(points, startIndex, t);

	if (t >= 1) {
		startIndex++;
		t = 0;
	}
	else {
		t += 0.01f;
	}

	return pos;
}

void Spline::Reset()
{			 
	t = 0;
	integer = 0;
	startIndex = 1;
}

Vector3 Spline::SplinePosition(const std::vector<Vector3>& points, size_t startIndex, float t) {
	//Ô‚×‚_
	size_t n = points.size() - 2;

	if (startIndex > n) return points[n];
	if (startIndex < 1) return points[1];

	//p0~p3Ì_æ“¾
	Vector3 p0_ = points[startIndex - 1];
	Vector3 p1_ = points[startIndex];
	Vector3 p2_ = points[startIndex + 1];
	Vector3 p3_ = points[startIndex + 2];

	//Catmull-Rom ÌÉ‚
	Vector3 position = 0.5 * (p1_ * 2 + (-p0_ + p2_) *
							  t + (p0_ * 2 - p1_ * 5 + p2_ * 4 - p3_) *
							  (t * t) + (-p0_ + p1_ * 3 - p2_ * 3 + p3_) *
							  (t * t * t));

	return position;
}
</file_content>

<file_content path="engine/math/Spline.h">
#pragma once

#include "Vector3.h"
#include <Vector>

class Spline 
{
public:
	//
	void Initialize();

	//XV
	Vector3 Update(std::vector<Vector3>& points,float val);

	Vector3 EnemyPosition(std::vector<Vector3>& points, float val);

	//XV
	Vector3 pointCal(std::vector<Vector3>& points);

	void Reset();

	//_ÌW(vectorRei)AÔ‚Ô‚Ì“YAÔŒoß—
	Vector3 SplinePosition(const std::vector<Vector3>& point, size_t startIndex, float t);

	bool GetIsEnd() { return isEnd; }
	float GetT() { return t + integer; }

private:
	//P1X^[g
	size_t startIndex = 1;
	bool isEnd = false;
	float t = 0;
	float integer = 0;


	//ÌˆÊ’u
	Vector3 position;
};
</file_content>

<file_content path="engine/math/Vector2.cpp">
#include "Vector2.h"
#include <cmath>      // sqrt

Vector2::Vector2()
	:x(0) , y(0)
{
}

Vector2::Vector2(float x,float y)
	:x(x) , y(y)
{
}

float Vector2::length() const
{
	return sqrt(x * x + y * y);
}

Vector2& Vector2::normalize()
{
	float len = length();
	if (len != 0)
	{
		return *this /= len;
	}
	return *this;
}

float Vector2::dot(const Vector2& v) const
{
	return x * v.x + y * v.y;
}

float Vector2::cross(const Vector2& v) const
{
	return x * v.y - y * v.x;
}

Vector2 Vector2::operator+() const
{
	return *this;
}

Vector2 Vector2::operator-() const
{
	return Vector2(-x, -y);
}

Vector2& Vector2::operator+=(const Vector2& v)
{
	x += v.x;
	y += v.y;
	return *this;
}

Vector2& Vector2::operator-=(const Vector2& v)
{
	x -= v.x;
	y -= v.y;
	return *this;
}

Vector2& Vector2::operator*=(float s)
{
	x *= s;
	y *= s;
	return *this;
}

Vector2& Vector2::operator/=(float s)
{
	x /= s;
	y /= s;
	return *this;
}

// Vector2 NXÉ‘È‚ÖQ
// ñ€‰Zq
const Vector2 operator+(const Vector2& v1, const Vector2& v2)
{
	Vector2 temp(v1);
	return temp += v2;
}

const Vector2 operator-(const Vector2& v1, const Vector2& v2)
{
	Vector2 temp(v1);
	return temp -= v2;
}

const Vector2 operator*(const Vector2& v, float s)
{
	Vector2 temp(v);
	return temp *= s;
}

const Vector2 operator*(float s, const Vector2& v)
{
	return v * s;
}

const Vector2 operator/(const Vector2& v, float s)
{
	Vector2 temp(v);
	return temp /= s;
}
</file_content>

<file_content path="engine/math/Vector2.h">
#pragma once
class Vector2
{
public:
	float x; // x
	float y; // y

public:
	// RXgN^
	Vector2();                  // xNgÆ‚Ä
	Vector2(float x, float y);  // x , ywè‚µÄ‚Ì

	// oÏ
	float length() const;
	Vector2& normalize();
	float dot(const Vector2& v) const;
	float cross(const Vector2& v)const;

	// PZqI[o[[h
	Vector2 operator+() const;
	Vector2 operator-() const;

	// ZqI[o[[h
	Vector2& operator+=(const Vector2& v);
	Vector2& operator-=(const Vector2& v);
	Vector2& operator*=(float s);
	Vector2& operator/=(float s);

};

// 2ZqI[o[[h
// Èˆ(ÌŒ^Æ)Ìƒp^[É‘Î‰é‚½ßAÈ‰Ì‚æ‚¤ÉÄ‚
const Vector2 operator+(const Vector2& v1, const Vector2& v2);
const Vector2 operator-(const Vector2& v1, const Vector2& v2);
const Vector2 operator*(const Vector2& v, float s);
const Vector2 operator*(float s, const Vector2& v);
const Vector2 operator/(const Vector2& v, float s);


</file_content>

<file_content path="engine/math/Vector3.cpp">
// ===================
// Vector3 ^
// ===================
#include "Vector3.h"

Vector3::Vector3()
	:x(0), y(0), z(0)
{
}
Vector3::Vector3(float x, float y, float z)
	: x(x), y(y), z(z)
{
}
float Vector3::length() const
{
	return std::sqrt(x * x + y * y + z * z);
}
Vector3& Vector3::normalize()
{
	float len = length();
	if (len != 0)
	{
		return*this /= len;
	}
	return*this;
}
float Vector3::dot(const Vector3& v, const Vector3& v2)
{
	return v.x * v2.x + v.y * v2.y + v.z * v2.z;
}
Vector3 Vector3::cross(const Vector3& v)const
{
	Vector3 temp;
	temp.x = this->y * v.z - this->z * v.y;
	temp.y = this->z * v.x - this->x * v.z;
	temp.z = this->x * v.y - this->y * v.x;
	return temp;
}

const Vector3 Vector3::lerp(const Vector3& start, const Vector3& end, const float t)
{
	return start * (1.0f - t) + end * t;
}

Vector3 Vector3::operator+()const
{
	return *this;
}
Vector3 Vector3::operator-()const
{
	return Vector3(-x, -y, -z);
}
Vector3& Vector3::operator+=(const Vector3& v)
{
	x += v.x;
	y += v.y;
	z += v.z;
	return *this;
}
Vector3& Vector3::operator-=(const Vector3& v)
{
	x -= v.x;
	y -= v.y;
	z -= v.z;
	return *this;
}
Vector3& Vector3::operator*=(const Vector3& v)
{
	x *= v.x;
	y *= v.y;
	z *= v.z;
	return *this;
}
Vector3& Vector3::operator*=(float s)
{
	x *= s;
	y *= s;
	z *= s;
	return *this;
}
Vector3& Vector3::operator/=(float s)
{
	x /= s;
	y /= s;
	z /= s;
	return *this;
}
// Vector3 NXÉ‘È‚ÖQ
// ñ€‰Zq
const Vector3 operator+ (const Vector3& v1, const Vector3& v2)
{
	Vector3 temp(v1);
	return temp += v2;
}
const Vector3 operator-(const Vector3& v1, const Vector3& v2)
{
	Vector3 temp(v1);
	return temp -= v2;
}
const Vector3 operator*(const Vector3& v, float s)
{
	Vector3 temp(v);
	return temp *= s;
}
const Vector3 operator*(float s, const Vector3& v)
{
	return v * s;
}
const Vector3 operator/(const Vector3& v, float s)
{
	Vector3 temp(v);
	return temp /= s;
}


</file_content>

<file_content path="engine/math/Vector3.h">
#pragma once
#include <cmath>

class Vector3 {
public:
	float x;//x
	float y;//y
	float z;//z

public:
	//RXgNg
	Vector3();                            //[xNgÆ‚Ä
	Vector3(float x, float y, float z);   //x,ywè‚µÄ‚Ì

	//@oÖ
	float length() const;                 //m()ß‚
	Vector3& normalize();                 //K
	static float dot(const Vector3& v, const Vector3& v2);   //Ï‚ß‚
	Vector3 cross(const Vector3& v)const; //OÏ‚ß‚

	// `(1Ö)
	static const Vector3 lerp(const Vector3& start, const Vector3& end, const float t);

	//bZqI[o[[h
	Vector3 operator+() const;
	Vector3 operator-() const;

	//ZqI[o[[h
	Vector3& operator+=(const Vector3& v);
	Vector3& operator-=(const Vector3& v);
	Vector3& operator*=(const Vector3& v);
	Vector3& operator*=(float s);
	Vector3& operator/=(float s);
};
//2ZqI[o[[h
//Èˆ(ÌŒ^Æ)Ìƒp^[É‘Î‰é‚½ßAÈ‰Ì‚æ‚¤ÉÄ‚
const Vector3  operator+(const Vector3& v1, const Vector3& v2);
const Vector3  operator-(const Vector3& v1, const Vector3& v2);
const Vector3  operator*(const Vector3& v, float s);
const Vector3  operator*(float s, const Vector3& v);
const Vector3  operator/(const Vector3& v, float s);



</file_content>

<file_content path="engine/math/Vector4.cpp">
#include "Vector4.h"

#include<cmath>  //sprt

Vector4::Vector4() :x(0), y(0), z(0), w(0)
{
}

Vector4::Vector4(float x, float y, float z, float w) {
	this->x = x;
	this->y = y;
	this->z = z;
	this->w = w;
}

float Vector4::length()const {
	return std::sqrt(x * x + y * y + z * z + w * w);
}

Vector4& Vector4::normalize() {
	float len = length();
	if (len != 0) {
		return *this /= len;
	}
	return *this;
}

float Vector4::dot(const Vector4& v) const
{
	return x * v.x + y * v.y + z * v.z + w * v.w;
}

Vector4 Vector4::cross(const Vector4& v) const
{
	return Vector4(
		y * v.z - z * v.y,
		z * v.x - x * v.z,
		x * v.y - y * v.x,
		v.w
	);
}

Vector4 Vector4::operator+() const
{
	return Vector4(x, y, z, w);
}

Vector4 Vector4::operator-() const
{
	return Vector4(x, y, z, w);
}

Vector4& Vector4::operator+=(const Vector4& v)
{
	this->x += v.x;
	this->y += v.y;
	this->z += v.z;
	this->w += v.w;
	return *this;
}

Vector4& Vector4::operator-=(const Vector4& v)
{
	this->x -= v.x;
	this->y -= v.y;
	this->z -= v.z;
	this->w -= v.w;
	return *this;
}

Vector4& Vector4::operator*=(float s)
{
	this->x *= s;
	this->y *= s;
	this->z *= s;
	this->w *= s;
	return *this;
}

Vector4& Vector4::operator/=(float s)
{
	x /= s;
	y /= s;
	z /= s;
	w /= s;
	return *this;
}

//Vector4 NXÉ‘È‚ÖQ


const Vector4 operator+(const Vector4& v1, const Vector4& v2)
{
	Vector4 temp(0,0,0,0);
	temp.x = v1.x + v2.x;
	temp.y = v1.y + v2.y;
	temp.z = v1.z + v2.z;
	temp.w = v1.w + v2.w;
	return temp;
}

const Vector4 operator-(const Vector4& v1, const Vector4& v2)
{
	Vector4 temp(0, 0, 0, 0);
	temp.x = v1.x - v2.x;
	temp.y = v1.y - v2.y;
	temp.z = v1.z - v2.z;
	temp.w = v1.w - v2.w;
	return temp;
}

const Vector4 operator*(const Vector4& v, float s)
{
	Vector4 temp(0,0,0,0);
	temp.x = v.x * s;
	temp.y = v.y * s;
	temp.z = v.z * s;
	temp.w = v.w * s;
	return temp;
}

const Vector4 operator/(const Vector4& v, float s)
{
	Vector4 temp(0, 0, 0, 0);
	temp.x = v.x / s;
	temp.y = v.y / s;
	temp.z = v.z / s;
	temp.w = v.w / s;
	return temp;
}
</file_content>

<file_content path="engine/math/Vector4.h">
#pragma once

class Vector4
{
public:
	float x;
	float y;
	float z;
	float w;
public:
	//RXgN^
	Vector4();								//xNgÆ‚
	Vector4(float x, float y, float z, float w);		//x,y,z wè‚µÄ

	//oÖ
	float length() const;					//m()ß‚
	Vector4& normalize();					//K
	float dot(const Vector4& v) const;		//Ï‚ß‚
	Vector4 cross(const Vector4& v) const;	//OÏ‚ß‚


	//PZqI[o[[h
	Vector4 operator+() const;
	Vector4 operator-() const;

	//ZqI[o[[h
	Vector4& operator+=(const Vector4& v);
	Vector4& operator-=(const Vector4& v);
	Vector4& operator*=(float s);
	Vector4& operator/=(float s);

};


//@2ZqI[o[[h
//@ë‚¢ÈˆÌƒp^[É‘Î‰(Ì)é‚½ßAÈ‰Ì‚æ‚¤ÉÄ‚
const Vector4 operator+(const Vector4& v1, const Vector4& v2);
const Vector4 operator-(const Vector4& v1, const Vector4& v2);
const Vector4 operator*(const Vector4& v, float s);
const Vector4 operator*(float s, const Vector4& v);
const Vector4 operator/(const Vector4& v, float s);
</file_content>

<file_content path="engine/scene/AbstractSceneFactory.h">
#pragma once

#include "GameBaseScene.h"
#include <string>

class AbstractSceneFactory
{
public:
	virtual ~AbstractSceneFactory() = default;

	virtual GameBaseScene* CreateScene(const std::string& sceneName) = 0;
};
</file_content>

<file_content path="engine/scene/Game.cpp">
#include "Game.h"

#include "SceneFactory.h"

void Game::Initialize()
{	
	// NXÌ
	SIFrameWork::Initialize();

	// V[t@Ngğ¶A}l[WÉƒZbg
	sceneFactory_ = new SceneFactory();
	sceneManager_->SetSceneFactory(sceneFactory_);
	// V[}l[WÉÅÌƒV[Zbg
	sceneManager_->ChangeScene("TITLE");
}

void Game::Finalize()
{
	// NXÌI
	SIFrameWork::Finalize();
}

void Game::Update()
{
	// NXÌXV
	SIFrameWork::Update();
}

void Game::Draw()
{
	// R}hXgÌæ“¾
	ID3D12GraphicsCommandList* cmdList = dxCommon->GetCommandList();

	//=== V[}l[WÌ•` ===//
	sceneManager_->Draw();
}

</file_content>

<file_content path="engine/scene/Game.h">
#pragma once

#include "SIFrameWork.h"

// Q[S
class Game : public SIFrameWork
{
public: // oÖ
	// 
	void Initialize() override;

	// I
	void Finalize() override;

	// t[XV
	void Update() override;

	// `
	void Draw() override;
};

</file_content>

<file_content path="engine/scene/GameBaseScene.cpp">
#include "GameBaseScene.h"


void GameBaseScene::LoadObjFromLevelEditor(const std::string& fileName) {
	JsonLoader* file = nullptr;
	LevelData* levelData = file->LoadFile(fileName);

	//IuWFNgzu
	for (auto& objectData : levelData->objects) {
		//t@Co^Ï‚İƒf
		Model* model = nullptr;
		decltype(models)::iterator it = models.find(objectData.fileName);
		if (it != models.end()) { model = it->second; }
		//fwè‚µ3DObjectğ¶
		Object3d* newObject = Object3d::Create();
		newObject->Initialize();
		newObject->SetModel(model);
		//W
		Vector3 pos;
		pos = Vector3(objectData.translation.x, objectData.translation.y, objectData.translation.z);
		newObject->SetPosition(pos);
		//]p
		Vector3 rot;
		rot = Vector3(objectData.rotation.x, objectData.rotation.y, objectData.rotation.z);
		newObject->SetRotation(rot);
		//XP[
		Vector3 scale;
		scale = Vector3(objectData.scaling.x, objectData.scaling.y, objectData.scaling.z);
		newObject->SetScale(scale);
		//zÉ“o^
		objects.push_back(newObject);
	}
}

</file_content>

<file_content path="engine/scene/GameBaseScene.h">
#pragma once

#include "Sprite.h"
#include "JsonLoader.h"	
#include "Model.h"
#include "Object3d.h"

#include <cassert>
#include <fstream>
#include <sstream>
#include <map>
#include <list>

// OéŒ¾
class GameSceneManager;

// V[NX
class GameBaseScene
{
public: // oÖ
	GameBaseScene() = default;
	virtual ~GameBaseScene() = default;

public: // oÖ
	/// <summary>
	/// 
	/// </summary>
	virtual void Initialize() = 0;

	/// <summary>
	/// XV
	/// </summary>
	virtual void Update() = 0;

	/// <summary>
	/// `
	/// </summary>
	virtual void Draw() = 0;

	/// <summary>
	/// 
	/// </summary>
	virtual void Finalize() = 0;

	void LoadObjFromLevelEditor(const std::string& fileName);

public: // oÖ
	virtual void SetSceneManager(GameSceneManager* gSceneManager) { gSceneManager_ = gSceneManager; }

protected: // oÏ
	// V[}l[WiØ‚Ä‚j
	GameSceneManager* gSceneManager_ = nullptr;
	//leveleditor
	std::map<std::string, Model*> models;
	std::vector<Object3d*> objects;
};


</file_content>

<file_content path="engine/scene/GameClearScene.cpp">
#include "GameClearScene.h"

using namespace DirectX;

GameClearScene::GameClearScene()
{
}

GameClearScene::~GameClearScene()
{
}

void GameClearScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon = DirectXCommon::GetInstance();


	//J
	viewProjection = new ViewProjection();
	viewProjection->Initialize();

	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon->GetDevice());

	//gameclearÌ‰æ‘œ
	clearGH.LoadTexture(spriteCommon_, 0, L"Resources/clear.png", dxCommon->GetDevice());
	clearGH.SpriteCreate(dxCommon->GetDevice(), 1280, 720, 0, Vector2(0.0f, 0.0f), false, false);
	clearGH.SetScale(Vector2(1280 * 1, 720 * 1));
	clearGH.SpriteTransferVertexBuffer(clearGH, 0);
	clearGH.SpriteUpdate(clearGH, spriteCommon_);
	
	showTime = 0;
	isNext = false;
	curHit01 = false;
	curHit02 = false;
}

void GameClearScene::Update()
{
	viewProjection->UpdateMatrix();
	clearGH.SpriteUpdate(clearGH, spriteCommon_);
	if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
		GameSceneManager::GetInstance()->ChangeScene("TITLE");
	}
}

void GameClearScene::Draw()
{
	// `O
	dxCommon->PreDraw();

	Object3d::PreDraw(dxCommon->GetCommandList());


	Object3d::PostDraw();

	Sprite::PreDraw(dxCommon->GetCommandList(),spriteCommon_);

	clearGH.SpriteDraw(dxCommon->GetCommandList(), spriteCommon_, dxCommon->GetDevice());

	Sprite::PostDraw();

	
	// `ãˆ
	dxCommon->PostDraw();
}

void GameClearScene::Finalize()
{
}

</file_content>

<file_content path="engine/scene/GameClearScene.h">
#pragma once

#include "Input.h"
#include "DirectXCommon.h"
#include "GameBaseScene.h"
#include "Sprite.h"
#include "GameSceneManager.h"
#include "GameTitleScene.h"
#include "Object3d.h"

#include <DirectXMath.h>

class GameClearScene : public GameBaseScene
{
public: // oÖ
	// RXgN^
	GameClearScene();
	// fXgN^
	~GameClearScene();

public: // oÖ
	/// <summary>
	/// 
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// XV
	/// </summary>
	void Update() override;

	/// <summary>
	/// `
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// 
	/// </summary>
	void Finalize() override;

private: // oÏ
	Input* input_ = nullptr;
	DirectXCommon* dxCommon = nullptr;
	Sprite* cross = nullptr;
	//J
	ViewProjection* viewProjection = nullptr;
	//score
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite clearGH;
	int scores[6];
	float numPosX;
	int showTime;
	//title
	Sprite* title01 = nullptr;
	Sprite* title02 = nullptr;
	//retry
	Sprite* retry01 = nullptr;
	Sprite* retry02 = nullptr;
	bool isNext;
	bool curHit01;
	bool curHit02;
};

</file_content>

<file_content path="engine/scene/GameOverScene.cpp">
#include "GameOverScene.h"

GameOverScene::GameOverScene()
{
}

GameOverScene::~GameOverScene()
{
}

void GameOverScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon = DirectXCommon::GetInstance();


	//J
	viewProjection = new ViewProjection();
	viewProjection->Initialize();

	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon->GetDevice());
}

void GameOverScene::Update()
{
	viewProjection->UpdateMatrix();
	if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
		GameSceneManager::GetInstance()->ChangeScene("TITLE");
	}
}

void GameOverScene::Draw()
{
	// `O
	dxCommon->PreDraw();

	Object3d::PreDraw(dxCommon->GetCommandList());


	Object3d::PostDraw();


	// `ãˆ
	dxCommon->PostDraw();
}

void GameOverScene::Finalize()
{
}

</file_content>

<file_content path="engine/scene/GameOverScene.h">
#pragma once

#include "Input.h"
#include "DirectXCommon.h"
#include "GameBaseScene.h"
#include "Sprite.h"
#include "GameSceneManager.h"
#include "GameTitleScene.h"
#include "Object3d.h"

#include <DirectXMath.h>

class GameOverScene : public GameBaseScene
{
public: // oÖ
	// RXgN^
	GameOverScene();
	// fXgN^
	~GameOverScene();

public: // oÖ
	/// <summary>
	/// 
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// XV
	/// </summary>
	void Update() override;

	/// <summary>
	/// `
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// 
	/// </summary>
	void Finalize() override;

private: // oÏ
	Input* input_ = nullptr;
	DirectXCommon* dxCommon = nullptr;
	Sprite* cross = nullptr;
	//J
	ViewProjection* viewProjection = nullptr;
	//score
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite clearGH;
	int scores[6];
	float numPosX;
	int showTime;
	//title
	Sprite* title01 = nullptr;
	Sprite* title02 = nullptr;
	//retry
	Sprite* retry01 = nullptr;
	Sprite* retry02 = nullptr;
	bool isNext;
	bool curHit01;
	bool curHit02;
};


</file_content>

<file_content path="engine/scene/GameScene.cpp">
#include "GameScene.h"
#include "FbxLoader.h"
#include "FbxObject3d.h"
#include "SphereCollider.h"
#include "CollisionManager.h"
#include "GameSceneManager.h"

#include <cassert>
#include <fstream>
#include <sstream>
#include <map>

std::list<std::unique_ptr<Energy>> GameScene::energys_;
int GameScene::popEnergyCount = 0;
GameScene::GameScene() {}

GameScene::~GameScene() {
	delete player;
}

///-----ÏÌ-----///
void GameScene::Initialize() {
	//
	dxCommon_ = DirectXCommon::GetInstance();
	winApp = WinApp::GetInstance();
	input = Input::GetInstance();
	//è”»
	collisionManager = CollisionManager::GetInstance();

	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 0.7f));

	//fÇ‚İ
	skyModel = Model::LoadFromOBJ("sky");
	seaModel = Model::LoadFromOBJ("sea");
	block01Model = Model::LoadFromOBJ("block01");
	block02Model = Model::LoadFromOBJ("block02");
	stoneModel = Model::LoadFromOBJ("stone");
	models.insert(std::make_pair("sky", skyModel));
	models.insert(std::make_pair("sea", seaModel));
	models.insert(std::make_pair("block01", block01Model));
	models.insert(std::make_pair("block02", block02Model));
	models.insert(std::make_pair("stone", stoneModel));
	//xGfB^Ç‚İ
	LoadObjFromLevelEditor("scene");

	railCamera = new RailCamera;
	railCamera->Initialize(player);

	xmViewProjection = new XMViewProjection;

	////FbxObjectÌÃ“I
	////JZbg
	//FbxObject3d::SetCamera(viewProjection);
	////OtBbNXpCvC
	//FbxObject3d::CreateGraphicsPipeline();

	// XvCgÌ
	// XvCg
	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon_->GetDevice());

	//titleÌ‰æ‘œ
	titleGH.LoadTexture(spriteCommon_, 0, L"Resources/title.png", dxCommon_->GetDevice());
	titleGH.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 0, Vector2(0.0f, 0.0f), false, false);
	titleGH.SetScale(Vector2(1280 * 1, 720 * 1));
	titleGH.SpriteTransferVertexBuffer(titleGH, 0);
	titleGH.SpriteUpdate(titleGH, spriteCommon_);

	//NXwAÌ‰æ‘œ
	for (int i = 0; i < 4; i++) {
		crosshair[i].LoadTexture(spriteCommon_, 1, L"Resources/crosshair.png", dxCommon_->GetDevice());
		crosshair[i].SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 1, Vector2(0.5f, 0.5f), false, false);
		crosshair[i].SetPosition(Vector3(1100, 0, 0));
		crosshair[i].SetScale(Vector2(24.0f * (i + 1.0f), 24.0f * (i + 1.0f)));
		crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
		crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
	}

	//HPpæ‘œ
	hp.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 2, Vector2(0.0f, 0.0f), false, false);
	hp.SetPosition(Vector3(28, 650, 0));
	hp.SetScale(Vector2(4 * 1, 48 * 1));
	hp.LoadTexture(spriteCommon_, 2, L"Resources/life.png", dxCommon_->GetDevice());
	hp.SpriteTransferVertexBuffer(hp, 2);
	hp.SpriteUpdate(hp, spriteCommon_);

	//gameclearÌ‰æ‘œ
	clearGH.LoadTexture(spriteCommon_, 3, L"Resources/clear.png", dxCommon_->GetDevice());
	clearGH.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 3, Vector2(0.0f, 0.0f), false, false);
	clearGH.SetScale(Vector2(1280 * 1, 720 * 1));
	clearGH.SpriteTransferVertexBuffer(clearGH, 3);
	clearGH.SpriteUpdate(clearGH, spriteCommon_);

	//gameoverÌ‰æ‘œ
	overGH.LoadTexture(spriteCommon_, 4, L"Resources/over.png", dxCommon_->GetDevice());
	overGH.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 4, Vector2(0.0f, 0.0f), false, false);
	overGH.SetScale(Vector2(1280 * 1, 720 * 1));
	overGH.SpriteTransferVertexBuffer(overGH, 4);
	overGH.SpriteUpdate(overGH, spriteCommon_);

	for (int i = 0; i < 10; i++) {
		lock[i].LoadTexture(spriteCommon_, 1, L"Resources/crosshair.png", dxCommon_->GetDevice());
		lock[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 1, Vector2(0.0f, 0.0f), false, false);
		lock[i].SetScale(Vector2(128 * 1, 128 * 1));
		lock[i].SpriteTransferVertexBuffer(lock[i], 1);
		lock[i].SpriteUpdate(lock[i], spriteCommon_);
	}

	//fade
	fade.LoadTexture(spriteCommon_, 5, L"Resources/black.png", dxCommon_->GetDevice());
	fade.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 5, Vector2(0.0f, 0.0f), false, false);
	fade.SetScale(Vector2(1280 * 1, 720 * 1));
	fade.SpriteTransferVertexBuffer(fade, 5);
	fade.SpriteUpdate(fade, spriteCommon_);
	//alpha
	fadeAlpha = 1.0f;
	fade.SetAlpha(fade, fadeAlpha);
	//boosHP
	bossHP.LoadTexture(spriteCommon_, 6, L"Resources/hp.png", dxCommon_->GetDevice());
	bossHP.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 6, Vector2(0.0f, 0.5f), false, false);
	bossHP.SetPosition(Vector3(25, 50, 0));
	bossHP.SetScale(Vector2(2 * 1, 48 * 1));
	bossHP.SpriteTransferVertexBuffer(bossHP, 6);
	bossHP.SpriteUpdate(bossHP, spriteCommon_);
	//gage
	gage.LoadTexture(spriteCommon_, 7, L"Resources/green.png", dxCommon_->GetDevice());
	gage.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 7, Vector2(0.0f, 0.5f), false, false);
	gage.SetPosition(Vector3(28, 641, 0));
	gage.SetScale(Vector2(2 * 1, 18 * 1));
	gage.SpriteTransferVertexBuffer(gage, 7);
	gage.SpriteUpdate(gage, spriteCommon_);
	//
	gageBack.LoadTexture(spriteCommon_, 8, L"Resources/green.png", dxCommon_->GetDevice());
	gageBack.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 8, Vector2(0.0f, 0.5f), false, false);
	gageBack.SetPosition(Vector3(28, 641, 0));
	gageBack.SetScale(Vector2(2 * 178, 18 * 1));
	gageBack.SetAlpha(gageBack, 0.5f);
	gageBack.SpriteTransferVertexBuffer(gageBack, 8);
	gageBack.SpriteUpdate(gageBack, spriteCommon_);
	//
	hpBack.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 9, Vector2(0.0f, 0.0f), false, false);
	hpBack.SetPosition(Vector3(28, 650, 0));
	hpBack.SetScale(Vector2(396, 48 * 1));
	hpBack.LoadTexture(spriteCommon_, 9, L"Resources/life.png", dxCommon_->GetDevice());
	hpBack.SetAlpha(hpBack, 0.5f);
	hpBack.SpriteTransferVertexBuffer(hpBack, 9);
	hpBack.SpriteUpdate(hpBack, spriteCommon_);
	//tF[hAEg
	fadeout.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 10, Vector2(1.0f, 0.0f), false, false);
	fadeout.SetScale(Vector2(1280 * 1, 1120 * 1));
	fadeout.SetPosition({ 0,100,0 });
	fadeout.SetRotation(45);
	fadeout.SpriteTransferVertexBuffer(fadeout, 10);
	fadeout.SpriteUpdate(fadeout, spriteCommon_);
	fadeout.LoadTexture(spriteCommon_, 10, L"Resources/fade.png", dxCommon_->GetDevice());

	//p[eBN
	particle = Particle::LoadParticleTexture("blue.png");
	pm_ = ParticleManager::Create();
	particle_ = Particle::LoadParticleTexture("crosshair.png");
	pm = ParticleManager::Create();
	//IuWFNgÉƒfRt
	pm->SetParticleModel(particle);
	pm_->SetParticleModel(particle_);
	//JZbg
	pm->SetXMViewProjection(xmViewProjection);
	pm_->SetXMViewProjection(xmViewProjection);

	////fwè‚µÄ“Ç‚İ
	//obj = new FbxObject3d;
	//obj->Initialize();
	//model = FbxLoader::GetInstance()->LoadModelFlomFile("cube");
	//obj->SetModel(model);
	//obj->SetPosition(Vector3(1, 0, -10));
	//obj->SetScale(Vector3((float)0.01, (float)0.01, (float)0.01));

	//boss
	boss = new Boss;
	boss->BossInitialize();
	boss->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 10.0f));


	//XvC_Ì“Ç‚İ
	stageNum = 1;
	LoadStage(stageNum);
	LoadEnemy(stageNum);
	//Ï
	isCheckPoint = false;
	isPlayable = false;
	gameState = MAIN;
	infos.clear();
	gameTime = 150;
	cursorRotate = 0.001f;
	bossPass = 0;
	cameraTmpPos = { 0,0,0 };
	cameraTmpRot = { 0,0,0 };
	isStart = false;
}

///-----XV-----///
void GameScene::Update() {
	//NXwAXV
	GetCrosshair();
	//Zbg
	if (Input::GetInstance()->TriggerKey(DIK_R)) {
		Reset();
		gameState = MAIN;
		gameTime = 150;
		railCamera->GetView()->SetEye(Vector3(-1, 0.5f, 490.0f));
		railCamera->GetView()->SetTarget(Vector3(0.0f, 0.5f, 495));
		player->SetPosition({ 0,0.5f,495 });
		Vector3 cursor = GetWorldToScreenPos(Vector3(0, 0, 0), railCamera);
		input->SetMousePos({ cursor.x,cursor.y });
	}
	if (isStart == false) {
		fadeAlpha = 0.0f;
		fade.SetAlpha(fade, fadeAlpha);
		gameTime = 150;
		railCamera->GetView()->SetEye(Vector3(-1, 0.5f, 490.0f));
		railCamera->GetView()->SetTarget(Vector3(0.0f, 0.5f, 495));
		player->SetPosition({ 0,0.5f,495 });
		Vector3 cursor = GetWorldToScreenPos(Vector3(-230, 85, 0), railCamera);
		input->SetMousePos({ cursor.x,cursor.y });
		for (auto& object : objects) {
			object->Update();
		}
		isStart = true;
	}
	//CQ[JntF[hAEg
	//if (fadeout.GetPosition().y < 400) {
	//	fadeout.SetPosition(fadeout.GetPosition() + Vector3(0, 40, 0));
	//	fadeout.SpriteUpdate(fadeout, spriteCommon_);
	//}

	Vector3 shotVec = { 0,0,0 };


  //Â”\Ô‚È‚HPXV
	if (isPlayable == true) {
		//playerhp
		float playerHp_ = player->GetHP() - (hp.GetScale().x / 4);
		if (playerHp_ > 0) {
			if ((playerHp_) > 4) {
				hp.SetScale(hp.GetScale() + Vector2(16.0f, 0.0f));
			}
			else if ((playerHp_) > 2) {
				hp.SetScale(hp.GetScale() + Vector2(8.0f, 0.0f));
			}
			else if ((playerHp_) > 1) {
				hp.SetScale(hp.GetScale() + Vector2(4.0f, 0.0f));
			}
		}
		else if (playerHp_ < 0) {
			if ((playerHp_) < 4) {
				hp.SetScale(hp.GetScale() - Vector2(8.0f, 0.0f));
			}
			else if ((playerHp_) < 2) {
				hp.SetScale(hp.GetScale() - Vector2(4.0f, 0.0f));
			}
			else if ((playerHp_) < 1) {
				hp.SetScale(hp.GetScale() - Vector2(2.0f, 0.0f));
			}
		}

		hp.SpriteTransferVertexBuffer(hp, 2);
		hp.SpriteUpdate(hp, spriteCommon_);
		//gage
		float gage_ = player->GetEnergy() - (gage.GetScale().x / 4);
		if (gage_ > 0) {
			if (player->GetEnergy() < 100) {
				if ((gage_) > 4) {
					gage.SetScale(gage.GetScale() + Vector2(16.0f, 0.0f));
				}
				else if ((gage_) > 2) {
					gage.SetScale(gage.GetScale() + Vector2(8.0f, 0.0f));
				}
				else if ((gage_) > 1) {
					gage.SetScale(gage.GetScale() + Vector2(4.0f, 0.0f));
				}
			}
		}
		else if (gage_ < 0) {
			if ((gage_) < 4) {
				gage.SetScale(gage.GetScale() - Vector2(8.0f, 0.0f));
			}
			else if ((gage_) < 2) {
				gage.SetScale(gage.GetScale() - Vector2(4.0f, 0.0f));
			}
			else if ((gage_) < 1) {
				gage.SetScale(gage.GetScale() - Vector2(2.0f, 0.0f));
			}
		}

		gage.SpriteTransferVertexBuffer(gage, 7);
		gage.SpriteUpdate(gage, spriteCommon_);
	}

	//CQ[
	switch (gameState)
	{
		//CQ[
	case GameScene::MAIN:
		//Q[X^[go
		if (gameTime > 0) {
			//SPACEÅ‰oXLbv
			if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
				gameTime = 1;
			}
			railCamera->GetView()->SetEye(railCamera->GetView()->GetEye() + Vector3(0, 0.0f, 0.05f));
			gameTime--;
			if (gameTime <= 0) {
				player->SetPosition(Vector3(0, -1.0f, -5.5f));
				player->SetAlpha(0.0f);
			}
			player->worldTransform_.UpdateMatrix();
		}
		//Q[
		if (gameTime == 0) {
			//sÂÔ‚
			if (isPlayable == false) {
				isPlayable = true;
			}
			//boss
			if (railCamera->GetOnRail() == false) {
				if (isCheckPoint == false) {
					isCheckPoint = true;
					boss->Pop();
					gameState = BOSS;
					delete railCamera;
					railCamera = new RailCamera;
					railCamera->Initialize(player);
				}
			}
			/////fobNp({XÜ‚ÅƒXLbv)/////
			if (input->TriggerKey(DIK_B)) {
				railCamera->SetOnRail(false);
			}

			//playerXV(JÌ‘O)
			if (input->PushMouseLeft()) {
				shotVec = GetScreenToWorldPos(crosshair[0], railCamera);
			}
			if (isPlayable == true) {
				SerchEnemy();
				player->Update(shotVec, infos);
				if (gameState == BOSS && railCamera->GetOnRail() == true) {
					player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				}
				LockedClear();
			}
			//XV
			railCamera->Update(player, points);
			//_[WÆ‚É‰ÊƒVFCN
			if (player->GetIsHit() == true) {
				railCamera->ShakeCamera(-0.2f, 0.2f);
			}
		}
		break;
		//{X
	case GameScene::BOSS:
		if (boss->GetTimer() > 0) {
			player->SetIsHit(false);
			//playerğ‘€sÂ‚
			if (isPlayable == true) {
				isPlayable = false;
				railCamera->GetView()->SetEye(Vector3(-40, 55, -150));
			}
			//SPACEÅ‰oXLbv
			if (input->TriggerKey(DIK_SPACE)) {
				boss->SkipMovie();
			}
			//o
			railCamera->GetView()->SetTarget(boss->GetPosition());
			if (boss->GetTimer() == 150) {
				railCamera->GetView()->SetEye(Vector3(-80, 55, -300));
			}
			else if (boss->GetTimer() < 150) {
				railCamera->GetView()->SetEye(railCamera->GetView()->GetEye() + Vector3(0.5f, 0.0f, 0.05f));
			}
		}
		else {
			//Â”\Ô‚
			if (isPlayable == false) {
				railCamera->GetView()->SetEye(Vector3(0, 60, -95));
				railCamera->GetView()->SetTarget(Vector3(0, 52, -200));
				railCamera->GetCamera()->SetPosition(Vector3(0, 59, -100));
				railCamera->GetCamera()->SetRotation(Vector3(0, 180, 0));
				player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				fadeAlpha = 1.0f;
				fade.SetAlpha(fade, fadeAlpha);
				isPlayable = true;
			}
			//BossHP
			float bossHp_ = boss->GetHP() - (bossHP.GetScale().x / 4);
			if (bossHp_ > 0) {
				if ((bossHp_) > 4) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(16.0f, 0.0f));
				}
				else if ((bossHp_) > 2) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(8.0f, 0.0f));
				}
				else if ((bossHp_) > 1) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(4.0f, 0.0f));
				}
			}
			else if (bossHp_ < 0) {
				if ((bossHp_) < 4) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(8.0f, 0.0f));
				}
				else if ((bossHp_) < 2) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(4.0f, 0.0f));
				}
				else if ((bossHp_) < 1) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(2.0f, 0.0f));
				}
			}
			bossHP.SpriteTransferVertexBuffer(bossHP, 6);
			bossHP.SpriteUpdate(bossHP, spriteCommon_);
			//playerXV(JÌ‘O)
			if (input->PushMouseLeft()) {
				shotVec = GetScreenToWorldPos(crosshair[0], railCamera);
			}
			if (isPlayable == true) {
				SerchEnemy();
				player->Update(shotVec, infos);
				if (gameState == BOSS && railCamera->GetOnRail() == true) {
					player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				}
				LockedClear();
			}

			//JXV
			if (railCamera->GetOnRail() == false) {
				gameTime++;
				if (gameTime == 300) {
					railCamera->SetOnRail(true);
					gameTime = 0;
				}
			}
			railCamera->Update(player, bossPoint);
			railCamera->GetView()->SetTarget(boss->GetPosition());
			railCamera->GetCamera()->SetRotation(railCamera->GetView()->GetTarget());
			//J
			if (bossPass == 0) {
				if (railCamera->GetPasPoint() + 1.0f > 3.0f) {
					railCamera->SetOnRail(false);
					bossPass = 1;
				}
			}
			else if (bossPass == 1) {
				if (railCamera->GetPasPoint() + 1.0f > 5.0f) {
					railCamera->SetOnRail(false);
					bossPass = 2;
				}
			}
			else if (bossPass == 2) {
				if (railCamera->GetPasPoint() + 1.0f > 7.0f) {
					railCamera->SetOnRail(false);
					bossPass = 3;
				}
			}
			else if (bossPass == 3) {
				if (railCamera->GetPasPoint() + 1.0f >= 8.96f) {
					railCamera->SetOnRail(false);
					railCamera->RailReset();
					bossPass = 0;
				}
			}
		}
		//fadein
		if (fadeAlpha > 0.0f) {
			fadeAlpha -= 0.005f;
			fade.SetAlpha(fade, fadeAlpha);
		}
		//gameclear
		if (boss->GetIsDead() == true) {
			LockedClear();
			GameSceneManager::GetInstance()->ChangeScene("CLEAR");
		}
		//XV
		boss->Update(player->GetWorldPos());
		//_[WÆ‚É‰ÊƒVFCN
		if (player->GetIsHit() == true) {
			railCamera->ShakeCamera(-2.0f, 2.0f);
		}
		break;
	case GameScene::ULT:
		if (isPlayable == true) {
			isPlayable = false;
		}
		player->Ultimate();
		railCamera->SetTarget(player->GetWorldPos());
		if (player->GetIsUltimate() == false) {
			player->BackRail();
			railCamera->SetEye(cameraTmpPos);
			railCamera->SetTarget(cameraTmpRot);
			gameState = gameState_bak;
		}
		break;
	}
	//////////////Â”\È‚XV///////////////////
	if (player->GetIsUltimate() == true && gameState != ULT) {
		cameraTmpPos = railCamera->GetView()->GetEye();
		cameraTmpRot = railCamera->GetView()->GetTarget();
		railCamera->SetEye(player->GetWorldPos() + Vector3(-2, 0, -3));
		railCamera->SetTarget(player->GetWorldPos());
		gameState_bak = gameState;
		gameState = ULT;
	}
	//fXtOÌ—Gíœ
	enemys_.remove_if([](std::unique_ptr < Enemy>& enemy_) {
		return enemy_->GetIsDead();
		});
	//GLÌXV
	for (const std::unique_ptr<Enemy>& enemy : enemys_) {
		enemy->Update(player->GetWorldPos(), railCamera->GetPasPoint());
	}
	//KEZGlM[
	for (const std::unique_ptr<Energy>& energy : energys_) {
		energy->Update(player->GetWorldPos(), railCamera->GetCamera()->GetRotation());
	}
	//fXtOÌ—Gíœ
	energys_.remove_if([](std::unique_ptr <Energy>& energys_) {
		return energys_->GetIsDead();
		});
	//gameover
	if (player->GetHP() == 0) {
		LockedClear();
		GameSceneManager::GetInstance()->ChangeScene("OVER");
	}
	//è”»`FbN
	collisionManager->CheckAllCollisions();
}

void GameScene::Draw() {
#pragma region 3DIuWFNg`

	dxCommon_->PreDraw();

	// 3DIuWFNg`O
	Object3d::PreDraw(dxCommon_->GetCommandList());

	//wiIuWFNg
	for (auto& object : objects) {
		object->Draw(railCamera->GetView());
	}
	//GLÌ•`
	for (const std::unique_ptr<Enemy>& enemy : enemys_) {
		enemy->EnemyDraw(railCamera->GetView());
	}
	for (const std::unique_ptr<Energy>& energy : energys_) {
		energy->Draw(railCamera->GetView());
	}
	//{X
	if (gameState == BOSS) {
		boss->BossDraw(railCamera->GetView());
	}
	//vC[
	player->PlayerDraw(railCamera->GetView());

	// 3DIuWFNg`ãˆ
	Object3d::PostDraw();

#pragma endregion

#pragma region FBX3DIuWFNg`

	//// 3DIuWFNg`O
	//FbxObject3d::PreDraw(dxCommon_->GetCommandList());

	//// 3DIuWFNg`ãˆ
	//FbxObject3d::PostDraw();

#pragma endregion

#pragma region p[eBN`

	// p[eBN`O
	ParticleManager::PreDraw(dxCommon_->GetCommandList());

	///==== p[eBN` ====///
	//p[eBN
	/*pm->Draw();
	pm_->Draw();*/

	// p[eBN`ãˆ
	ParticleManager::PostDraw();

#pragma endregion

#pragma region XvCg`

	// XvCg`O
	Sprite::PreDraw(dxCommon_->GetCommandList(), spriteCommon_);

	///=== XvCg` ===///

	if (gameState == BOSS) {
		fade.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		if (boss->GetTimer() == 0) {
			//{XHP
			bossHP.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
	}
	if (isPlayable == true) {
		hpBack.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		gageBack.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		hp.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		gage.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}
	if (isPlayable == true) {
		for (int i = 0; i < 4; i++) {
			crosshair[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
	}
	for (int i = 0; i < infos.size(); i++) {
		lock[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}
	fadeout.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());

	// XvCg`ãˆ
	Sprite::PostDraw();

	dxCommon_->PostDraw();
}

void GameScene::LoadStage(int stageNum) {
	points.clear();
	bossPoint.clear();

	//t@CJ
	std::ifstream file;
	file.open("Resources/csv/stagePop.csv");
	assert(file.is_open());

	HRESULT result = S_FALSE;

	std::string num;
	num = stageNum + 48;

	// PsÂ“Ç‚İ
	string line;
	while (getline(file, line)) {

		// PsÌ•Xg[É•ÏŠÄ‰Í‚â‚·
		std::istringstream line_stream(line);

		// pXp[XØ‚ÅsÌæ“ªæ“¾
		string key;
		getline(line_stream, key, ' ');


		// æ“ªstÈ‚Xe[W
		if (key == "st" + num) {
			// X,Y,ZWÇ‚İ
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// Wf[^É’Ç‰
			points.emplace_back(position);
		}
		if (stageNum == 10) {
			if (key == "st10") {
				// X,Y,ZWÇ‚İ
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// Wf[^É’Ç‰
				points.emplace_back(position);
			}
		}
		else if (stageNum > 10) {
			if (key == "st1" + stageNum - 10) {
				// X,Y,ZWÇ‚İ
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// Wf[^É’Ç‰
				points.emplace_back(position);
			}
		}
		//æ“ªboÈ‚{X
		if (key == "bo" + num) {
			// X,Y,ZWÇ‚İ
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// Wf[^É’Ç‰
			bossPoint.emplace_back(position);
		}
		if (stageNum == 10) {
			if (key == "st10") {
				// X,Y,ZWÇ‚İ
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// Wf[^É’Ç‰
				bossPoint.emplace_back(position);
			}
		}
		else if (stageNum > 10) {
			if (key == "st1" + stageNum - 10) {
				// X,Y,ZWÇ‚İ
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// Wf[^É’Ç‰
				bossPoint.emplace_back(position);
			}
		}
	}
	// t@CÆ•Â‚
	file.close();
}

void GameScene::Reset() {
	delete player;
	delete railCamera;
	delete enemy;
	delete boss;

	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 0.7f));
	player->SetPosition({ 0,0.5f,495 });
	hp.SetScale(Vector2(0, 48 * 1));
	//boss
	boss = new Boss;
	boss->BossInitialize();
	boss->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 10.0f));
	bossHP.SetScale(Vector2(12 * 1, 48 * 1));
	//camera
	railCamera = new RailCamera;
	railCamera->Initialize(player);
	//enemy
	LoadEnemy(stageNum);
	//Ï
	isCheckPoint = false;
	isPlayable = false;
	cursorRotate = 0.001f;
	LockedClear();
	infos.clear();
	gameState = MAIN;
	gameTime = 150;
	bossPass = 0;
	fadeAlpha = 1.0f;
	fade.SetAlpha(fade, fadeAlpha);
	popEnergyCount = 0;
}

void GameScene::Finalize()
{
}

void GameScene::LoadEnemy(int stageNum) {

	Spline spline;
	spline.Initialize();

	pointsL = points;
	pointsR = points;

	for (int i = 0; i < points.size(); i++)
	{
		pointsL[i] += Vector3(-2, 0, 0);
		pointsR[i] += Vector3(2, 0, 0);
	}

	enemys_.clear();

	//t@CJ
	std::ifstream file;
	file.open("Resources/csv/EnemyPop.csv");
	assert(file.is_open());

	HRESULT result = S_FALSE;

	std::string num;
	num = stageNum + 48;

	// PsÂ“Ç‚İ
	string line;
	while (getline(file, line)) {

		// PsÌ•Xg[É•ÏŠÄ‰Í‚â‚·
		std::istringstream line_stream(line);

		// pXp[XØ‚ÅsÌæ“ªæ“¾
		string key;
		getline(line_stream, key, ' ');

		string word;
		getline(line_stream, word, ' ');

		if (stageNum < 10) {
			// æ“ªñ‚ª‚È‚ç’¸_W
			if (key == "ea" + num) {
				//GÌ
				std::unique_ptr<Enemy> newEnemy = std::make_unique<Enemy>();
				//GÌ
				newEnemy->EnemyInitialize();
				////RC_[Ì’Ç‰
				newEnemy->SetCollider(new SphereCollider());
				// X,Y,ZWÇ‚İ
				Vector3 position{};
				float t;

				if (word.find("L") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(pointsL, t);
				}
				else if (word.find("M") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(points, t);
				}
				else if (word.find("R") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(pointsR, t);
				}

				// Wf[^É’Ç‰
				newEnemy->SetPosition(position);
				newEnemy->SetScale({ 0.6f,0.6f,0.6f });
				//o^
				enemys_.push_back(std::move(newEnemy));
			}
		}
	}
	// t@CÆ•Â‚
	file.close();
}

void GameScene::SerchEnemy()
{
	Vector3 cur = input->GetMousePos();

	if (input->PushKey(DIK_LSHIFT)) {
		for (int i = 0; i < boss->GetPartsNum(); i++) {
			Vector3 epos1 = GetWorldToScreenPos(boss->GetParts(i)->GetWorldPos(), railCamera);
			if (boss->GetIsInvisible() == false) {
				if (pow((epos1.x - cur.x), 2) + pow((epos1.y - cur.y), 2) < pow(50, 2)) {
					if (boss->GetParts(i)->GetIsLocked() == false && infos.size() < 10) {
						LockInfo info;
						info.vec = boss->GetParts(i)->GetWorldPos();
						info.obj = boss->GetParts(i);
						infos.push_back(info);
						boss->GetParts(i)->SetIsLocked(true);
					}
				}
			}
		}

		for (const std::unique_ptr<Enemy>& enemy : enemys_) {
			Vector3 epos2 = GetWorldToScreenPos(enemy->GetWorldPos(), railCamera);
			Vector3 len = enemy->GetWorldPos() - player->GetWorldPos();
			float len_ = len.length();
			if (pow((epos2.x - cur.x), 2) + pow((epos2.y - cur.y), 2) < pow(30, 2)) {
				if (enemy->GetIsLocked() == false && infos.size() < 10) {
					LockInfo info;
					info.vec = enemy->GetWorldPos();
					info.obj = enemy->GetPointer();
					infos.push_back(info);
					enemy->SetIsLocked(true);
				}
			}
		}
		if (cursorRotate < 0.005f) {
			cursorRotate += 0.0001f;
		}
	}
	else {
		if (cursorRotate > 0.001f) {
			cursorRotate -= 0.0001f;
		}
	}
	//bNIæ‘œÌXV
	for (int i = 0; i < infos.size(); i++) {
		lock[i].SetScale(GetWorldToScreenScale(infos[i].obj, railCamera));
		lock[i].SetPosition(GetWorldToScreenPos(infos[i].obj->GetWorldPos(), railCamera) - (Vector3(lock[i].GetScale().x, lock[i].GetScale().y, 0) / 2));
		lock[i].SpriteUpdate(lock[i], spriteCommon_);
		lock[i].SpriteTransferVertexBuffer(lock[i], 1);
	}
}

void GameScene::LockedClear()
{
	if (player->GetIsShooted() == true) {
		if (boss->GetIsLocked() == true) {
			boss->SetIsLocked(false);
		}

		for (const std::unique_ptr<Enemy>& enemy : enemys_) {
			if (enemy->GetIsLocked() == true) {
				enemy->SetIsLocked(false);
			}
		}
		infos.clear();
	}
}

void GameScene::GetCrosshair()
{
	Vector3 mPos = input->GetMousePos();
	//}EXJ[\ÌêŠÉƒNXwA\
	if (gameState == MAIN) {
		for (int i = 0; i < 4; i++) {
			if (i == 0) {
				crosshair[i].SetPosition(mPos);
			}
			else if (i == 1) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.1f);
			}
			else if (i == 2) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.25f);
			}
			else if (i == 3) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.55f);
			}
			if (i % 2 == 0) {
				crosshair[i].SetRotation(crosshair[i].GetRotation() + cursorRotate);
			}
			else {
				crosshair[i].SetRotation(crosshair[i].GetRotation() - cursorRotate);
			}
			if (crosshair[i].GetRotation() == 1.0f) {
				crosshair[i].SetRotation(0.0f);
			}
			crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
			crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
		}
	}
	else {
		for (int i = 0; i < 4; i++) {
			crosshair[i].SetPosition(mPos);
			if (i % 2 == 0) {
				crosshair[i].SetRotation(crosshair[i].GetRotation() + cursorRotate);
			}
			else {
				crosshair[i].SetRotation(crosshair[i].GetRotation() - cursorRotate);
			}
			if (crosshair[i].GetRotation() == 1.0f) {
				crosshair[i].SetRotation(0.0f);
			}
			crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
			crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
		}
	}
}

void GameScene::PopEnergy(Vector3 pos_)
{
	//u
	std::random_device seed_gen;
	std::mt19937_64 engine(seed_gen());
	std::uniform_real_distribution<float>dist(-1.5f, 1.5f);
	std::uniform_real_distribution<float>dist2(-2.5f, 2.5f);
	std::uniform_real_distribution<float>dist3(-1.5f, 1.5f);
	//eğ¶
	std::unique_ptr<Energy> newEnergy = std::make_unique<Energy>();

	//P													   
	newEnergy->EnergyInitialize();
	newEnergy->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 2.0f));
	newEnergy->SetPosition(pos_ + Vector3(dist(engine), dist2(engine), dist3(engine)));
	energys_.push_back(std::move(newEnergy));
}

Vector3 GameScene::GetScreenToWorldPos(Sprite& sprite_, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector3(0, 0, 1);
	}

	//r[|[gsñ¶
	Matrix4 viewPort = viewPort.ViewPortMat(WinApp::window_width, WinApp::window_height, Vector2(0.0f, 0.0f));

	//r[vWFNVr[|[gs
	Matrix4 invViewPort = viewPort;
	invViewPort.MakeInverse();
	//vWFNVs//
	float fovAngleY = 45.0f * (3.141592f / 180.0f);;
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	//vWFNVsñ¶
	Matrix4 projection = projection.ProjectionMat(fovAngleY, aspectRatio, 0.1f, 200.0f);
	Matrix4 invProjection = projection;
	invProjection.MakeInverse();
	//r[s//
	Matrix4 view = railCamera->GetView()->GetMatView();
	Matrix4 invView = view;
	invView.MakeInverse();
	////sÌ‹tsvZ
	Matrix4 matInverseVPV = invViewPort * invProjection * invView;
	//XN[Wnçƒ[hWn
	Matrix4 mat1, mat2;
	//wZ
	Vector3 posNear = Vector3(sprite_.GetPosition().x, sprite_.GetPosition().y, 0);
	Vector3 posFar = Vector3(sprite_.GetPosition().x, sprite_.GetPosition().y, 1);
	posNear = mat1.transform(posNear, matInverseVPV);
	posFar = mat2.transform(posFar, matInverseVPV);

	//}EXCÌ•
	Vector3 mouseDirection = posFar - posNear;
	mouseDirection = mouseDirection.normalize();
	//JÆIuWFNgÌ‹
	const float kDistanceTestObject = 0.05f;

	Vector3 pos = player->GetWorldPos();
	Vector3 translate = (posFar - pos) * kDistanceTestObject;

	return translate;
}

Vector3 GameScene::GetWorldToScreenPos(Vector3 pos_, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector3(0, 0, 0);
	}

	//r[s//
	Matrix4 view = railCamera->GetView()->GetMatView();
	//vWFNVs//
	float fovAngleY = 45.0f * (3.141592f / 180.0f);;
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	//vWFNVsñ¶
	Matrix4 projection = projection.ProjectionMat(fovAngleY, aspectRatio, 0.1f, 200.0f);
	//r[|[gsñ¶
	Matrix4 viewPort = viewPort.ViewPortMat(WinApp::window_width, WinApp::window_height, Vector2(0.0f, 0.0f));

	Matrix4 matVPV = view * projection * viewPort;

	Matrix4 mat;
	Vector3 posScreen = pos_;
	posScreen = mat.transform(posScreen, matVPV);
	posScreen.z = 0;

	return posScreen;
}

Vector2 GameScene::GetWorldToScreenScale(Object3d* obj, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector2(0, 0);
	}

	Vector3 v = obj->GetPosition() - rail->GetView()->GetEye();
	v.normalize();
	float len = v.length();

	float x = 64;
	x *= obj->GetScale().x;
	float y = 64;
	y *= obj->GetScale().y;


	return Vector2(x / len, y / len);
}

//void GameScene::LoadObjFromLevelEditor(const std::string& fileName) {
//	JsonLoader* file = nullptr;
//	LevelData* levelData = file->LoadFile(fileName);
//
//	//IuWFNgzu
//	for (auto& objectData : levelData->objects) {
//		//t@Co^Ï‚İƒf
//		Model* model = nullptr;
//		decltype(models)::iterator it = models.find(objectData.fileName);
//		if (it != models.end()) { model = it->second; }
//		//fwè‚µ3DObjectğ¶
//		Object3d* newObject = Object3d::Create();
//		newObject->Initialize();
//		newObject->SetModel(model);
//		//W
//		Vector3 pos;
//		pos = Vector3(objectData.translation.x, objectData.translation.y, objectData.translation.z);
//		newObject->SetPosition(pos);
//		//]p
//		Vector3 rot;
//		rot = Vector3(objectData.rotation.x, objectData.rotation.y, objectData.rotation.z);
//		newObject->SetRotation(rot);
//		//XP[
//		Vector3 scale;
//		scale = Vector3(objectData.scaling.x, objectData.scaling.y, objectData.scaling.z);
//		newObject->SetScale(scale);
//		//zÉ“o^
//		objects.push_back(newObject);
//	}
//}
</file_content>

<file_content path="engine/scene/GameScene.h">
#pragma once
#include "Sprite.h"
#include "Object3d.h"
#include"WinApp.h"
#include"DirectXCommon.h"
#include "Object3d.h"
#include "Input.h"
#include "time.h"
#include <random>
#include "Model.h"
#include "ViewProjection.h"
#include "Particle.h"
#include "ParticleManager.h"
#include "FbxObject3d.h"
#include "FbxModel.h"
#include "Player.h"
#include "RailCamera.h"
#include "Enemy.h"
#include "CollisionManager.h"
#include "Boss.h"
#include "JsonLoader.h"	
#include "energy.h"
#include "GameBaseScene.h"


class GameScene : public GameBaseScene {
public:
	//oÖ
	GameScene();

	~GameScene();

	void Initialize() override;
	/*void LoadObjFromLevelEditor(const std::string& fileName);*/

	void Update();

	void Draw();
	void Reset();
	void Finalize()override;

	void LoadStage(int stageNum);
	void LoadEnemy(int stageNum);
	void SerchEnemy();
	void LockedClear();
	void GetCrosshair();
	static void PopEnergy(Vector3 pos_);

	Vector3 GetScreenToWorldPos(Sprite& sprite_, RailCamera* rail);
	Vector3 GetWorldToScreenPos(Vector3 pos_, RailCamera* rail);
	Vector2 GetWorldToScreenScale(Object3d* obj, RailCamera* rail);

private:
	//base
	DirectXCommon* dxCommon_ = nullptr;
	WinApp* winApp = nullptr;
	//Í‚Ìƒ|C^
	Input* input = nullptr;
	//XvCgÌƒ|C^
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite titleGH;
	Sprite crosshair[4];
	Sprite hp;
	Sprite clearGH;
	Sprite overGH;
	Sprite lock[10];
	Sprite fade;
	float fadeAlpha;
	Sprite bossHP;
	Sprite gage;
	Sprite gageBack;
	Sprite hpBack;
	Sprite fadeout;
	//IuWFNgÌƒ|C^
	//3DIuWFNg
	Player* player = nullptr;
	Enemy* enemy = nullptr;
	Model* skyModel = nullptr;
	Model* seaModel = nullptr;
	Model* block01Model = nullptr;
	Model* block02Model = nullptr;
	Model* stoneModel = nullptr;
	Boss* boss = nullptr;
	//J
	ViewProjection* viewProjection = nullptr;
	XMViewProjection* xmViewProjection = nullptr;
	RailCamera* railCamera = nullptr;
	Vector3 cameraTmpPos;
	Vector3 cameraTmpRot;
	//p[eBN
	Particle* particle = nullptr;
	ParticleManager* pm = nullptr;
	Particle* particle_ = nullptr;
	ParticleManager* pm_ = nullptr;
	//enemy
	std::list<std::unique_ptr<Enemy>> enemys_;
	//energy
	static std::list<std::unique_ptr<Energy>> energys_;
	static int popEnergyCount;
	//è”»
	CollisionManager* collisionManager = nullptr;
	//FBX
	FbxModel* model = nullptr;
	FbxObject3d* obj = nullptr;
	//JÚ“p[
	std::vector<Vector3> points{};
	std::vector<Vector3> pointsL;
	std::vector<Vector3> pointsR;
	std::vector<Vector3> bossPoint{};
	//Xe[W
	int stageNum = 0;
	bool isCheckPoint = false;
	bool isPlayable = false;
	//bNI
	std::vector<LockInfo> infos;
	int gameTime;
	float cursorRotate;
	//Q[Xe[^X
	enum GameState {
		MAIN,
		BOSS,
		ULT
	};
	GameState gameState;
	GameState gameState_bak;
	int bossPass;
	bool isStart;
};
</file_content>

<file_content path="engine/scene/GameSceneManager.cpp">
#include "GameSceneManager.h"

GameSceneManager::~GameSceneManager()
{
	// ÅŒÌƒV[ÌIÆ‰
	if (scene_ != nullptr) {
		scene_->Finalize();
		delete scene_;
		scene_ = nullptr;
	}
}

GameSceneManager* GameSceneManager::GetInstance() 
{
	static GameSceneManager instance;

	return &instance;
}

void GameSceneManager::Update()
{
	// \V[Ì—\ñ‚ª‚È‚
	if (nextScene_) {
		// V[ÌI
		if (scene_) {
			scene_->Finalize();

			delete scene_;
		}

		// V[Ø‚Ö‚
		scene_ = nextScene_;
		nextScene_ = nullptr;

		// V[}l[WZbg
		scene_->SetSceneManager(this);

		// V[
		scene_->Initialize();
	}

	// sV[XV
	scene_->Update();
}

void GameSceneManager::Draw()
{
	// V[Ì•`
	scene_->Draw();
}

void GameSceneManager::Destroy()
{
	if (scene_ != nullptr) {
		scene_->Finalize();
		delete scene_;
		scene_ = nullptr;
	}
}

void GameSceneManager::ChangeScene(const std::string& sceneName)
{
	assert(sceneFactory_);
	assert(nextScene_ == nullptr);

	// V[
	nextScene_ = sceneFactory_->CreateScene(sceneName);
}

</file_content>

<file_content path="engine/scene/GameSceneManager.h">
#pragma once

#include "GameBaseScene.h"
#include "AbstractSceneFactory.h"

/// <summary>
/// V[Ç—
/// </summary>
class GameSceneManager final
{
private: // oÖ
	// RXgN^
	GameSceneManager() = default;
	// fXgN^
	~GameSceneManager();

public: // oÖ
	/// <summary>
	/// XV
	/// </summary>
	void Update();

	/// <summary>
	/// `
	/// </summary>
	void Draw();

	/// <summary>
	/// V[Ì‰
	/// </summary>
	void Destroy();

public:
	// CX^XÌì¬
	static GameSceneManager* GetInstance();

private:
	// Rs[RXgN^ğ–³ŒÉ‚
	GameSceneManager(const GameSceneManager&) = delete;
	// Zqğ–³ŒÉ‚
	GameSceneManager& operator=(const GameSceneManager&) = delete;

public: // oÖ
	/// <summary>
	/// V[\
	/// </summary>
	/// <param name="sceneName">t@C</param>
	void ChangeScene(const std::string& sceneName);

	// V[t@Ng[setter
	void SetSceneFactory(AbstractSceneFactory* sceneFactory) { sceneFactory_ = sceneFactory; }

private: // oÏ
	// ÌƒV[(sV[)
	GameBaseScene* scene_ = nullptr;
	// V[
	GameBaseScene* nextScene_ = nullptr;
	// V[t@Ng[iØ‚Ä‚j
	AbstractSceneFactory* sceneFactory_ = nullptr;
};


</file_content>

<file_content path="engine/scene/GameTitleScene.cpp">
ï»¿#include "GameTitleScene.h"

using namespace DirectX;

GameTitleScene::GameTitleScene()
{
	//// ã‚µã‚¦ãƒ³ãƒ‰ã®é™çš„åˆæœŸåŒ–
	//Sound::StaticInitialize();
}

GameTitleScene::~GameTitleScene()
{
}

void GameTitleScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon_ = DirectXCommon::GetInstance();
	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon_->GetDevice());

	//titleã®ç”»åƒ
	title.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 0, Vector2(0.0f, 0.0f), false, false);
	title.SetScale(Vector2(1280 * 1, 720 * 1));
	title.SetPosition({ -354,-32,0 });
	title.SpriteTransferVertexBuffer(title, 0);
	title.SpriteUpdate(title, spriteCommon_);
	title.LoadTexture(spriteCommon_, 0, L"Resources/title.png", dxCommon_->GetDevice());
	//titleèƒŒæ™¯
	for (int i = 0; i < 3; i++) {
		titleBack[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, i + 1, Vector2(0.0f, 0.0f), false, false);
		titleBack[i].SetScale(Vector2(1280 * 1.1, 720 * 1.7));
		titleBack[i].SetPosition({ -418,-192,0 });
		titleBack[i].SpriteTransferVertexBuffer(titleBack[i], i + 1);
		titleBack[i].SpriteUpdate(titleBack[i], spriteCommon_);
	}
	titleBack[0].LoadTexture(spriteCommon_, 1, L"Resources/titleBack.png", dxCommon_->GetDevice());
	titleBack[1].LoadTexture(spriteCommon_, 2, L"Resources/titleBack2.png", dxCommon_->GetDevice());
	titleBack[2].LoadTexture(spriteCommon_, 3, L"Resources/titleBack3.png", dxCommon_->GetDevice());
	//ã‚«ãƒ¼ã‚½ãƒ«
	for (int i = 0; i < 9; i++) {
		cursor[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 4, Vector2(0.5f, 0.5f), false, false);
		cursor[i].SetScale(Vector2(48 * 1, 48 * 1));
		cursor[i].SetPosition(Input::GetInstance()->GetMousePos());
		cursor[i].SetAlpha(cursor[i], 1 - (i * 0.1f));
		cursor[i].SpriteTransferVertexBuffer(cursor[i], 4);
		cursor[i].SpriteUpdate(cursor[i], spriteCommon_);
		cursor[i].LoadTexture(spriteCommon_, 4, L"Resources/cursor.png", dxCommon_->GetDevice());
	}
	//ã‚¯ãƒªãƒƒã‚¯
	for (int i = 0; i < 2; i++) {
		click[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 5+i, Vector2(0.5f, 0.5f), false, false);
		click[i].SetScale(Vector2(312.0f * 1.2f, 52.0f * 1.2f));
		click[i].SetPosition({ 640,640,0 });
		click[i].SpriteTransferVertexBuffer(click[i], 5+i);
		click[i].SpriteUpdate(click[i], spriteCommon_);
	}
	click[0].LoadTexture(spriteCommon_, 5, L"Resources/click1.png", dxCommon_->GetDevice());
	click[1].LoadTexture(spriteCommon_, 6, L"Resources/click2.png", dxCommon_->GetDevice());
	//ã‚«ãƒ¼ã‚½ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	circle.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 7, Vector2(0.5f, 0.5f), false, false);
	circle.SetScale(Vector2(48 * circleSize, 48 * circleSize));
	circle.SetPosition({ 0,0,0 });
	circle.SpriteTransferVertexBuffer(circle, 7);
	circle.SpriteUpdate(circle, spriteCommon_);
	circle.LoadTexture(spriteCommon_, 7, L"Resources/circle.png", dxCommon_->GetDevice());
	//ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	fade.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 8, Vector2(0.0f, 0.0f), false, false);
	fade.SetScale(Vector2(1280 * 1, 1120 * 1));
	fade.SetPosition({ 0,-1120,0 });
	fade.SpriteTransferVertexBuffer(fade, 8);
	fade.SpriteUpdate(fade, spriteCommon_);
	fade.LoadTexture(spriteCommon_, 8, L"Resources/fade.png", dxCommon_->GetDevice());
	//loading
	loading.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 9, Vector2(0.0f, 0.0f), false, false);
	loading.SetScale(Vector2(256 * 1, 48 * 1));
	loading.SetPosition({ 1000,600,0 });
	loading.SpriteTransferVertexBuffer(loading, 9);
	loading.LoadTexture(spriteCommon_, 9, L"Resources/loading.png", dxCommon_->GetDevice());


	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetPosition({ 0.0f,33.3f,288.0f });
	player->SetRotation({ 0,90,0 });

	//ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–
	viewProjection = new ViewProjection();
	viewProjection->Initialize();
	viewProjection->SetEye({ 3.5f,34.5f,298.0f });
	viewProjection->SetTarget({0,40,-400});

	//ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	skyModel = Model::LoadFromOBJ("sky");
	seaModel = Model::LoadFromOBJ("sea");
	block01Model = Model::LoadFromOBJ("block01");
	block02Model = Model::LoadFromOBJ("block02");
	stoneModel = Model::LoadFromOBJ("stone");
	models.insert(std::make_pair("sky", skyModel));
	models.insert(std::make_pair("sea", seaModel));
	models.insert(std::make_pair("block01", block01Model));
	models.insert(std::make_pair("block02", block02Model));
	models.insert(std::make_pair("stone", stoneModel));
	//ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿èª­ã¿è¾¼ã¿
	LoadObjFromLevelEditor("title");
	gameTimer = 0;
	isBackNum = 0;
	onCursor = false;
	isNext = false;
	circleSize = 1.0f;
}

void GameTitleScene::Update()
{
	if (isNext == false) {
		Vector3 cur = Input::GetInstance()->GetMousePos();
		cursor[8].SetPosition(cursor[7].GetPosition());
		cursor[7].SetPosition(cursor[6].GetPosition());
		cursor[6].SetPosition(cursor[5].GetPosition());
		cursor[5].SetPosition(cursor[4].GetPosition());
		cursor[4].SetPosition(cursor[3].GetPosition());
		cursor[3].SetPosition(cursor[2].GetPosition());
		cursor[2].SetPosition(cursor[1].GetPosition());
		cursor[1].SetPosition(cursor[0].GetPosition());
		cursor[0].SetPosition(cur);
		circle.SetPosition(cur);
		if (Input::GetInstance()->TriggerMouseLeft() == true) {
			circleSize = 1.0f;
		}
		else if (circleSize < 6.0f) {
			circleSize += 0.1f;
		}
		else {
			circleSize = 1.0f;
		}
		circle.SetScale(Vector2(64 * circleSize, 64 * circleSize));
		circle.SpriteTransferVertexBuffer(circle, 7);
		circle.SpriteUpdate(circle, spriteCommon_);
		for (int i = 0; i < 9; i++) {
			cursor[i].SpriteUpdate(cursor[i], spriteCommon_);
		}
		//ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
		if (cur.x > click[0].GetPosition().x - 156 && cur.x < click[0].GetPosition().x + 156) {
			if (cur.y > click[0].GetPosition().y - 26 && cur.y < click[0].GetPosition().y + 26) {
				if (onCursor == false) {
					onCursor = true;
				}
				if (Input::GetInstance()->TriggerMouseLeft()) {
					isNext = true;
					gameTimer = 0;
				}
			}
			else {
				if (onCursor == true) {
					onCursor = false;
				}
			}
		}
		else {
			if (onCursor == true) {
				onCursor = false;
			}
		}
		//ã‚¿ã‚¤ãƒˆãƒ«æ¼”å‡º
		if (gameTimer % 8 == 0) {
			if (isBackNum < 2) {
				isBackNum++;
			}
			else if (isBackNum == 2) {
				isBackNum = 0;
			}
		}
		title.SpriteUpdate(title, spriteCommon_);
		for (int i = 0; i < 3; i++) {
			titleBack[i].SpriteUpdate(titleBack[i], spriteCommon_);
		}
		//ã‚¯ãƒªãƒƒã‚¯
		for (int i = 0; i < 2; i++) {
			click[i].SpriteUpdate(click[i], spriteCommon_);
		}

		//æ›´æ–°
		for (auto& object : objects) {
			object->Update();
		}
		if (gameTimer < 50) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.005f, 0));
		}
		else if (gameTimer < 100) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.005f, 0));
		}
		gameTimer++;
		if (gameTimer > 100) {
			gameTimer = 0;
		}
	}
	else {
		//ã‚·ãƒ¼ãƒ³é·ç§»
		if (gameTimer < 10) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.0075f, 0));
		}
		else if (gameTimer < 25) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.01f, 0));
		}
		else if (gameTimer < 75) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.0025f, 0));
		}
		else if(player->GetPosition().y < 60.0f) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.8f, 0));
			viewProjection->SetTarget(viewProjection->GetTarget() + Vector3(0,3.0f,0));
		}
		else if (fade.GetPosition().y < 0) {
			fade.SetPosition(fade.GetPosition() + Vector3(0, +40, 0));
			fade.SpriteUpdate(fade, spriteCommon_);
		}
		else {
			loading.SpriteUpdate(loading, spriteCommon_);
			//æ¬¡ã‚·ãƒ¼ãƒ³ã¸
			GameSceneManager::GetInstance()->ChangeScene("GAMEPLAY");
		}
		gameTimer++;
	}
	//æ›´æ–°
	player->worldTransform_.UpdateMatrix();
	viewProjection->UpdateMatrix();
}

void GameTitleScene::Draw()
{
	dxCommon_->PreDraw();

	Object3d::PreDraw(dxCommon_->GetCommandList());

	player->Draw(viewProjection);
	//èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	for (auto& object : objects) {
		object->Draw(viewProjection);
	}

	Object3d::PostDraw();

	Sprite::PreDraw(dxCommon_->GetCommandList(), spriteCommon_);
	if (isNext == false) {
		titleBack[isBackNum].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		title.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		if (onCursor == false) {
			click[0].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
		else {
			click[1].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
		circle.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		for (int i = 0; i < 9; i++) {
			cursor[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
   }
	else {
		fade.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		loading.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}

	Sprite::PostDraw();

	dxCommon_->PostDraw();
}

void GameTitleScene::Finalize()
{

}
</file_content>

<file_content path="engine/scene/GameTitleScene.h">
ï»¿#pragma once

#include "DirectXCommon.h"
#include "Input.h"
#include "Sprite.h"
#include "GameBaseScene.h"
#include "GameSceneManager.h"
#include "GameScene.h"
#include "viewProjection.h"
#include "Player.h"


#include <DirectXMath.h>

class GameTitleScene : public GameBaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	GameTitleScene();

	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~GameTitleScene();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// è§£æ”¾
	/// </summary>
	void Finalize() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// å…¥åŠ›
	Input* input_ = nullptr;
	DirectXCommon* dxCommon_ = nullptr;


	//ã‚«ãƒ¡ãƒ©
	ViewProjection* viewProjection = nullptr;

	//ã‚«ãƒ¼ã‚½ãƒ«
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite title;
	Sprite titleBack[3];
	Sprite cursor[9];
	Sprite click[2];
	Sprite circle;
	Sprite fade;
	Sprite loading;

	Model* skyModel = nullptr;
	Model* seaModel = nullptr;
	Model* block01Model = nullptr;
	Model* block02Model = nullptr;
	Model* stoneModel = nullptr;
	Player* player = nullptr;

	int gameTimer;
	int isBackNum;
	bool onCursor;
	bool isNext;
	float circleSize;
};

</file_content>

<file_content path="engine/scene/SIFrameWork.cpp">
#include "SIFrameWork.h"

void SIFrameWork::Initialize()
{
	// WindowsAPIÌ
	winApp = WinApp::GetInstance();
	winApp->Initialize();

	// DirectXÌ
	dxCommon = DirectXCommon::GetInstance();
	dxCommon->Initialize(winApp);

	// Í‚Ì
	input = Input::GetInstance();
	input->Initialize(winApp);
	//3DIuWFNgÃ“I
	Object3d::StaticInitialize(dxCommon->GetDevice(), WinApp::window_width, WinApp::window_height);
	// r[vWFNVÌ
	ViewProjection::StaticInitialize(dxCommon->GetDevice());
	// V[}l[WÌ
	sceneManager_ = GameSceneManager::GetInstance();
	// p[eBNÃ“I
	ParticleManager::StaticInitialize(dxCommon->GetDevice());
	//fbxÄ—p
	FbxLoader::GetInstance()->Initialize(dxCommon->GetDevice());
	//
	FbxObject3d::StaticInitialize(dxCommon->GetDevice());

	/*postEffect.Initialize(dxCommon->GetDevice());*/
	
}

void SIFrameWork::Finalize()
{
	sceneManager_->Destroy();
	//V[t@NgÌ‰
	delete sceneFactory_;

	// WindowsAPIÌI
	winApp->Finalize();

	// DirectX
	dxCommon->fpsFixedFinalize();
}

void SIFrameWork::Update()
{
	// WindowsÌƒbZ[W
	if (winApp->ProcessMessage()) {
		// Q[[vğ”²‚
		endRequest = true;
	}

	// Í‚ÌXV
	input->Update();

	if (Input::GetInstance()->TriggerKey(DIK_ESCAPE)) {
		endRequest = true;
	}

	// V[}l[WÌXV
	sceneManager_->Update();
}

void SIFrameWork::Run()
{
	// Q[Ì
	Initialize();

	while (true) // Q[[v 
	{
		// t[XV
		Update();

		// INGXgçƒ‹[vğ”²‚
		if (IsEndRequest()) {
			// Q[[vğ”²‚
			break;
		}

		// `
		Draw();
	}

	// Q[ÌI
	Finalize();
}

</file_content>

<file_content path="engine/scene/SIFrameWork.h">
#pragma once
#include"Input.h"
#include"WinApp.h"
#include"DirectXCommon.h"
#include "Sprite.h"
#include "Object3d.h"
#include "FbxObject3d.h"
#include"Model.h"
#include "ParticleManager.h"
#include "FbxLoader.h"
#include "AbstractSceneFactory.h"
#include "GameSceneManager.h"

class SIFrameWork
{
public://oÖ
	//
	virtual void Initialize();
	//I
	virtual void Finalize();
	//XV
	virtual void Update();
	//`
	virtual void Draw() = 0;
	//I`FbN
	virtual bool IsEndRequest() { return endRequest; }

public:
	virtual ~SIFrameWork() = default;

public:
	//s
	void Run();

protected:
	//WindowsAPIÌƒ|C^
	WinApp* winApp = nullptr;
	//DirectXÌƒ|C^
	DirectXCommon* dxCommon = nullptr;
	//Í‚Ìƒ|C^
	Input* input = nullptr;
	// V[}l[W
	GameSceneManager* sceneManager_ = nullptr;
	// V[t@Ng[
	AbstractSceneFactory* sceneFactory_ = nullptr;
private:
	bool endRequest = false;
};


</file_content>

<file_content path="engine/scene/SceneFactory.cpp">
#include "SceneFactory.h"

GameBaseScene* SceneFactory::CreateScene(const std::string& sceneName)
{
    // ÌƒV[
    GameBaseScene* newScene = nullptr;

    if (sceneName == "TITLE") {
        newScene = new GameTitleScene();
    }
    else if (sceneName == "GAMEPLAY") {
        newScene = new GameScene();
    }
    else if (sceneName == "CLEAR") {
        newScene = new GameClearScene();
    }
    else if (sceneName == "OVER") {
        newScene = new GameOverScene();
    }

    return newScene;
}

</file_content>

<file_content path="engine/scene/SceneFactory.h">
#pragma once

#include "AbstractSceneFactory.h"
#include "GameTitleScene.h"
#include "GameScene.h"
#include "GameClearScene.h"
#include "GameOverScene.h"

/// <summary>
/// ÌƒQ[pÌƒV[H
/// </summary>
class SceneFactory : public AbstractSceneFactory
{
public:
	/// <summary>
	/// V[
	/// </summary>
	/// <param name="sceneName">V[</param>
	/// <returns></returns>
	GameBaseScene* CreateScene(const std::string& sceneName) override;
};


</file_content>

<file_content path="main.cpp">
#include "Game.h"


int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
	SIFrameWork* game = new Game();

	game->Run();

	delete game;

	return 0;
}
</file_content>

