### ğŸŒ³ Codebase File Tree (Physical Structure)

â”œâ”€â”€ ./
â”‚   â””â”€â”€ CG2_DirectXGame.vcxproj
â”‚   â””â”€â”€ CG2_DirectXGame.vcxproj.filters
â”‚   â””â”€â”€ main.cpp
â”‚   â”œâ”€â”€ engine/
â”‚   â”‚   â”œâ”€â”€ collision/
â”‚   â”‚   â”‚   â””â”€â”€ CollisionTypes.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionPrimitive.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionManager.h
â”‚   â”‚   â”‚   â””â”€â”€ Collision.h
â”‚   â”‚   â”‚   â””â”€â”€ BaseCollider.h
â”‚   â”‚   â”‚   â””â”€â”€ SphereCollider.cpp
â”‚   â”‚   â”‚   â””â”€â”€ SphereCollider.h
â”‚   â”‚   â”‚   â””â”€â”€ Collision.cpp
â”‚   â”‚   â”‚   â””â”€â”€ CollisionInfo.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionPrimitive.cpp
â”‚   â”‚   â”‚   â””â”€â”€ RaycastHit.h
â”‚   â”‚   â”‚   â””â”€â”€ CollisionManager.cpp
â”‚   â”‚   â”œâ”€â”€ math/
â”‚   â”‚   â”‚   â””â”€â”€ Vector2.h
â”‚   â”‚   â”‚   â””â”€â”€ Vector2.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Vector4.h
â”‚   â”‚   â”‚   â””â”€â”€ Matrix4.h
â”‚   â”‚   â”‚   â””â”€â”€ Spline.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Vector3.h
â”‚   â”‚   â”‚   â””â”€â”€ Matrix4.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Spline.h
â”‚   â”‚   â”‚   â””â”€â”€ Vector4.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Vector3.cpp
â”‚   â”‚   â”œâ”€â”€ scene/
â”‚   â”‚   â”‚   â””â”€â”€ GameSceneManager.h
â”‚   â”‚   â”‚   â””â”€â”€ Game.h
â”‚   â”‚   â”‚   â””â”€â”€ SIFrameWork.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameTitleScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameClearScene.h
â”‚   â”‚   â”‚   â””â”€â”€ GameClearScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ SIFrameWork.h
â”‚   â”‚   â”‚   â””â”€â”€ GameBaseScene.h
â”‚   â”‚   â”‚   â””â”€â”€ GameTitleScene.h
â”‚   â”‚   â”‚   â””â”€â”€ SceneFactory.h
â”‚   â”‚   â”‚   â””â”€â”€ AbstractSceneFactory.h
â”‚   â”‚   â”‚   â””â”€â”€ GameOverScene.h
â”‚   â”‚   â”‚   â””â”€â”€ SceneFactory.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Game.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameScene.h
â”‚   â”‚   â”‚   â””â”€â”€ GameOverScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameBaseScene.cpp
â”‚   â”‚   â”‚   â””â”€â”€ GameSceneManager.cpp
â”‚   â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”‚   â””â”€â”€ JsonLoader.h
â”‚   â”‚   â”‚   â””â”€â”€ Input.cpp
â”‚   â”‚   â”‚   â””â”€â”€ DirectXCommon.cpp
â”‚   â”‚   â”‚   â””â”€â”€ DirectXCommon.h
â”‚   â”‚   â”‚   â””â”€â”€ FPSFixed.h
â”‚   â”‚   â”‚   â””â”€â”€ Input.h
â”‚   â”‚   â”‚   â””â”€â”€ WinApp.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FPSFixed.cpp
â”‚   â”‚   â”‚   â””â”€â”€ JsonLoader.cpp
â”‚   â”‚   â”‚   â””â”€â”€ WinApp.h
â”‚   â”‚   â”œâ”€â”€ 2d/
â”‚   â”‚   â”‚   â””â”€â”€ Sprite.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Sprite.h
â”‚   â”‚   â”œâ”€â”€ 3d/
â”‚   â”‚   â”‚   â””â”€â”€ PlayerBullet.cpp
â”‚   â”‚   â”‚   â””â”€â”€ EnemyBullet.h
â”‚   â”‚   â”‚   â””â”€â”€ XMViewProjection.h
â”‚   â”‚   â”‚   â””â”€â”€ Boss.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Player.h
â”‚   â”‚   â”‚   â””â”€â”€ Object3d.h
â”‚   â”‚   â”‚   â””â”€â”€ Energy.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FbxLoader.h
â”‚   â”‚   â”‚   â””â”€â”€ Model.h
â”‚   â”‚   â”‚   â””â”€â”€ FbxModel.h
â”‚   â”‚   â”‚   â””â”€â”€ PlayerBullet.h
â”‚   â”‚   â”‚   â””â”€â”€ Player.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Model.cpp
â”‚   â”‚   â”‚   â””â”€â”€ EnemyBullet.cpp
â”‚   â”‚   â”‚   â””â”€â”€ WorldTransform.cpp
â”‚   â”‚   â”‚   â””â”€â”€ ViewProjection.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FbxModel.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Enemy.h
â”‚   â”‚   â”‚   â””â”€â”€ FbxObject3d.cpp
â”‚   â”‚   â”‚   â””â”€â”€ RailCamera.h
â”‚   â”‚   â”‚   â””â”€â”€ Energy.h
â”‚   â”‚   â”‚   â””â”€â”€ Boss.h
â”‚   â”‚   â”‚   â””â”€â”€ RailCamera.cpp
â”‚   â”‚   â”‚   â””â”€â”€ Enemy.cpp
â”‚   â”‚   â”‚   â””â”€â”€ XMViewProjection.cpp
â”‚   â”‚   â”‚   â””â”€â”€ BossBullet.h
â”‚   â”‚   â”‚   â””â”€â”€ BossBullet.cpp
â”‚   â”‚   â”‚   â””â”€â”€ WorldTransform.h
â”‚   â”‚   â”‚   â””â”€â”€ Object3d.cpp
â”‚   â”‚   â”‚   â””â”€â”€ FbxObject3d.h
â”‚   â”‚   â”‚   â””â”€â”€ ViewProjection.h
â”‚   â”‚   â”‚   â””â”€â”€ FbxLoader.cpp
â”‚   â”‚   â”œâ”€â”€ effect/
â”‚   â”‚   â”‚   â””â”€â”€ Particle.cpp
â”‚   â”‚   â”‚   â””â”€â”€ PostEffect.cpp
â”‚   â”‚   â”‚   â””â”€â”€ ParticleManager.cpp
â”‚   â”‚   â”‚   â””â”€â”€ ParticleManager.h
â”‚   â”‚   â”‚   â””â”€â”€ Particle.h
â”‚   â”‚   â”‚   â””â”€â”€ PostEffect.h
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ scene/
â”‚   â”‚   â”‚   â””â”€â”€ BaseScene.h
â”‚   â”‚   â”‚   â””â”€â”€ BaseScene.cpp
â”‚   â”‚   â”œâ”€â”€ platform/
â”‚   â”‚   â”‚   â””â”€â”€ Framework.h
â”‚   â”‚   â”‚   â””â”€â”€ Framework.cpp

============================================================
FILE CONTENTS START BELOW
============================================================

<file_content path="CG2_DirectXGame.vcxproj">
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e2b32998-cddf-4587-aac4-cfebbfbd82fd}</ProjectGuid>
    <RootNamespace>CG2DirectXGame</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir)engine\external\DirectXTex\include;$(ProjectDir)engine\external\fbx_sdk\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)engine\external\fbx_sdk\lib\Debug;$(ProjectDir)engine\external\DirectXTex\lib\Debug;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\Generated\Obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\Generated\Output\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)engine\external\DirectXTex\include;$(ProjectDir)engine\external\fbx_sdk\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)engine\external\fbx_sdk\lib\Release;$(ProjectDir)engine\external\DirectXTex\lib\Release;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\Generated\Obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\Generated\Output\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)app\scene;$(ProjectDir)app\platform;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\base;$(ProjectDir)engine\effect;$(ProjectDir)engine\math;$(ProjectDir)engine\collision;$(ProjectDir)engine\scene</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-md.lib;libxml2-md.lib;zlib-md.lib;DirectXTex.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_ITERATOR_DEBUG_LEVEL=2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)app\scene;$(ProjectDir)app\platform;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\base;$(ProjectDir)engine\effect;$(ProjectDir)engine\math;$(ProjectDir)engine\collision;$(ProjectDir)engine\scene</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <UndefineAllPreprocessorDefinitions>false</UndefineAllPreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/IGNORE:4099 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>libfbxsdk-md.lib;libxml2-md.lib;zlib-md.lib;DirectXTex.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="app\platform\Framework.cpp" />
    <ClCompile Include="app\scene\BaseScene.cpp" />
    <ClCompile Include="engine\3d\Boss.cpp" />
    <ClCompile Include="engine\3d\BossBullet.cpp" />
    <ClCompile Include="engine\3d\Enemy.cpp" />
    <ClCompile Include="engine\3d\EnemyBullet.cpp" />
    <ClCompile Include="engine\3d\Energy.cpp" />
    <ClCompile Include="engine\3d\Player.cpp" />
    <ClCompile Include="engine\3d\PlayerBullet.cpp" />
    <ClCompile Include="engine\3d\RailCamera.cpp" />
    <ClCompile Include="engine\base\DirectXCommon.cpp" />
    <ClCompile Include="engine\base\FPSFixed.cpp" />
    <ClCompile Include="engine\base\Input.cpp" />
    <ClCompile Include="engine\base\JsonLoader.cpp" />
    <ClCompile Include="engine\collision\Collision.cpp" />
    <ClCompile Include="engine\collision\CollisionManager.cpp" />
    <ClCompile Include="engine\collision\CollisionPrimitive.cpp" />
    <ClCompile Include="engine\collision\SphereCollider.cpp" />
    <ClCompile Include="engine\effect\PostEffect.cpp" />
    <ClCompile Include="engine\math\Spline.cpp" />
    <ClCompile Include="engine\scene\Game.cpp" />
    <ClCompile Include="engine\scene\GameBaseScene.cpp" />
    <ClCompile Include="engine\scene\GameClearScene.cpp" />
    <ClCompile Include="engine\scene\GameOverScene.cpp" />
    <ClCompile Include="engine\scene\GameSceneManager.cpp" />
    <ClCompile Include="engine\scene\GameTitleScene.cpp" />
    <ClCompile Include="engine\scene\SceneFactory.cpp" />
    <ClCompile Include="engine\scene\SIFrameWork.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="engine\math\Matrix4.cpp" />
    <ClCompile Include="engine\3d\Model.cpp" />
    <ClCompile Include="engine\3d\Object3d.cpp" />
    <ClCompile Include="engine\effect\Particle.cpp" />
    <ClCompile Include="engine\effect\ParticleManager.cpp" />
    <ClCompile Include="engine\2d\Sprite.cpp" />
    <ClCompile Include="engine\math\Vector2.cpp" />
    <ClCompile Include="engine\math\Vector3.cpp" />
    <ClCompile Include="engine\math\Vector4.cpp" />
    <ClCompile Include="engine\3d\ViewProjection.cpp" />
    <ClCompile Include="engine\base\WinApp.cpp" />
    <ClCompile Include="engine\scene\GameScene.cpp" />
    <ClCompile Include="engine\3d\WorldTransform.cpp" />
    <ClCompile Include="engine\3d\XMViewProjection.cpp" />
    <ClCompile Include="engine\3d\FbxLoader.cpp" />
    <ClCompile Include="engine\3d\FbxModel.cpp" />
    <ClCompile Include="engine\3d\FbxObject3d.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\shaders\Basic.hlsli" />
    <None Include="Resources\shaders\FBX.hlsli" />
    <None Include="Resources\shaders\OBJ.hlsli" />
    <None Include="Resources\shaders\Particle.hlsli" />
    <None Include="Resources\shaders\PostEffect.hlsli" />
    <None Include="Resources\shaders\Sprite.hlsli" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\BasicPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\BasicVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXPS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXVS.hlsl">
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleGS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Geometry</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Geometry</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Geometry</ShaderType>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticlePS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectPS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpritePS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpriteVS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="app\platform\Framework.h" />
    <ClInclude Include="app\scene\BaseScene.h" />
    <ClInclude Include="engine\3d\Boss.h" />
    <ClInclude Include="engine\3d\BossBullet.h" />
    <ClInclude Include="engine\3d\Enemy.h" />
    <ClInclude Include="engine\3d\EnemyBullet.h" />
    <ClInclude Include="engine\3d\Energy.h" />
    <ClInclude Include="engine\3d\Player.h" />
    <ClInclude Include="engine\3d\PlayerBullet.h" />
    <ClInclude Include="engine\3d\RailCamera.h" />
    <ClInclude Include="engine\base\DirectXCommon.h" />
    <ClInclude Include="engine\base\FPSFixed.h" />
    <ClInclude Include="engine\base\Input.h" />
    <ClInclude Include="engine\base\json.hpp" />
    <ClInclude Include="engine\base\JsonLoader.h" />
    <ClInclude Include="engine\collision\BaseCollider.h" />
    <ClInclude Include="engine\collision\Collision.h" />
    <ClInclude Include="engine\collision\CollisionInfo.h" />
    <ClInclude Include="engine\collision\CollisionManager.h" />
    <ClInclude Include="engine\collision\CollisionPrimitive.h" />
    <ClInclude Include="engine\collision\CollisionTypes.h" />
    <ClInclude Include="engine\collision\RaycastHit.h" />
    <ClInclude Include="engine\collision\SphereCollider.h" />
    <ClInclude Include="engine\effect\PostEffect.h" />
    <ClInclude Include="engine\math\Matrix4.h" />
    <ClInclude Include="engine\3d\Model.h" />
    <ClInclude Include="engine\3d\Object3d.h" />
    <ClInclude Include="engine\effect\Particle.h" />
    <ClInclude Include="engine\effect\ParticleManager.h" />
    <ClInclude Include="engine\2d\Sprite.h" />
    <ClInclude Include="engine\math\Spline.h" />
    <ClInclude Include="engine\math\Vector2.h" />
    <ClInclude Include="engine\math\Vector3.h" />
    <ClInclude Include="engine\math\Vector4.h" />
    <ClInclude Include="engine\3d\ViewProjection.h" />
    <ClInclude Include="engine\base\WinApp.h" />
    <ClInclude Include="engine\scene\AbstractSceneFactory.h" />
    <ClInclude Include="engine\scene\Game.h" />
    <ClInclude Include="engine\scene\GameBaseScene.h" />
    <ClInclude Include="engine\scene\GameClearScene.h" />
    <ClInclude Include="engine\scene\GameOverScene.h" />
    <ClInclude Include="engine\scene\GameScene.h" />
    <ClInclude Include="engine\3d\WorldTransform.h" />
    <ClInclude Include="engine\3d\XMViewProjection.h" />
    <ClInclude Include="engine\3d\FbxLoader.h" />
    <ClInclude Include="engine\3d\FbxModel.h" />
    <ClInclude Include="engine\3d\FbxObject3d.h" />
    <ClInclude Include="engine\scene\GameSceneManager.h" />
    <ClInclude Include="engine\scene\GameTitleScene.h" />
    <ClInclude Include="engine\scene\SceneFactory.h" />
    <ClInclude Include="engine\scene\SIFrameWork.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
</file_content>

<file_content path="CG2_DirectXGame.vcxproj.filters">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{0ec641aa-dd1b-4500-8535-382c3827c462}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{8af0deee-6556-46f7-99ed-db9664eaec35}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{385839e5-4dc3-4305-b5f9-d2ff99e4d14b}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d">
      <UniqueIdentifier>{fa0a1209-5613-41f4-8336-a1b32e0bb017}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d">
      <UniqueIdentifier>{c9e7a42e-e554-4643-b452-9d37989931a1}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base">
      <UniqueIdentifier>{ef959771-e341-4b66-b050-784b8557adaa}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math">
      <UniqueIdentifier>{c5ed0df1-7d03-4dcc-9231-f51298ef7b4f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene">
      <UniqueIdentifier>{6bef14bd-ffae-4ac6-9aee-6e82cdf7d056}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect">
      <UniqueIdentifier>{436c057a-8f47-423b-8489-b9aceefb13ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform">
      <UniqueIdentifier>{46d387be-bb6f-44f2-acdc-483e1b27f2b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene">
      <UniqueIdentifier>{0554bbb1-90f0-423b-b877-043bcaaa4592}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application">
      <UniqueIdentifier>{2e619881-ee64-4395-9e02-763883744995}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine">
      <UniqueIdentifier>{dbabf37a-58f2-44ee-90e9-abbd314ee416}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math">
      <UniqueIdentifier>{0025325f-b1da-41dc-8b22-11a61d4549fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene">
      <UniqueIdentifier>{5855e325-0d99-4092-bf18-d5326cc03816}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect">
      <UniqueIdentifier>{3285a7bc-7645-4c4c-a945-e02fdeece07d}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base">
      <UniqueIdentifier>{df34dcd6-551e-4994-8c34-9780c07caa06}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d">
      <UniqueIdentifier>{b1febb7f-4466-46af-aa04-d3bf26ecbdbf}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d">
      <UniqueIdentifier>{5138cc02-99cf-4f0f-bdef-c2321640aa1c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform">
      <UniqueIdentifier>{5d923fb2-2d4d-47e6-ac8a-df6b18b95a2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene">
      <UniqueIdentifier>{bcb6b033-1690-4db6-a7a7-f0e436506639}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj">
      <UniqueIdentifier>{db1e4cf1-5bc3-450f-8d25-9e3810865cb0}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj">
      <UniqueIdentifier>{f3046790-de45-420a-9f52-00891842d0ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera">
      <UniqueIdentifier>{d39ca11e-0299-46e3-9634-f3dae2283183}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera">
      <UniqueIdentifier>{564b3b6e-4c8d-4015-879a-b2fe90bba468}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision">
      <UniqueIdentifier>{6d468e4a-84a8-4f43-aa92-3bd8a1d2e728}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision">
      <UniqueIdentifier>{9db64233-bb0d-4897-ba7c-418dd1007c1e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\Sprite.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3d.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Input.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Matrix4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector2.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector3.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Vector4.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\WorldTransform.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Model.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\Particle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\ParticleManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxModel.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\FbxObject3d.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="app\scene\BaseScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene</Filter>
    </ClCompile>
    <ClCompile Include="app\platform\Framework.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Spline.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Player.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\XMViewProjection.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ViewProjection.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\RailCamera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\PlayerBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Enemy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\Collision.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\CollisionManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\CollisionPrimitive.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\collision\SphereCollider.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\WinApp.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\EnemyBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Boss.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\FPSFixed.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\JsonLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClCompile>
    <ClCompile Include="engine\effect\PostEffect.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\BossBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Energy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\Game.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameBaseScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameClearScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameSceneManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameTitleScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SceneFactory.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SIFrameWork.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\GameOverScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\shaders\Basic.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\Sprite.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\OBJ.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\Particle.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\FBX.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\shaders\PostEffect.hlsli">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\BasicPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\BasicVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpritePS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\SpriteVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\OBJVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleGS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticlePS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\ParticleVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\FBXVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectPS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\PostEffectVS.hlsl">
      <Filter>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine\2d\Sprite.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Input.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\WinApp.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3d.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Matrix4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Model.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector2.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector3.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\WorldTransform.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\Particle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\ParticleManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxModel.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\FbxObject3d.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="app\platform\Framework.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\platform</Filter>
    </ClInclude>
    <ClInclude Include="app\scene\BaseScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Application\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Spline.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Player.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\XMViewProjection.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ViewProjection.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\RailCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\PlayerBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Enemy.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\BaseCollider.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\Collision.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionInfo.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionPrimitive.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\CollisionTypes.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\RaycastHit.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\collision\SphereCollider.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\EnemyBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\FPSFixed.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\JsonLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\json.hpp">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Base</Filter>
    </ClInclude>
    <ClInclude Include="engine\effect\PostEffect.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\Effect</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\BossBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Boss.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Energy.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameObj</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\AbstractSceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\Game.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameBaseScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameClearScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameSceneManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameTitleScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SIFrameWork.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\GameOverScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\Engine\GameScene</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
</file_content>

<file_content path="app/platform/Framework.cpp">
#include "Framework.h"

void Framework::Run()
{
	// ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
	Initialize();

	while (true) // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— 
	{
		// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
		Update();

		// çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæ¥ãŸã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		if (IsEndRequest()) {
			// ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			break;
		}
		if (input->TriggerKey(DIK_ESCAPE)) {
			// ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			break;
		}

		// æç”»
		Draw();
	}

	// ã‚²ãƒ¼ãƒ ã®çµ‚äº†
	Finalize();
}

void Framework::Initialize()
{
	// WindowsAPIã®åˆæœŸåŒ–
	winApp = WinApp::GetInstance();
	winApp->Initialize();

	// DirectXã®åˆæœŸåŒ–
	dXCommon = DirectXCommon::GetInstance();
	dXCommon->Initialize(winApp);

	// å…¥åŠ›ã®åˆæœŸåŒ–
	input = Input::GetInstance();
	input->Initialize(winApp);
	//3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé™çš„åˆæœŸåŒ–
	Object3d::StaticInitialize(dXCommon->GetDevice(), WinApp::window_width, WinApp::window_height);
	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	ViewProjection::StaticInitialize(dXCommon->GetDevice());
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é™çš„åˆæœŸåŒ–
	ParticleManager::StaticInitialize(dXCommon->GetDevice());
	//fbxæ±ç”¨åˆæœŸåŒ–
	FbxLoader::GetInstance()->Initialize(dXCommon->GetDevice());
	//
	FbxObject3d::StaticInitialize(dXCommon->GetDevice());

	postEffect.Initialize(dXCommon->GetDevice());
#pragma endregion åŸºç›¤ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–

	//ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³
	/*gameScene = new GameScene();*/
	gameScene->Initialize();
}

void Framework::Update()
{
	// Windowsã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	if (winApp->ProcessMessage()) {
		// ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		endRequest_ = true;
	}
	gameScene->Update();
	// å…¥åŠ›ã®æ›´æ–°
	/*input->Update();*/
}

void Framework::Draw()
{
#pragma region ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³æç”»


#pragma endregion

#pragma region æç”»
	postEffect.PreDrawScene(dXCommon->GetCommandList());
	gameScene->Draw();
	postEffect.PostDrawScene(dXCommon->GetCommandList());
	// æç”»å‰å‡¦ç†
	dXCommon->PreDraw();
	//=== ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³æç”» ===//
	postEffect.Draw(dXCommon->GetCommandList());
	// æç”»å¾Œå‡¦ç†
	dXCommon->PostDraw();
#pragma endregion
}

void Framework::Finalize()
{
	delete gameScene;
	FbxLoader::GetInstance()->Finalize();
	// WindowsAPIã®çµ‚äº†å‡¦ç†
	winApp->Finalize();

	// DirectXè§£æ”¾
	dXCommon->fpsFixedFinalize();
	
}

</file_content>

<file_content path="app/platform/Framework.h">
#pragma once

#include "Input.h"
#include "WinApp.h"
#include "DirectXCommon.h"
#include "Sprite.h"
#include "Model.h"
#include "Object3d.h"
#include "GameScene.h"
#include "ParticleManager.h"
#include "FbxLoader.h"
#include "FbxObject3d.h"
#include"WinApp.h"
#include"DirectXCommon.h"

#include<windows.h>
#include<cassert>
#include<vector>
#include<string>
#include<d3dcompiler.h>
#include<DirectXMath.h>
#include<dinput.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include "PostEffect.h"

#pragma comment(lib,"d3dcompiler.lib")
#pragma comment(lib,"dxguid.lib")

class Framework
{

public:
	// å®Ÿè¡Œ
	void Run();

	// åˆæœŸåŒ–
	void Initialize();

	// æ›´æ–°
	void Update();

	// æ›´æ–°
	void Draw();

	// çµ‚äº†
	void Finalize();

public:
	//ã€€çµ‚äº†ãƒã‚§ãƒƒã‚¯
	bool IsEndRequest() { return endRequest_; }

protected:
	WinApp* winApp = nullptr;
	DirectXCommon* dXCommon = nullptr;
	Input* input = nullptr;
	SpriteCommon spriteCommon;
	GameScene* gameScene = nullptr;
	PostEffect postEffect;
	ParticleManager* particleManager = nullptr;

private:
	// ã‚²ãƒ¼ãƒ çµ‚äº†ãƒ•ãƒ©ã‚°
	bool endRequest_ = false;
};

</file_content>

<file_content path="app/scene/BaseScene.cpp">
#include "BaseScene.h"

//void BaseScene::Initialize()
//{
//	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
//	Framework::Initialize();
//
//	dXCommon = DirectXCommon::GetInstance();
//
//	// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã®ç”Ÿæˆã¨åˆæœŸåŒ–
//	scene_ = new GameScene();
//	scene_->Initialize(spriteCommon);
//}
//
//void BaseScene::Update()
//{
//	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®æ›´æ–°å‡¦ç†
//	Framework::Update();
//
//	// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã®æ›´æ–°
//	scene_->Update();
//
//}
//
//void BaseScene::Draw()
//{
//#pragma region ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³æç”»
//
//	//=== ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³æç”» ===//
//	scene_->Draw();
//
//#pragma endregion
//
//#pragma region æç”»
//	// æç”»å‰å‡¦ç†
//	dXCommon->PreDraw();
//
//	// æç”»å¾Œå‡¦ç†
//	dXCommon->PostDraw();
//#pragma endregion
//}
//
//void BaseScene::Finalize()
//{
//	// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã®è§£æ”¾
//	delete scene_;
//
//	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®çµ‚äº†å‡¦ç†
//	Framework::Finalize();
//}

</file_content>

<file_content path="app/scene/BaseScene.h">
#pragma once

#include "Framework.h"

// ã‚²ãƒ¼ãƒ å…¨ä½“
class BaseScene
{
//public:
//	// åˆæœŸåŒ–
//	void Initialize() override;
//
//	// æ›´æ–°
//	void Update() override;
//
//	// æç”»
//	void Draw() override;
//
//	// çµ‚äº†
//	void Finalize() override;

};

</file_content>

<file_content path="engine/2d/Sprite.cpp">
#include "Sprite.h"

Sprite::Sprite() {

}

Sprite::~Sprite() {

}

PipelineSet Sprite::SpriteCreateGraphicsPipeline(ID3D12Device* device) 
{
	HRESULT result;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob; // ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/SpriteVS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/SpritePS.hlsl",   // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyzåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

		{ // uvåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®è¨­å®š
	CD3DX12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

	CD3DX12_ROOT_PARAMETER rootParams[2];
	rootParams[0].InitAsConstantBufferView(0);
	rootParams[1].InitAsDescriptorTable(1, &descriptorRange, D3D12_SHADER_VISIBILITY_ALL);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µãƒ³ãƒ—ãƒ©ãƒ¼ã®è¨­å®š
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //æ¨ªç¹°ã‚Šè¿”ã—ï¼ˆã‚¿ã‚¤ãƒªãƒ³ã‚°ï¼‰
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //ç¸¦ç¹°ã‚Šè¿”ã—ï¼ˆã‚¿ã‚¤ãƒªãƒ³ã‚°ï¼‰
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //å¥¥è¡Œç¹°ã‚Šè¿”ã—ï¼ˆã‚¿ã‚¤ãƒªãƒ³ã‚°ï¼‰
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK; //ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; //å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX; //ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—æœ€å¤§å€¤
	samplerDesc.MinLOD = 0.0f; //ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—æœ€å°å€¤
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; //ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	// ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¹ã‚¯ã®è¨­å®š
	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // æ¨™æº–è¨­å®š

	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;  // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
	//pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
	//pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; // RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;                   // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚’æœ‰åŠ¹ã«ã™ã‚‹
	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;    // åŠ ç®—
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;      // ã‚½ãƒ¼ã‚¹ã®å€¤ã‚’100% ä½¿ã†
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;    // ãƒ‡ã‚¹ãƒˆã®å€¤ã‚’  0% ä½¿ã†

	// åŠé€æ˜åˆæˆ
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;             // åŠ ç®—
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;         // ã‚½ãƒ¼ã‚¹ã®ã‚¢ãƒ«ãƒ•ã‚¡å€¤
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;    // 1.0f-ã‚½ãƒ¼ã‚¹ã®ã‚¢ãƒ«ãƒ•ã‚¡å€¤

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®š
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// ãã®ä»–ã®è¨­å®š
	pipelineDesc.NumRenderTargets = 1; // æç”»å¯¾è±¡ã¯1ã¤
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½255æŒ‡å®šã®RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS; // å¸¸ã«ä¸Šæ›¸ããƒ«ãƒ¼ãƒ«
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthEnable = false;

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹
	rootSignatureDesc.NumParameters = _countof(rootParams); // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ•°
	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚»ãƒƒãƒˆ
	PipelineSet pipelineSet;

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è‡ªå‹•åˆ¤å®šã§ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3D12SerializeRootSignature(
		&rootSignatureDesc, 
		D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob, 
		&errorBlob);
	assert(SUCCEEDED(result));
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	result = device->CreateRootSignature(
		0, 
		rootSigBlob->GetBufferPointer(), 
		rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&pipelineSet.rootsignature));
	assert(SUCCEEDED(result));

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	pipelineDesc.pRootSignature = pipelineSet.rootsignature.Get();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelineSet.pipelinestate));
	assert(SUCCEEDED(result));

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰è¦‹ãˆã‚‹ã‚ˆã†ã«
	descHeapDesc.NumDescriptors = 1; // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼1ã¤
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap));//ç”Ÿæˆ
	if (FAILED(result)) {
		assert(0);
	}

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’è¿”ã™
	return pipelineSet;
}

void Sprite::SpriteCreate(ID3D12Device* dev, int window_width, int window_height, 
	UINT texNumber, Vector2 anchorpoint, bool isFlipX, bool isFlipY) {

	HRESULT result = S_FALSE;

	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	VertexPosUv vertices[] = {
		{{	0.0f, 100.0f,	0.0f},{0.0f,1.0f}},
		{{	0.0f,	0.0f,	0.0f},{0.0f,0.0f}},
		{{100.0f, 100.0f,	0.0f},{1.0f,1.0f}},
		{{100.0f,	0.0f,	0.0f},{1.0f,0.0f}},
	};

	UINT sizeVB = static_cast<UINT>(sizeof(VertexPosUv) * _countof(vertices));

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapPropsVertexBuffer = 
		CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDescVertexBuffer =
		CD3DX12_RESOURCE_DESC::Buffer(sizeof(vertices));

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·ã‚’ã‚³ãƒ”ãƒ¼
	this->texNumber = texNumber;

	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	result = dev->CreateCommittedResource(
		&heapPropsVertexBuffer, // ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&resourceDescVertexBuffer, // ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	// æŒ‡å®šç•ªå·ã®ç”»åƒãŒèª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰
	if (spriteCommon_.texBuff[this->texNumber]) {
		// ãƒ†ã‚¯ã‚¹ãƒãƒ£æƒ…å ±å–å¾—
		D3D12_RESOURCE_DESC resDesc = spriteCommon_.texBuff[this->texNumber]->GetDesc();
		// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®å¤§ãã•ã‚’ç”»åƒã®è§£åƒåº¦ã«åˆã‚ã›ã‚‹
		scale = { (float)resDesc.Width,(float)resDesc.Height };
		// ãƒ†ã‚¯ã‚¹ãƒãƒ£æƒ…å ±å–å¾—
	}

	texSize_ = { (float)resDesc.Width, (float)resDesc.Height };

	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’ã‚³ãƒ”ãƒ¼
	this->anchorpoint = anchorpoint;

	// åè»¢ãƒ•ãƒ©ã‚°ã‚’ã‚³ãƒ”ãƒ¼
	this->isFlipX_ = isFlipX;
	this->isFlipY_ = isFlipY;

	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPosUv* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	vertBuff->Unmap(0, nullptr);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	// GPUä»®æƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚º
	vbView.SizeInBytes = sizeof(vertices);
	// é ‚ç‚¹1ã¤åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º
	vbView.StrideInBytes = sizeof(vertices[0]);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapPropsConstantBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDescConstantBuffer =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB0) + 0xff) & ~0xff);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = dev->CreateCommittedResource(
		&heapPropsConstantBuffer, // ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&resourceDescConstantBuffer, // ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB0));
	assert(SUCCEEDED(result));

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
	result = constBuffB0->Map(0, nullptr, (void**)&constMap); // ãƒãƒƒãƒ”ãƒ³ã‚°
	assert(SUCCEEDED(result));

	constMap->color = color_;

	// å˜ä½è¡Œåˆ—ã‚’ä»£å…¥
	constMap->mat.identity();

	// åº§æ¨™å¤‰æ›
	constMap->mat.m[0][0] = 2.0f / WinApp::window_width;
	constMap->mat.m[1][1] = -2.0f / WinApp::window_height;
	constMap->mat.m[3][0] = -1.0f;
	constMap->mat.m[3][1] = 1.0f;
}

void Sprite::PreDraw(ID3D12GraphicsCommandList* cmdList, const SpriteCommon& spriteCommon) {

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	cmdList->SetPipelineState(spriteCommon.pipelineSet.pipelinestate.Get());
	cmdList->SetGraphicsRootSignature(spriteCommon.pipelineSet.rootsignature.Get());

	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®š
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
	ID3D12DescriptorHeap* ppHeaps[] = { spriteCommon.descHeap.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
}

void Sprite::PostDraw()
{
}

void Sprite::SpriteDraw(ID3D12GraphicsCommandList* cmdList_, const SpriteCommon& spriteCommon, 
	ID3D12Device* dev) 
{
	// éè¡¨ç¤ºãƒ•ãƒ©ã‚°ãŒtrueãªã‚‰
	if (isInvisible) {
		// æç”»ã›ãšã«æŠœã‘ã‚‹
		return;
	}

	this->cmdList = cmdList_;

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ã‚»ãƒƒãƒˆ
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡(CBV)ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, constBuffB0->GetGPUVirtualAddress());

	//ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootDescriptorTable(
		1, CD3DX12_GPU_DESCRIPTOR_HANDLE(
			spriteCommon.descHeap->GetGPUDescriptorHandleForHeapStart(),
			texNumber, 
			dev->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)));

	//ãƒãƒªã‚´ãƒ³ã®æç”»(4é ‚ç‚¹ã§å››è§’å½¢)
	cmdList->DrawInstanced(4, 1, 0, 0);
}

SpriteCommon Sprite::SpriteCommonCreate(ID3D12Device* dev) 
{
	HRESULT result = S_FALSE;

	// æ–°ãŸãªã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
	SpriteCommon spriteCommon{};

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆç”¨ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	spriteCommon.pipelineSet = SpriteCreateGraphicsPipeline(dev);

	spriteCommon.matProjection = Matrix4::identity();

	// åº§æ¨™å¤‰æ›
	spriteCommon.matProjection.m[0][0] = 2.0f / WinApp::window_width;
	spriteCommon.matProjection.m[1][1] = -2.0f / WinApp::window_height;
	spriteCommon.matProjection.m[3][0] = -1.0f;
	spriteCommon.matProjection.m[3][1] = 1.0f;

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	descHeapDesc.NumDescriptors = SpriteCommon::kMaxSRVCount;
	result = dev->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&spriteCommon.descHeap));

	// ç”Ÿæˆã—ãŸã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’è¿”ã™
	return spriteCommon;
}

void Sprite::SpriteUpdate(Sprite& sprite, const SpriteCommon& spriteCommon) 
{
	// è¡Œåˆ—ã®è¨­å®š
	Matrix4 matRot;
	Matrix4 matTrans;
	Matrix4 matRotX, matRotY, matRotZ;

	//å„è¡Œåˆ—è¨ˆç®—
	matRot = Matrix4::identity();
	matRot *= matRotZ.rotateZ(rotation * 180.0f / 3.1415f);
	matRot *= matRotX.rotateX(rotation_.x * 180.0f / 3.1415f);
	matRot *= matRotY.rotateY(rotation_.y * 180.0f / 3.1415f);
	matTrans = Matrix4::identity();
	matTrans.translate(position);

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®æ›´æ–°
	Matrix4 mat;
	sprite.matWorld = mat.identity();
	// Zè»¸å›è»¢
	sprite.matWorld *= matRot;
	// å¹³è¡Œç§»å‹•
	sprite.matWorld *= matTrans;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®è»¢é€
	HRESULT result = sprite.constBuffB0->Map(0, nullptr, (void**)&constMap);
	constMap->mat = sprite.matWorld * spriteCommon.matProjection;
	sprite.constBuffB0->Unmap(0, nullptr);
}

void Sprite::LoadTexture(SpriteCommon& spriteCommon, UINT texnumber, const wchar_t* filename, ID3D12Device* dev) {

	assert(texnumber <= SpriteCommon::kMaxSRVCount - 1);

	HRESULT result;
	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// WICãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ­ãƒ¼ãƒ‰
	result = LoadFromWICFile(filename, WIC_FLAGS_NONE, &metadata, scratchImg);
	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ç”Ÿæˆ
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// èª­ã¿è¾¼ã‚“ã ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’SRGBã¨ã—ã¦æ‰±ã†
	metadata.format = MakeSRGB(metadata.format);

	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = dev->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨æŒ‡å®š
		nullptr, IID_PPV_ARGS(&spriteCommon.texBuff[texnumber]));
	assert(SUCCEEDED(result));

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // ç”Ÿãƒ‡ãƒ¼ã‚¿æŠ½å‡º
		result = spriteCommon.texBuff[texnumber]->WriteToSubresource(
			(UINT)i,
			nullptr, // å…¨é ˜åŸŸã¸ã‚³ãƒ”ãƒ¼
			img->pixels, // å…ƒãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ‰ãƒ¬ã‚¹
			(UINT)img->rowPitch, // 1ãƒ©ã‚¤ãƒ³ã‚µã‚¤ã‚º
			(UINT)img->slicePitch // 1æšã‚µã‚¤ã‚º
		);
		assert(SUCCEEDED(result));
	}

	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ä½œæˆ
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // è¨­å®šæ§‹é€ ä½“
	D3D12_RESOURCE_DESC resDesc = spriteCommon.texBuff[texnumber]->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;// 2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
	srvDesc.Texture2D.MipLevels = 1;

	dev->CreateShaderResourceView(spriteCommon.texBuff[texnumber].Get(), // ãƒ“ãƒ¥ãƒ¼ã¨é–¢é€£ä»˜ã‘ã‚‹ãƒãƒƒãƒ•ã‚¡
		&srvDesc, // ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®šæƒ…å ±
		CD3DX12_CPU_DESCRIPTOR_HANDLE(spriteCommon.descHeap->GetCPUDescriptorHandleForHeapStart(), 
		texnumber, 
		dev->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV))
	);
}

void Sprite::SpriteTransferVertexBuffer(const Sprite& sprite, uint32_t texIndex)
{
	HRESULT result = S_FALSE;

	this->texIndex_ = texIndex;

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	VertexPosUv vertices[] = {
		//    u    v
		{{},{0.0f,1.0f}}, // å·¦ä¸‹
		{{},{0.0f,0.0f}}, // å·¦ä¸Š
		{{},{1.0f,1.0f}}, // å³ä¸‹
		{{},{1.0f,0.0f}}, // å³ä¸Š
	};

	//  å·¦ä¸‹ã€å·¦ä¸Šã€å³ä¸‹ã€å³ä¸Š
	enum { LB, LT, RB, RT };

	// å·¦å³ä¸Šä¸‹ç«¯ã®åº§æ¨™è¨ˆç®—
	float left = (0.0f - anchorpoint.x) * scale.x;
	float right = (1.0f - anchorpoint.x) * scale.x;
	float top = (0.0f - anchorpoint.y) * scale.y;
	float bottom = (1.0f - anchorpoint.y) * scale.y;

	if (isFlipX_ = false) 
	{// å·¦å³å…¥ã‚Œæ›¿ãˆ
		left = -left;
		right = -right;
	}

	if (isFlipY_ = false)
	{// å·¦å³å…¥ã‚Œæ›¿ãˆ
		top = -top;
		bottom = -bottom;
	}

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿é…åˆ—ã«åº§æ¨™ã‚»ãƒƒãƒˆ
	vertices[LB].pos = { left,  bottom, 0.0f }; // å·¦ä¸‹
	vertices[LT].pos = { left,     top, 0.0f }; // å·¦ä¸Š
	vertices[RB].pos = { right, bottom, 0.0f }; // å³ä¸‹
	vertices[RT].pos = { right,    top, 0.0f }; // å³ä¸Š

	// UVè¨ˆç®—
	// æŒ‡å®šç•ªå·ã®ç”»åƒãŒèª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰
	if (spriteCommon_.texBuff[sprite.texIndex_]) {
		// ãƒ†ã‚¯ã‚¹ãƒãƒ£æƒ…å ±å–å¾—
		resDesc = spriteCommon_.texBuff[sprite.texIndex_]->GetDesc();

		float tex_left = sprite.texLeftTop_.x / resDesc.Width;
		float tex_right = (sprite.texLeftTop_.x + sprite.texSize_.x) / resDesc.Width;
		float tex_top = sprite.texLeftTop_.y / resDesc.Height;
		float tex_bottom = (sprite.texLeftTop_.y + sprite.texSize_.y) / resDesc.Height;

		vertices[LB].uv = { tex_left,  tex_bottom }; // å·¦ä¸‹
		vertices[LT].uv = { tex_left,     tex_top }; // å·¦ä¸Š
		vertices[RB].uv = { tex_right, tex_bottom }; // å³ä¸‹z
		vertices[RT].uv = { tex_right,    tex_top }; // å³ä¸Š
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPosUv* vertMap = nullptr;
	result = sprite.vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	sprite.vertBuff->Unmap(0, nullptr);
}

void Sprite::Finalize()
{
	//delete dXCommon;
}

void Sprite::SetAlpha(Sprite sprite,float alpha_) {

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®è»¢é€
	HRESULT result = sprite.constBuffB0->Map(0, nullptr, (void**)&constMap);
	constMap->color.w = alpha_;
	sprite.constBuffB0->Unmap(0, nullptr);
	assert(SUCCEEDED(result));
}

</file_content>

<file_content path="engine/2d/Sprite.h">
#pragma once

#include <Windows.h>
#include <D3dx12.h>
#include <DirectXMath.h>
#include <d3dcompiler.h>
#include <cassert>
#pragma warning(push)
#pragma	warning(disable:26813)
#include <DirectXTex.h>
#pragma warning(pop)
#include <wrl.h>
#include <array>
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include"Matrix4.h"

#include "DirectXCommon.h"

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;



// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚»ãƒƒãƒˆ
struct PipelineSet {
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3D12PipelineState> pipelinestate;
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	ComPtr<ID3D12RootSignature> rootsignature;
};

// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®å…±é€šãƒ‡ãƒ¼ã‚¿
struct SpriteCommon {
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚»ãƒƒãƒˆ
	PipelineSet pipelineSet;
	// å°„å½±è¡Œåˆ—
	Matrix4 matProjection{};
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	ComPtr<ID3D12DescriptorHeap> descHeap;
	// SRVã®æœ€å¤§æšæ•°
	static const size_t kMaxSRVCount = 512;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚½ãƒ¼ã‚¹(ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡)ã®é…åˆ—
	ComPtr<ID3D12Resource> texBuff[kMaxSRVCount];
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡å–å¾—
	ID3D12Resource* GetTexBuffer(uint32_t index) const { return texBuff[index].Get(); }
};

// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
class Sprite
{
public://ã‚µãƒ–ã‚¯ãƒ©ã‚¹
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“B0
	struct ConstBufferDataB0
	{
		Vector4 color;
		Matrix4 mat;	// ï¼“ï¼¤å¤‰æ›è¡Œåˆ—
	};

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	struct VertexPosUv {
		Vector3 pos;
		Vector2 uv;
	};
public:
	Sprite();
	~Sprite();

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	SpriteCommon SpriteCommonCreate(ID3D12Device* dev);

	/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”¨ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	PipelineSet SpriteCreateGraphicsPipeline(ID3D12Device* device);

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	void LoadTexture(SpriteCommon& spriteCommon, UINT texnumber, 
		const wchar_t* filename, ID3D12Device* dev);

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆç”Ÿæˆ
	void SpriteCreate(ID3D12Device* dev, int window_width, int window_height, 
		UINT texNumber, Vector2 anchorpoint, bool isFlipX, bool FlipY);

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå˜ä½“é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®è»¢é€
	void SpriteTransferVertexBuffer(const Sprite& sprite, uint32_t texIndex_ = UINT32_MAX);

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå˜ä½“æ›´æ–°
	void SpriteUpdate(Sprite& sprite, const SpriteCommon& spriteCommon);

	/// æç”»å‰å‡¦ç†
	static void PreDraw(ID3D12GraphicsCommandList* cmdList, const SpriteCommon& spriteCommon);

	/// æç”»å¾Œå‡¦ç†
	static void PostDraw();

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå˜ä½“æç”»
	void SpriteDraw(ID3D12GraphicsCommandList* cmdList_, const SpriteCommon& spriteCommon, 
		ID3D12Device* dev);

	/// çµ‚äº†å‡¦ç†
	void Finalize();

public: // ã‚»ãƒƒã‚¿ãƒ¼
	// åº§æ¨™è¨­å®š
	void SetPosition(Vector3 position) { this->position = position; }
	// ã‚µã‚¤ã‚ºè¨­å®š
	void SetScale(Vector2 scale) { this->scale = scale; }
	// å›è»¢
	void SetRotation(float rotation) { this->rotation = rotation; }
	// ç•ªå·
	void SetTexNumber(UINT texNumber) { this->texNumber = texNumber; }
	// è‰²
	void SetColor(const Vector4& color) { this->color_ = color; }
	void SetAlpha(Sprite sprite, float alpha_);
	// ãƒ•ãƒªãƒƒãƒ—
	void SetIsFlipX(bool isFlipX) { this->isFlipX_ = isFlipX; } // X
	void SetIsFlipY(bool isFlipY) { this->isFlipY_ = isFlipY; } // Y
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
	void SetTexLeftTop(const Vector2& texLeftTop) { this->texLeftTop_ = texLeftTop; }
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	void SetTexSize(const Vector2& texSize) { this->texSize_ = texSize; }

public: // ã‚²ãƒƒã‚¿ãƒ¼
	// åº§æ¨™
	Vector3 GetPosition() const { return position; }
	// ã‚µã‚¤ã‚º
	Vector2 GetScale() const { return scale; }
	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
	Matrix4 GetMat() { return constMap->mat; }
	// å›è»¢
	float GetRotation() const { return rotation; }
	// ç•ªå·
	UINT GetTexNumber() const { return texNumber; }
	// è‰²
	Vector4 GetColor() const { return color_; }
	// ãƒ•ãƒªãƒƒãƒ—
	bool GetIsFlipX() const { return isFlipX_; } // X
	bool GetIsFlipY() const { return isFlipY_; } // Y
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
	Vector2 GetTexLeftTop() const { return texLeftTop_; }
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	Vector2 GetTexSize() const { return texSize_; }

public:
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> vertBuff;
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	D3D12_RESOURCE_DESC resDesc;

private:
	// DirectXCommonã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	DirectXCommon* dXCommon = nullptr;
	SpriteCommon spriteCommon_;

	ComPtr<ID3D12GraphicsCommandList> cmdList;
	ComPtr<ID3D12DescriptorHeap> descHeap;
	//å®šæ•°ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> constBuffB0 = nullptr;
	// ãƒãƒƒãƒ”ãƒ³ã‚°æ¸ˆã¿ã‚¢ãƒ‰ãƒ¬ã‚¹
	ConstBufferDataB0* constMap = nullptr;
	D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
	static const size_t kMaxSRVCount = 2056;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡
	std::array<ComPtr<ID3D12Resource>, kMaxSRVCount> texBuffers_;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·
	UINT texNumber = 0;
	uint32_t texIndex_ = 0;
	// åº§æ¨™
	Vector3 position = { 0.0f, 0.0f, 0.0f };
	// ã‚µã‚¤ã‚º
	Vector2 scale = { 1.0f, 1.0f };
	// å›è»¢
	Vector3 rotation_ = { 0.0f,0.0f,0.0f };
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
	Matrix4 matWorld;
	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	Vector2 anchorpoint = { 0.0f,0.0f };
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™è¨­å®š
	Vector2 texLeftTop_ = { 50.0f, 50.0f };
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	Vector2 texSize_ = { 100.0f, 100.0f };
	// è‰²
	Vector4 color_ = { 1,1,1,1 };

	// Zè»¸å›ã‚Šã®å›è»¢
	float rotation = 0.0f;
	// å·¦å³åè»¢
	bool isFlipX_ = false;
	// ä¸Šä¸‹åè»¢
	bool isFlipY_ = false;
	// éè¡¨ç¤º
	bool isInvisible = false;
};


</file_content>

<file_content path="engine/3d/Boss.cpp">
#include "Boss.h"
#include "SphereCollider.h"
#include "time.h"
#include "stdlib.h"
#include "GameScene.h"

Boss::~Boss()
{
	delete bossModel;
}

void Boss::BossInitialize()
{
	Initialize();
	// OBJã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	bossModel = Model::LoadFromOBJ("fighter");
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Create();
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ã²ã‚‚ä»˜ã‘ã‚‹
	SetModel(bossModel);
	SetPosition({ -75,65,-200 });
	SetScale({ 10,10,10 });
	//ãƒ‘ãƒ¼ãƒ„ã®åˆæœŸåŒ–
	for (int i = 0; i < PARTS_NUM; i++) {
		parts[i] = Create();
		parts[i]->worldTransform_.SetParent3d(&worldTransform_);
		parts[i]->SetCollider(new SphereCollider());
	}
	parts[0]->SetPosition({ -2.0f,0.0f,-0.5f });
	parts[1]->SetPosition({ 2.0f,0.0f,-0.5f });
	parts[2]->SetPosition({ 0.0f,0.0f,1.0f });
	parts[3]->SetPosition({ -3.0f,0.0f,-1.0f });
	parts[4]->SetPosition({ 3.0f,0.0f,-1.0f });

	isDead_ = false;
	isInvisible = true;
	//ã‚¿ã‚¤ãƒãƒ¼
	appearTimer = 0;
	bossAlpha = 0.0f;
	hp = 300;
	isHit = false;
	hitTimer = 0;
	timer = 0;
	timeCount = 0;
	state = WAIT;
	//ä¹±æ•°
	srand((unsigned int)time(NULL));
}

void Boss::Update(Vector3 velo)
{
	//ç™»å ´æ™‚
	if (appearTimer > 0) {
		if (appearTimer > 150) {
			SetPosition(GetPosition() + Vector3(0.5f, -0.1f, 0));
		}
		if (appearTimer > 100) {
			bossAlpha += 0.02f;
		}
		appearTimer--;
	}
	//åŸºæœ¬æŒ™å‹•
	Move();
	ChangeState();

	//å¼¾ãŒã‚ã‚‹ãªã‚‰æ›´æ–°
	for (std::unique_ptr<BossBullet>& bullet : bullets_) {
		bullet->Update(velo);
	}
	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°ã®ç«‹ã£ãŸæ•µã‚’å‰Šé™¤
	bullets_.remove_if([](std::unique_ptr <BossBullet>& bullets_) {
		return bullets_->IsDead();
		});
	
	 //ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®š
	if (hitTimer > 0) {
		hitTimer--;
		if (hitTimer == 0) {
			isHit = false;
		}
	}
	//HPãŒ0ãªã‚‰æ­»äº¡
	if (hp <= 0) {
		isDead_ = true;
	}
	//æ›´æ–°
	worldTransform_.UpdateMatrix();
	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}
	//ãƒœã‚¹ãƒ‘ãƒ¼ãƒ„ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
	for (int i = 0; i < PARTS_NUM; i++) {
		parts[i]->Update();
	}
	//ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ
	if (timeCount == 4) {
		timeCount = 0;
	}
}

void Boss::Pop()
{
	if (isInvisible == true) {
		isInvisible = false;
	}
	appearTimer = 300;
}

void Boss::Attack()
{
	//å¼¾ã‚’ç”Ÿæˆã—åˆæœŸåŒ–
	std::unique_ptr<BossBullet> newBullet = std::make_unique<BossBullet>();

	//å˜ç™º													   
	newBullet->BulletInitialize(GetPosition());
	newBullet->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 5.0f));

	//å¼¾ã®ç™»éŒ²										 
   //è¤‡æ•°
	newBullet->SetPosition(GetPosition());
	newBullet->SetScale({ 1.2f,1.2f,1.2f });
	bullets_.push_back(std::move(newBullet));
}

void Boss::Move()
{
	//ãƒœã‚¹ç™»å ´å¾Œ
	if (isInvisible == false) {
		if (timer < 75) {
			SetPosition(GetPosition() + Vector3(0.0f, 0.01f, 0.0f));
		}
		else if (timer < 150) {
			SetPosition(GetPosition() + Vector3(0.0f, -0.01f, 0.0f));
		}
		else {
			timer = 0;
			timeCount++;
		}
		timer++;
	}
}

void Boss::ChangeState()
{
	//å¾…æ©ŸçŠ¶æ…‹
	if (state == WAIT) {
		if (timeCount == 4) {
			//ä¹±æ•°ã«ã‚ˆã‚Šè¡Œå‹•ã‚’æ±ºå®š
			int random = rand() % 1 + 1;
			//æŠ½é¸ã•ã‚ŒãŸè¡Œå‹•
			state = (State)random;
		}						 
	}
	//å°„æ’ƒçŠ¶æ…‹
	else if (state == SHOT) {
		Attack();
		state = WAIT;
	}
}

void Boss::BossDraw(ViewProjection* viewProjection_)
{
	Draw(viewProjection_, bossAlpha);
	//å¼¾æç”»
	for (std::unique_ptr<BossBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}

void Boss::OnCollision(const CollisionInfo& info)
{
	//è¡çªç›¸æ‰‹ã®åå‰
	const char* str1 = "class PlayerBullet";

	//ç›¸æ‰‹ãŒplayerã®å¼¾
	if (strcmp(toCollisionName, str1) == 0) {
		if (isHit == false && isInvisible == false) {
			isHit = true;
			hitTimer = 30;
			hp-= 5;
			for (int i = 0; i < PARTS_NUM; i++) {
				if (parts[i]->GetIsLocked() == true) {
					parts[i]->SetIsLocked(false);
					GameScene::PopEnergy(parts[i]->GetWorldPos());
					hp -= 5;
				}
			}
		}
	}
}

void Boss::SkipMovie()
{
	appearTimer = 0;
	SetPosition({ 0.0f,49.99f,-200.0f });
	bossAlpha = 1.0f;
}

</file_content>

<file_content path="engine/3d/Boss.h">
#pragma once
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include "BossBullet.h"

//GameSceneã®å‰æ–¹å®£è¨€
class GameScene;

class Boss : public Object3d
{
public:
	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Boss();
	//åˆæœŸåŒ–
	void BossInitialize();

	void Update(Vector3 velo);
	void Pop();
	void Attack();
	void Move();
	void ChangeState();
	
	void BossDraw(ViewProjection* viewProjection_);

	bool GetIsDead() const { return isDead_; }
	//å½“ãŸã‚Šåˆ¤å®š
	void OnCollision(const CollisionInfo& info) override;
	//Getter
	bool GetIsInvisible() { return isInvisible; }
	float GetAlpha() { return bossAlpha; }
	int GetTimer() { return appearTimer; }
	float GetHP() { return hp; }
	int GetPartsNum() { return PARTS_NUM; }
	Object3d* GetParts(int i) { return parts[i]; }
	//æ¼”å‡ºã‚¹ã‚­ãƒƒãƒ—
	void SkipMovie();

	

private:

	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;
	bool isInvisible = true;
	//ã‚¿ã‚¤ãƒãƒ¼
	int appearTimer = 0;
	float bossAlpha = 0.0f;
	float hp;
	bool isHit;
	int hitTimer;
	int timeCount;
	int timer;
	
	//ãƒœã‚¹è¡Œå‹•æƒ…å ±
	enum State {
		WAIT,
		SHOT
	};
	State state;

	// ãƒ¢ãƒ‡ãƒ«
	Model* bossModel = nullptr;
	//å¼¾
	std::list<std::unique_ptr<BossBullet>> bullets_;
	static const int PARTS_NUM = 5;
	Object3d* parts[PARTS_NUM];
};

</file_content>

<file_content path="engine/3d/BossBullet.cpp">
#include "BossBullet.h"
#include "BaseCollider.h"

void BossBullet::BulletInitialize(const Vector3& position)
{
	Initialize();

	// OBJã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	bulletModel->LoadTexture("Resources/blue.png");
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Create();
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ã²ã‚‚ä»˜ã‘ã‚‹
	SetModel(bulletModel);

	//ä½“åŠ›æŒ‡å®š
	hp = 2;
	hitTime = 0;
	isHit = false;
}

void BossBullet::Update(const Vector3& playerPos_)
{
	//ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
	velocity = playerPos_ - GetPosition();
	velocity.normalize();
	//åº§æ¨™ã‚’åŠ ç®—
	SetPosition(GetPosition() + velocity);
	//æ›´æ–°
	worldTransform_.UpdateMatrix();

	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}
	//ãƒ’ãƒƒãƒˆæ™‚ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
	if (hitTime > 0) {
		hitTime--;
		if (isHit == false) {
			isHit = true;
			bulletModel->LoadTexture("Resources/red.png");
		}
	}
	else {
		if (isHit == true) {
			isHit = false;
			bulletModel->LoadTexture("Resources/blue.png");
		}
	}
	//æ™‚é–“çµŒéã§ãƒ‡ã‚¹
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}
}

void BossBullet::OnCollision(const CollisionInfo& info)
{
	//è¡çªç›¸æ‰‹ã®åå‰
	const char* str1 = "class Player";
	const char* str2 = "class PlayerBullet";

	//ç›¸æ‰‹ãŒplayer
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
	//ç›¸æ‰‹ãŒplayerã®å¼¾
	if (strcmp(toCollisionName, str2) == 0) {
		if (hitTime == 0) {
			if (hp == 2) {
				hp--;
			}
			else {
				isDead_ = true;
				hitTime = 10;
			}
		}
	}
}

</file_content>

<file_content path="engine/3d/BossBullet.h">
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class BossBullet : public Object3d
{
public:
	///< summary>
	///åˆæœŸåŒ–
	///</summary>
	void BulletInitialize(const Vector3& position);

	///< summary>
	///åˆæœŸåŒ–
	///</summary>
	void Update(const Vector3& playerPos_);


	//è¡çªã‚’æ¤œå‡ºã—ãŸã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void OnCollision(const CollisionInfo& info) override;


public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }

private:
	//ãƒ¢ãƒ‡ãƒ«
	Model* bulletModel = nullptr;

	//é€Ÿåº¦
	Vector3 playerPos;
	Vector3 velocity;

	//å¯¿å‘½
	static const int32_t kLifeTime = 60 * 3;
	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒãƒ¼
	int32_t deathTimer_ = kLifeTime;
	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	int hp;
	int hitTime;
	bool isHit;
	bool isDead_ = false;

};

</file_content>

<file_content path="engine/3d/Enemy.cpp">
#include "Enemy.h"
#include "string.h"
#include "BaseCollider.h"
#include "SphereCollider.h"
#include "GameScene.h"

//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
Enemy::~Enemy() {
	delete enemyModel;
}

//åˆæœŸåŒ–
void Enemy::EnemyInitialize()
{
	Initialize();
	// OBJã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	enemyModel = Model::LoadFromOBJ("triangle_mat");
	enemyModel->LoadTexture("Resources/red.png");
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Create();
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ã²ã‚‚ä»˜ã‘ã‚‹
	SetModel(enemyModel);
	isDead_ = false;
	isInvisible = true;
	timer = 0;
	isAttack = false;
	timeCount = 0;
	alpha = 0;
}

void Enemy::Update(Vector3 velo,float t) {
	//é€æ˜çŠ¶æ…‹ãªã‚‰
	if (isInvisible == true) {
		float len = stagePoint - t + 1.0f;
 		if (len < 4.0f) {
			isInvisible = false;
		}
	}
	else {
		if (alpha < 1) {
			alpha += 0.05f;
		}
		float moveX;
		if (timeCount == 0) {
			moveX = -0.05f;
		}
		else if (timeCount == 1) {
			moveX = 0.05f;
		}
		else if (timeCount == 2) {
			moveX = 0.05f;
		}
		else {
			moveX = -0.05f;
		}

		if (timer < 75) {
			SetPosition(GetPosition() + Vector3(moveX, 0.005f, 0));
		}
		else if (timer < 150) {
			SetPosition(GetPosition() + Vector3(moveX, -0.005f, 0));
		}
		else {
			timer = 0;
			if (timeCount == 4) {
				timeCount = 0;
			}
			else {
				timeCount++;
			}
		}
		//playerãŒæ•µã‚’è¿½ã„è¶Šã—ãŸã‚‰æ”»æ’ƒã—ãªã„
		if (stagePoint < t + 1.0f) {
			if (isAttack == true) {
				isAttack = false;
			}
		}
		//æ”»æ’ƒ
		if (isAttack == false) {
			Vector3 playerVec = velo - GetPosition();
			float len = playerVec.length();
			if (len < 70.0f) {
				isAttack = true;
			}
		}
		else {
			Attack();
		}

		for (std::unique_ptr<EnemyBullet>& bullet : bullets_) {
			bullet->Update(velo);
		}
		//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°ã®ç«‹ã£ãŸæ•µã‚’å‰Šé™¤
		bullets_.remove_if([](std::unique_ptr <EnemyBullet>& bullets_) {
			return bullets_->IsDead();
			});
		//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
		if (collider)
		{
			collider->Update();
		}
		worldTransform_.UpdateMatrix();
		timer++;
	}
}

void Enemy::OnCollision(const CollisionInfo& info)
{
	//è¡çªç›¸æ‰‹ã®åå‰
	const char* str1 = "class PlayerBullet";

	//ç›¸æ‰‹ãŒplayerã®å¼¾
	if (strcmp(toCollisionName, str1) == 0) {
		if (isInvisible == false) {
			if (isDead_ == false) {
				isDead_ = true;
				for (int i = 0; i < 3; i++) {
					GameScene::PopEnergy(GetPosition());
				}
			}
		}
	}
}

void Enemy::Attack() {

		if (coolTime == 0) {
			//å¼¾ã‚’ç”Ÿæˆã—åˆæœŸåŒ–
		//è¤‡æ•°
			std::unique_ptr<EnemyBullet> newBullet = std::make_unique<EnemyBullet>();

			//å˜ç™º													   
			newBullet->BulletInitialize(GetPosition());
			newBullet->SetCollider(new SphereCollider(Vector3{0,0,0},0.5f));

			//å¼¾ã®ç™»éŒ²										 
		   //è¤‡æ•°
			newBullet->SetPosition(GetPosition());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			bullets_.push_back(std::move(newBullet));


			//ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã‚’è¨­å®š
			coolTime = 200;
		}
		else if (coolTime > 0) {
			coolTime--;
		}

}

void Enemy::EnemyDraw(ViewProjection* viewProjection_) {
	Draw(viewProjection_, alpha);
	//å¼¾æç”»
	for (std::unique_ptr<EnemyBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}
</file_content>

<file_content path="engine/3d/Enemy.h">
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include <list>
#include "EnemyBullet.h"

//GameSceneã®å‰æ–¹å®£è¨€
class GameScene;

class Enemy : public Object3d
{
public:
	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Enemy();
	//åˆæœŸåŒ–
	void EnemyInitialize();


	bool GetIsDead() const { return isDead_; }
	
	void Update(Vector3 velo,float t);
	void EnemyDraw(ViewProjection* viewProjection_);

	void Attack();

	void OnCollision(const CollisionInfo& info) override;
	void SetStagePoint(float pos_) { stagePoint = pos_; }
	float GetStagePoint(){return stagePoint;}
	Object3d* GetPointer() { return this; }
	bool GetIsInvisible() { return isInvisible; }

	//å¼¾ãƒªã‚¹ãƒˆã‚’å–å¾—
	const std::list<std::unique_ptr<EnemyBullet>>& GetBullets() { return bullets_; }

private:

	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;
	//
	bool isInvisible = true;

	//æ•µ
	std::list<std::unique_ptr<EnemyBullet>> bullets_;

	// ãƒ¢ãƒ‡ãƒ«
	Model* enemyModel = nullptr;
	float alpha;

	//åŠå¾„
	int timer;
	float radius = 1.0f;
	int coolTime = 0;
	float stagePoint;

	bool isAttack;
	int timeCount;
};

</file_content>

<file_content path="engine/3d/EnemyBullet.cpp">
#include "EnemyBullet.h"
#include "BaseCollider.h"

void EnemyBullet::BulletInitialize(const Vector3& position) {

	Initialize();

	// OBJã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Create();
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ã²ã‚‚ä»˜ã‘ã‚‹
	SetModel(bulletModel);

	//å¼•æ•°ã§å—ã‘å–ã£ãŸé€Ÿåº¦ã‚’ãƒ¡ãƒ³ãƒå¤‰æ•°ã«ä»£å…¥
	bulletTime = 0;
}

void EnemyBullet::Update(const Vector3& playerPos_) {

	if (bulletTime < 40) {
		velocity = (playerPos_ - GetPosition()) * 0.05f;
		bulletTime++;
	}

	SetPosition(GetPosition() + velocity);

	worldTransform_.UpdateMatrix();

	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}
	//æ™‚é–“çµŒéã§ãƒ‡ã‚¹
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}
}

void EnemyBullet::OnCollision(const CollisionInfo& info)
{
	//è¡çªç›¸æ‰‹ã®åå‰
	const char* str1 = "class Player";
	const char* str2 = "class PlayerBullet";

	//ç›¸æ‰‹ãŒplayer
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
	//ç›¸æ‰‹ãŒplayerã®å¼¾
	if (strcmp(toCollisionName, str2) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}
}

</file_content>

<file_content path="engine/3d/EnemyBullet.h">
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class EnemyBullet : public Object3d
{
public:
	///< summary>
	///åˆæœŸåŒ–
	///</summary>
	void BulletInitialize(const Vector3& position);

	///< summary>
	///åˆæœŸåŒ–
	///</summary>
	void Update(const Vector3& playerPos_);


	//è¡çªã‚’æ¤œå‡ºã—ãŸã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void OnCollision(const CollisionInfo& info) override;


public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }

private:
	//ãƒ¢ãƒ‡ãƒ«
	Model* bulletModel = nullptr;

	//é€Ÿåº¦
	Vector3 playerPos;
	Vector3 velocity;

	//å¯¿å‘½
	static const int32_t kLifeTime = 60 * 3;
	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒãƒ¼
	int32_t deathTimer_ = kLifeTime;
	int bulletTime;
	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;

};

</file_content>

<file_content path="engine/3d/Energy.cpp">
#include "Energy.h"
#include "string.h"
#include "BaseCollider.h"
#include "SphereCollider.h"

void Energy::EnergyInitialize()
{
	Initialize();
	// OBJã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	energyModel = Model::LoadFromOBJ("panel");
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Create();
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ã²ã‚‚ä»˜ã‘ã‚‹
	SetModel(energyModel);
	SetScale(Vector3(0.5f, 0.5f, 0.5f));
	isDead = false;
}

void Energy::Update(Vector3 pos,Vector3 rot)
{
	//playerã®ã‚‚ã¨ã¸
	Vector3 velo = pos - GetPosition();
	velo = velo.normalize();
	SetPosition(GetPosition() + velo);
	SetRotation(rot + Vector3(0,90,0));

	worldTransform_.UpdateMatrix();

	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}
}

void Energy::OnCollision(const CollisionInfo& info)
{
	//è¡çªç›¸æ‰‹ã®åå‰
	const char* str1 = "class Player";

	//ç›¸æ‰‹ãŒplayerã®å¼¾
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead == false) {
			isDead = true;
		}
	}
}

</file_content>

<file_content path="engine/3d/Energy.h">
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "Model.h"
#include <list>

//GameSceneã®å‰æ–¹å®£è¨€
class GameScene;

class Energy : public Object3d
{
public:

	void EnergyInitialize();
	
	void Update(Vector3 pos, Vector3 rot);

	void OnCollision(const CollisionInfo& info) override;

	bool GetIsDead() const { return isDead; }

private:
	// ãƒ¢ãƒ‡ãƒ«
	Model* energyModel = nullptr;
	
	bool isDead;
};

</file_content>

<file_content path="engine/3d/FbxLoader.cpp">
#include "FbxLoader.h"
#include <cassert>
#include "Vector3.h"
#include "DirectXMath.h"

//é™çš„å¤‰æ•°ã®å®Ÿä½“
const std::string FbxLoader::baseDirectory =
"Resources/";
const std::string FbxLoader::defaultTextureFileName =
"white1x1.png";

//ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
FbxLoader* FbxLoader::GetInstance() {
	static FbxLoader instance;
	return &instance;
}

//åˆæœŸåŒ–
void FbxLoader::Initialize(ID3D12Device* device) {

	//å†åˆæœŸåŒ–ãƒã‚§ãƒƒã‚¯
	assert(fbxManager == nullptr);
	//å¼•æ•°ã‹ã‚‰ãƒ¡ãƒ³ãƒå¤‰æ•°ã«ä»£å…¥
	this->device = device;
	//FBXãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ç”Ÿæˆ
	fbxManager = FbxManager::Create();
	//FBXãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®å…¥å‡ºåŠ›è¨­å®š
	FbxIOSettings* ios = FbxIOSettings::Create(fbxManager, IOSROOT);
	fbxManager->SetIOSettings(ios);
	//FBXã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®ç”Ÿæˆ
	fbxImporter = FbxImporter::Create(fbxManager, "");
}

//ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
FbxModel* FbxLoader::LoadModelFlomFile(const string& modelName) {
	const string directoryPath = baseDirectory + modelName + "/";
	const string fileName = modelName + ".fbx";
	//é€£çµ
	const string fullPath = directoryPath + fileName;

	//ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®šã—ã¦èª­ã¿è¾¼ã¿
	if (!fbxImporter->Initialize(fullPath.c_str(), -1, fbxManager->GetIOSettings())) {
		assert(0);
	}
	FbxScene* fbxScene = FbxScene::Create(fbxManager, "fbxScene");

	//ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’ã‚·ãƒ¼ãƒ³ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
	fbxImporter->Import(fbxScene);

	//ãƒ¢ãƒ‡ãƒ«ç”Ÿæˆ
	FbxModel* model = new FbxModel();
	model->name = modelName;
	//ãƒãƒ¼ãƒ‰æ•°ã‚’å–å¾—
	int nodeCount = fbxScene->GetNodeCount();

	model->nodes.reserve(nodeCount);

	ParseNodeRecursive(model, fbxScene->GetRootNode());
	model->fbxScene = fbxScene;

	//ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	model->CreateBuffers(device);
	assert(model->indices.size());

	return model;
}

//ãƒãƒ¼ãƒ‰è§£æ
void FbxLoader::ParseNodeRecursive(FbxModel* model, FbxNode* fbxNode, Node* parent) {

	model->nodes.emplace_back();
	Node& node = model->nodes.back();
	//ãƒãƒ¼ãƒ‰åã‚’å–å¾—
	node.name = fbxNode->GetName();

	//fbxãƒãƒ¼ãƒ‰ã®ãƒ­ãƒ¼ã‚«ãƒ«ç§»å‹•æƒ…å ±
	FbxDouble3 rotation = fbxNode->LclRotation.Get();
	FbxDouble3 scaling = fbxNode->LclScaling.Get();
	FbxDouble3 translation = fbxNode->LclTranslation.Get();

	//å½¢å¼å¤‰æ›ã—ã¦ä»£å…¥
	node.rotation = { (float)rotation[0],(float)rotation[1],(float)rotation[2],0.0f };
	node.scaling = { (float)scaling[0],(float)scaling[1],(float)scaling[2],0.0f };
	node.translation = { (float)translation[0],(float)translation[1],(float)translation[2],1.0f };

	//å›è»¢è§’ã‚’Degreeã‹ã‚‰ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›
	node.rotation.x = Matrix4::ConvertToRadian(node.rotation.x);
	node.rotation.y = Matrix4::ConvertToRadian(node.rotation.y);
	node.rotation.z = Matrix4::ConvertToRadian(node.rotation.z);

	//è§’è¡Œåˆ—ã®è¨ˆç®—
	Matrix4 matScaling, matRotation, matTranslation;
	Matrix4 matRotX, matRotY, matRotZ;
	Vector3 scl = { node.scaling.x,node.scaling.y ,node.scaling.z };
	matScaling = Matrix4::identity();
	matScaling.scale(scl);
	matRotation = Matrix4::identity();
	matRotation *= matRotZ.rotateZ(Matrix4::ConvertToRadian(node.rotation.z));
	matRotation *= matRotX.rotateX(Matrix4::ConvertToRadian(node.rotation.x));
	matRotation *= matRotY.rotateY(Matrix4::ConvertToRadian(node.rotation.y));
	Vector3 trl = { node.translation.x,node.translation.y,node.translation.z };
	matTranslation = Matrix4::identity();
	matTranslation.translate(trl);

	//ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ›è¡Œåˆ—ã®è¨ˆç®—
	node.tranform = Matrix4::identity();
	node.tranform *= matScaling;
	node.tranform *= matRotation;
	node.tranform *= matTranslation;

	//ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰å½¢è¡Œåˆ—ã®è¨ˆç®—
	node.globalTransform = node.tranform;
	if (parent) {
		node.parent = parent;
		//è¦ªã®å¤‰å½¢ã‚’ä¹—ç®—
		node.globalTransform *= parent->globalTransform;
	}

	//ãƒ¡ãƒƒã‚·ãƒ¥è§£æ
	FbxNodeAttribute* fbxNodeAttribute = fbxNode->GetNodeAttribute();

	if (fbxNodeAttribute) {
		if (fbxNodeAttribute->GetAttributeType() == FbxNodeAttribute::eMesh) {
			model->meshNode = &node;
			ParseMesh(model, fbxNode);
		}
	}

	//å­ãƒãƒ¼ãƒ‰ã«å¯¾ã—ã¦å†èµ·å‘¼ã³å‡ºã—
	for (int i = 0; i < fbxNode->GetChildCount(); i++) {
		ParseNodeRecursive(model, fbxNode->GetChild(i), &node);
	}


}

void FbxLoader::ParseMesh(FbxModel* model, FbxNode* fbxNode) {
	FbxMesh* fbxMesh = fbxNode->GetMesh();

	//é ‚ç‚¹åº§æ¨™èª­ã¿å–ã‚Š
	ParseMeshVertices(model, fbxMesh);
	//é¢
	ParseMeshFaces(model, fbxMesh);
	//ãƒãƒ†ãƒªã‚¢ãƒ«
	ParseMatrial(model, fbxNode);
	//ã‚¹ã‚­ãƒ‹ãƒ³ã‚°æƒ…å ±èª­ã¿å–ã‚Š
	ParseSkin(model, fbxMesh);

}
//é ‚ç‚¹æƒ…å ±èª­ã¿å–ã‚Š
void FbxLoader::ParseMeshVertices(FbxModel* model, FbxMesh* fbxMesh) {
	auto& vertices = model->vertices;

	//é ‚ç‚¹åº§æ¨™ã®ãƒ‡ãƒ¼ã‚¿ã®æ•°
	const int controlPointsCount = fbxMesh->GetControlPointsCount();

	//å¿…è¦æ•°ã ã‘é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç¢ºä¿
	FbxModel::VertexPosNormalUvSkin vert{};
	model->vertices.resize(controlPointsCount, vert);

	//fbxãƒ¡ãƒƒã‚·ãƒ¥ã®é ‚ç‚¹åº§æ¨™é…åˆ—ã‚’å–å¾—
	FbxVector4* pCoord = fbxMesh->GetControlPoints();

	//fbxãƒ¡ãƒƒã‚·ãƒ¥ã®å…¨é ‚ç‚¹åº§æ¨™ã‚’ãƒ¢ãƒ‡ãƒ«å†…ã®é…åˆ—ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹
	for (int i = 0; i < controlPointsCount; i++) {
		FbxModel::VertexPosNormalUvSkin& vertex = vertices[i];
		//åº§æ¨™ã®ã‚³ãƒ”ãƒ¼
		vertex.pos.x = (float)pCoord[i][0];
		vertex.pos.y = (float)pCoord[i][1];
		vertex.pos.z = (float)pCoord[i][2];
	}
}
//é¢æƒ…å ±èª­ã¿å–ã‚Š
void FbxLoader::ParseMeshFaces(FbxModel* model, FbxMesh* fbxMesh) {
	auto& vertices = model->vertices;
	auto& indices = model->indices;

	//1ãƒ•ã‚¡ã‚¤ãƒ«ã«è¤‡æ•°ãƒ¡ãƒƒã‚·ãƒ¥ã®ãƒ¢ãƒ‡ãƒ«ã¯éå¯¾å¿œ
	assert(indices.size() == 0);

	//é¢ã®æ•°
	const int polygonCount = fbxMesh->GetPolygonCount();
	//uvãƒ‡ãƒ¼ã‚¿ã®æ•°
	const int textureUVCount = fbxMesh->GetTextureUVCount();
	//uvåãƒªã‚¹ãƒˆ
	FbxStringList uvNames;
	fbxMesh->GetUVSetNames(uvNames);

	//é¢ã”ã¨ã®æƒ…å ±èª­ã¿å–ã‚Š
	for (int i = 0; i < polygonCount; i++) {
		const int polygonSize = fbxMesh->GetPolygonSize(i);
		assert(polygonSize <= 4);

		for (int j = 0; j < polygonSize; j++) {
			int index = fbxMesh->GetPolygonVertex(i, j);
			assert(index >= 0);
			//é ‚ç‚¹æ³•ç·šèª­ã¿è¾¼ã¿
			FbxModel::VertexPosNormalUvSkin& vertex = vertices[index];
			FbxVector4 normal;
			if (fbxMesh->GetPolygonVertexNormal(i, j, normal)) {
				vertex.normal.x = (float)normal[0];
				vertex.normal.y = (float)normal[1];
				vertex.normal.z = (float)normal[2];
			}
			//ãƒ†ã‚¯ã‚¹ãƒãƒ£uvèª­ã¿è¾¼ã¿
			if (textureUVCount > 0) {
				FbxVector2 uvs;
				bool lUnmappedUV;
				//0ç•ªæ±ºã‚æ‰“ã¡ã§èª­ã¿è¾¼ã¿
				if (fbxMesh->GetPolygonVertexUV(i, j, uvNames[0], uvs, lUnmappedUV)) {
					vertex.uv.x = (float)uvs[0];
					vertex.uv.y = (float)uvs[1];
				}
			}

			//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ã«é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ 
			if (j < 3) {
				indices.push_back(index);
			}
			//4é ‚ç‚¹
			else {
				int index2 = indices[indices.size() - 1];
				int index3 = index;
				int index0 = indices[indices.size() - 3];
				indices.push_back(index2);
				indices.push_back(index3);
				indices.push_back(index0);
			}
		}
	}

}
//ãƒãƒ†ãƒªã‚¢ãƒ«èª­ã¿è¾¼ã¿
void FbxLoader::ParseMatrial(FbxModel* model, FbxNode* fbxNode) {
	const int materialCount = fbxNode->GetMaterialCount();
	if (materialCount > 0) {
		FbxSurfaceMaterial* material = fbxNode->GetMaterial(0);
		bool textureLoaded = false;

		if (material) {
			if (material->GetClassId().Is(FbxSurfaceLambert::ClassId)) {
				FbxSurfaceLambert* lambert =
					static_cast<FbxSurfaceLambert*>(material);

				//ç’°å¢ƒå…‰ä¿‚æ•°
				FbxPropertyT<FbxDouble3> ambient = lambert->Ambient;
				model->ambient.x = (float)ambient.Get()[0];
				model->ambient.y = (float)ambient.Get()[1];
				model->ambient.z = (float)ambient.Get()[2];

				//æ‹¡æ•£åå°„å…‰ä¿‚æ•°
				FbxPropertyT<FbxDouble3> diffuse = lambert->Diffuse;
				model->diffuse.x = (float)diffuse.Get()[0];
				model->diffuse.y = (float)diffuse.Get()[1];
				model->diffuse.z = (float)diffuse.Get()[2];
			}
			//ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å–ã‚Šå‡ºã™
			const FbxProperty diffuseProperty =
				material->FindProperty(FbxSurfaceMaterial::sDiffuse);
			if (diffuseProperty.IsValid()) {
				const FbxFileTexture* texture = diffuseProperty.GetSrcObject<FbxFileTexture>();
				if (texture) {
					const char* filepath = texture->GetFileName();
					//ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åæŠ½å‡º
					string path_str(filepath);
					string name = ExtracFileName(path_str);
					//ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
					LoadTexture(model, baseDirectory + model->name + "/" + name);
					textureLoaded = true;
				}
			}
		}
		//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒãªã„å ´åˆç™½ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è²¼ã‚‹
		if (!textureLoaded) {
			LoadTexture(model, baseDirectory + defaultTextureFileName);
		}
	}
}

//ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
void FbxLoader::LoadTexture(FbxModel* model, const std::string& fullPath) {
	HRESULT result = S_FALSE;
	//WICãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ­ãƒ¼ãƒ‰
	DirectX::TexMetadata& metadata = model->metaData;
	DirectX::ScratchImage& scratchImage = model->scratchImg;
	//ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã«å¤‰æ›
	wchar_t wfilepath[128];
	MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, wfilepath, _countof(wfilepath));
	result = DirectX::LoadFromWICFile(wfilepath, DirectX::WIC_FLAGS_NONE, &metadata, scratchImage);

	if (FAILED(result)) {
		assert(0);
	}
}

//ãƒ•ã‚¡ã‚¤ãƒ«åæŠ½å‡º
std::string FbxLoader::ExtracFileName(const std::string& path) {
	size_t pos1;
	//åŒºåˆ‡ã‚Šæ–‡å­—""ãŒå‡ºã¦ãã‚‹ä¸€ç•ªæœ€å¾Œã®éƒ¨åˆ†ã‚’æ¤œç´¢
	pos1 = path.rfind("\\");
	if (pos1 != string::npos) {
		return path.substr(pos1 + 1, path.size() - pos1 - 1);
	}
	//åŒºåˆ‡ã‚Šæ–‡å­—'/'
	pos1 = path.rfind('/');
	if (pos1 != string::npos) {
		return path.substr(pos1 + 1, path.size() - pos1 - 1);
	}

	return path;
}

//å¾Œå§‹æœ«
void FbxLoader::Finalize() {
	//å„ç¨®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ç ´æ£„
	fbxImporter->Destroy();
	fbxManager->Destroy();
}

void FbxLoader::ConvertMatrixFromFbx(Matrix4 dst, const FbxAMatrix& src) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			dst.m[i][j] = (float)src.Get(i, j);
		}
	}
}

void FbxLoader::ParseSkin(FbxModel* model, FbxMesh* fbxMesh) {
	FbxSkin* fbxSkin =
	static_cast<FbxSkin*>(fbxMesh->GetDeformer(0, FbxDeformer::eSkin));
	//ã‚¹ã‚­ãƒ‹ãƒ³ã‚°æƒ…å ±ãŒãªã‘ã‚Œã°çµ‚äº†
	if (fbxSkin == nullptr) {
		return;
	}
	//ãƒœãƒ¼ãƒ³é…åˆ—ã®å‚ç…§
	std::vector<FbxModel::Bone>& bones = model->bones;
	//ãƒœãƒ¼ãƒ³ã®æ•°
	int clusterCount = fbxSkin->GetClusterCount();
	bones.reserve(clusterCount);

	//å…¨ã¦ã®ãƒœãƒ¼ãƒ³ã«ã¤ã„ã¦
	for (int i = 0; i < clusterCount; i++) {
		//FBXãƒœãƒ¼ãƒ³æƒ…å ±
		FbxCluster* fbxCluster = fbxSkin->GetCluster(i);
		//ãƒœãƒ¼ãƒ³è‡ªä½“ã®ãƒãƒ¼ãƒ‰ã®åå‰ã‚’å–å¾—
		const char* boneName = fbxCluster->GetLink()->GetName();
		//æ–°ã—ããƒœãƒ¼ãƒ³ã‚’è¿½åŠ ã—è¿½åŠ ã—ãŸãƒœãƒ¼ãƒ³ã®å‚ç…§ã‚’å¾—ã‚‹
		bones.emplace_back(FbxModel::Bone(boneName));
		FbxModel::Bone& bone = bones.back();
		//è‡ªä½œãƒœãƒ¼ãƒ³ã¨Fbxã®ãƒœãƒ¼ãƒ³ã‚’ç´ã¥ã‘ã‚‹
		bone.fbxCluster = fbxCluster;
		//FBXã‹ã‚‰åˆæœŸå§¿å‹¢è¡Œåˆ—ã‚’å–å¾—ã™ã‚‹
		FbxAMatrix fbxMat;
		fbxCluster->GetTransformLinkMatrix(fbxMat);
		//Matrix4å‹ã«å¤‰æ›ã™ã‚‹
		Matrix4 initialPose;
		ConvertMatrixFromFbx(initialPose, fbxMat);
		//åˆæœŸå§¿å‹¢è¡Œåˆ—ã®é€†è¡Œåˆ—ã‚’å¾—ã‚‹
		bone.inInitialPose.MakeInverse();
	}
	//ãƒœãƒ¼ãƒ³ç•ªå·ã¨ã‚¹ã‚­ãƒ³ã‚¦ã‚§ã‚¤ãƒˆã®ãƒšã‚¢
	struct WeightSet {
		UINT index;
		float weight;
	};

	//äºŒæ¬¡å…ƒé…åˆ—(ã‚¸ãƒ£ã‚°é…åˆ—)
	//list:é ‚ç‚¹ãŒå½±éŸ¿ã‚’å—ã‘ã‚‹ãƒœãƒ¼ãƒ³ã®å…¨ãƒªã‚¹ãƒˆ
	//vector:ãã‚Œã‚’å…¨é ‚ç‚¹åˆ†
	std::vector<std::list<WeightSet>>
	weightLists(model->vertices.size());
	//å…¨ã¦ã®ãƒœãƒ¼ãƒ³ã«ã¤ã„ã¦
	for (int i = 0; i < clusterCount; i++) {
		FbxCluster* fbxCluster = fbxSkin->GetCluster(i);
		//ã“ã®ãƒœãƒ¼ãƒ³ã«å½±éŸ¿ã‚’å—ã‘ã‚‹é ‚ç‚¹
		int controlPointIndicesCount = fbxCluster->GetControlPointIndicesCount();
		//ã“ã®ãƒœãƒ¼ãƒ³ã«å½±éŸ¿ã‚’å—ã‘ã‚‹é ‚ç‚¹ã®é…åˆ—
		int* controlPointIndices = fbxCluster->GetControlPointIndices();
		double* controlPointWeights = fbxCluster->GetControlPointWeights();
		//å½±éŸ¿ã‚’å—ã‘ã‚‹å…¨é ‚ç‚¹ã«ã¤ã„ã¦
		for (int j = 0; j < controlPointIndicesCount; j++) {
			int vertIndex = controlPointIndices[j];
			//ã‚¹ã‚­ãƒ³ã‚¦ã‚§ã‚¤ãƒˆ
			float weight = (float)controlPointWeights[j];
			//ãã®é ‚ç‚¹ã®å½±éŸ¿ã‚’å—ã‘ã‚‹ãƒœãƒ¼ãƒ³ãƒªã‚¹ãƒˆã«ãƒœãƒ¼ãƒ³ã¨ã‚¦ã‚§ã‚¤ãƒˆã®ãƒšã‚¢ã‚’è¿½åŠ 
			weightLists[vertIndex].emplace_back(WeightSet{ (UINT)i,weight });
		}

		auto& vertices = model->vertices;
		for (int i = 0; i < vertices.size(); i++) {
			auto& weightList = weightLists[i];
			weightList.sort([](auto const& lhs, auto const& rhs) {
			//å·¦ã®è¦ç´ ã®æ–¹ãŒå¤§ãã‘ã‚Œã°true ãã†ã§ãªã‘ã‚Œã°falseã‚’è¿”ã™
			return lhs.weight > rhs.weight;
			});

			int weightArrayIndex = 0;
			//é™é †ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®ã‚¦ã‚§ã‚¤ãƒˆãƒªã‚¹ãƒˆã‹ã‚‰
			for (auto& weightSet : weightList) {
				vertices[i].boneIndex[weightArrayIndex] = weightSet.index;
				vertices[i].boneWeight[weightArrayIndex] = weightSet.weight;
				//4ã¤ã«é”ã—ãŸã‚‰çµ‚äº†
				if (++weightArrayIndex >= FbxModel::MAX_BONE_INDICES) {
					float weight = 0.0f;
					//2ç•ªç›®ä»¥é™ã®ã‚¦ã‚§ã‚¤ãƒˆã‚’åˆè¨ˆ
					for (int j = 1; j < FbxModel::MAX_BONE_INDICES; j++) {
						weight += vertices[i].boneWeight[j];
					}
					//åˆè¨ˆã§1.0f(100%)ã«ãªã‚‹ã‚ˆã†ã«èª¿æ•´
					vertices[i].boneWeight[0] = 1.0f - weight;
					break;
				}
			}
		}
	}
}
</file_content>

<file_content path="engine/3d/FbxLoader.h">
#pragma once
#pragma warning(push)
#pragma	warning(disable:26495)
#pragma	warning(disable:26451)
#include <fbxsdk.h>
#pragma warning(pop)

#include "d3d12.h"
#include "d3dx12.h"
#include <string>
#include "FbxModel.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma	warning(disable:26813)
#include "DirectXTex.h"
#pragma warning(pop)

class FbxLoader {
	//ã‚¨ã‚¤ãƒªã‚¢ã‚¹
private:
	using string = std::string;

public:
	//ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	//<return>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</return>
	static FbxLoader* GetInstance();

	//åˆæœŸåŒ–
	void Initialize(ID3D12Device* device);

	//fbxãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	FbxModel* LoadModelFlomFile(const string& modelName);

	//ãƒãƒ¼ãƒ‰è§£æ
	void ParseNodeRecursive(FbxModel* model, FbxNode* fbxNode,Node* parent = nullptr);

	//ãƒ¡ãƒƒã‚·ãƒ¥è§£æ
	void ParseMesh(FbxModel* model, FbxNode* fbxNode);
	//ã‚µãƒ–
	void ParseMeshVertices(FbxModel* model, FbxMesh* fbxMesh);
	void ParseMeshFaces(FbxModel* model, FbxMesh* fbxMesh);
	void ParseMatrial(FbxModel* model, FbxNode* fbxNode);
	void LoadTexture(FbxModel* model, const std::string& fullPath);

	static void ConvertMatrixFromFbx(Matrix4 dst, const FbxAMatrix& src);

	//ãƒ•ã‚¡ã‚¤ãƒ«åæŠ½å‡º
	std::string ExtracFileName(const std::string& path);

	//å¾Œå§‹æœ«
	void Finalize();

	//ã‚¹ã‚­ãƒ‹ãƒ³ã‚°æƒ…å ±ã®èª­ã¿å–ã‚Š
	void ParseSkin(FbxModel* model, FbxMesh* fbxMesh);

private:
	//D3D12ãƒ‡ãƒã‚¤ã‚¹
	ID3D12Device* device = nullptr;
	//FBXãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	FbxManager* fbxManager = nullptr;
	//FBXã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼
	FbxImporter* fbxImporter = nullptr;

private:
	//privateãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	FbxLoader() = default;
	//privateãªãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~FbxLoader() = default;
	//ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç¦æ­¢
	FbxLoader(const FbxLoader& obj) = delete;
	//ã‚³ãƒ”ãƒ¼ä»£å…¥æ¼”ç®—å­ã‚’ç¦æ­¢
	void operator=(const FbxLoader& obj) = delete;

//privateé™çš„é–¢æ•°
private:
	static const string defaultTextureFileName;
public:
	static const string baseDirectory;
};
</file_content>

<file_content path="engine/3d/FbxModel.cpp">
#include "FbxModel.h"

FbxModel::~FbxModel() {
	//FBXã‚·ãƒ¼ãƒ³ã®è§£æ”¾
	fbxScene->Destroy();
}

void FbxModel::CreateBuffers(ID3D12Device* device)
{
	HRESULT result;

	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿å…¨ä½“ã®ã‚µã‚¤ã‚º
	UINT sizeVB =
		static_cast<UINT>(sizeof(VertexPosNormalUvSkin) * vertices.size());

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPosNormalUvSkin* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		std::copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼(VBV)ã®ç”Ÿæˆ
	vbView.BufferLocation =
		vertBuff->GetGPUVirtualAddress();
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	//é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å…¨ä½“ã®ã‚µã‚¤ã‚º
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	resourceDesc.Width = sizeIB;

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&indexBuff));
	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	unsigned short* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result)) {
		std::copy(indices.begin(), indices.end(), indexMap);
		indexBuff->Unmap(0, nullptr);
	}
	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼(IBV)ã®ä½œæˆ
	ibView.BufferLocation =
		indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	ibView.SizeInBytes = sizeIB;

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”»åƒãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	const DirectX::Image* img = scratchImg.GetImage(0, 0, 0);
	assert(img);
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metaData.format, metaData.width,
		(UINT)metaData.height, (UINT16)metaData.arraySize,
		(UINT16)metaData.mipLevels);
	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps1 = CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps1,
		D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr, IID_PPV_ARGS(&texBuff));
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
	result = texBuff->WriteToSubresource(
		0, nullptr,
		img->pixels,
		(UINT)img->rowPitch, (UINT)img->slicePitch);

	//SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	descHeapDesc.NumDescriptors = 1;
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeapSRV));
	//ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼(SRV)ä½œæˆ
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	D3D12_RESOURCE_DESC resDesc = texBuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texBuff.Get(),
		&srvDesc, descHeapSRV->GetCPUDescriptorHandleForHeapStart()
	);
}

void FbxModel::Draw(ID3D12GraphicsCommandList* cmdList)
{
	assert(cmdList);
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ã‚»ãƒƒãƒˆ
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ã‚»ãƒƒãƒˆ
	cmdList->IASetIndexBuffer(&ibView);

	//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ã‚»ãƒƒãƒˆ
	ID3D12DescriptorHeap* ppheaps[] = { descHeapSRV.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppheaps), ppheaps);

	//ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootDescriptorTable(3, descHeapSRV->GetGPUDescriptorHandleForHeapStart());
	//æç”»ã‚³ãƒãƒ³ãƒ‰
	cmdList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}

</file_content>

<file_content path="engine/3d/FbxModel.h">
#pragma once
#include <string>
#include <vector>
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#pragma warning(push)
#pragma	warning(disable:26495)
#pragma	warning(disable:26451)
#include <fbxsdk.h>
#pragma warning(pop)

//ãƒãƒ¼ãƒ‰
struct Node {
	//åå‰
	std::string name;
	//ã‚¹ã‚±ãƒ¼ãƒ«
	Vector4 scaling = { 1,1,1,0 };
	//å›è»¢è§’
	Vector4 rotation = { 0,0,0,0 };
	//ãƒ­ãƒ¼ã‚«ãƒ«ç§»å‹•
	Vector4 translation = { 0,0,0,1 };
	//ãƒ­ãƒ¼ã‚«ãƒ«å¤‰å½¢è¡Œåˆ—
	Matrix4 tranform;
	//ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰å½¢è¡Œåˆ—
	Matrix4 globalTransform;
	//è¦ªãƒãƒ¼ãƒ‰
	Node* parent = nullptr;
};

class FbxModel {
public:
	friend class FbxLoader;
public://å®šæ•°
	//ãƒœãƒ¼ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æœ€å¤§æ•°
	static const int MAX_BONE_INDICES = 4;
//ã‚µãƒ–ã‚¯ãƒ©ã‚¹
public:
	struct VertexPosNormalUvSkin {
		Vector3 pos;
		Vector3 normal;
		Vector2 uv;
		UINT boneIndex[MAX_BONE_INDICES];
		float boneWeight[MAX_BONE_INDICES];
	};
	//ãƒœãƒ¼ãƒ³
	struct Bone {
		std::string name;
		//åˆæœŸå§¿å‹¢ã®é€†è¡Œåˆ—
		Matrix4 inInitialPose;
		//ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼
		FbxCluster* fbxCluster;
		//ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
		Bone(const std::string& name) {
			this->name = name;
		}
	};

private://ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	template <class T> using ComPtr =
		Microsoft::WRL::ComPtr<T>;
	//DirectX::ã‚’çœç•¥
	using TexMetadata = DirectX::TexMetadata;
	using sSratchImage = DirectX::ScratchImage;
	//std::ã‚’çœç•¥
	using string = std::string;
	template <class T> using vector =
		std::vector<T>;
private:
	//ãƒ¢ãƒ‡ãƒ«ã®åå‰
	std::string name;
	//ãƒãƒ¼ãƒ‰é…åˆ—
	std::vector<Node> nodes;
	//ãƒ¡ãƒƒã‚·ãƒ¥ã‚’æŒã¤ãƒãƒ¼ãƒ‰
	Node* meshNode = nullptr;
	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	std::vector<VertexPosNormalUvSkin> vertices;
	//é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	std::vector<unsigned int>indices;
	//ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆ
	Vector3 ambient = { 1,1,1 };
	//ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚º
	Vector3 diffuse = { 1,1,1 };
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
	DirectX::TexMetadata metaData = {};
	//ã‚¹ã‚¯ãƒ©ãƒƒãƒã‚¤ãƒ¡ãƒ¼ã‚¸
	DirectX::ScratchImage scratchImg = {};
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> vertBuff;
	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> indexBuff;
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> texBuff;
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vbView = {};
	//ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_INDEX_BUFFER_VIEW ibView = {};
	//SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descHeapSRV;
	//ãƒœãƒ¼ãƒ³é…åˆ—
	std::vector<Bone> bones;
	//FBXã‚·ãƒ¼ãƒ³
	FbxScene* fbxScene = nullptr;

public://é–¢æ•°
	~FbxModel();
	void CreateBuffers(ID3D12Device* device);
	//æç”»
	void Draw(ID3D12GraphicsCommandList* cmdList);
	//ãƒ¢ãƒ‡ãƒ«ã®å¤‰å½¢è¡Œåˆ—å–å¾—
	const Matrix4& GetModelTransform() { return meshNode->globalTransform; }
	//getter
	std::vector<Bone>& GetBones() { return bones; }
	FbxScene* GetFbxScene() { return fbxScene; }
};
</file_content>

<file_content path="engine/3d/FbxObject3d.cpp">
#include "FbxObject3d.h"
#include <d3dcompiler.h>
#pragma comment(lib, "d3dcompiler.lib")

using namespace Microsoft::WRL;

ID3D12Device* FbxObject3d::device = nullptr;
ViewProjection* FbxObject3d::view = nullptr;
ComPtr<ID3D12RootSignature> FbxObject3d::rootsignature;
ComPtr<ID3D12PipelineState> FbxObject3d::pipelinestate;
ID3D12GraphicsCommandList* FbxObject3d::cmdList = nullptr;

void FbxObject3d::CreateGraphicsPipeline()
{

	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/FBXVS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/FBXPS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // uvåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æµã‚Œã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¹ã‚¯
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // æ¨™æº–è¨­å®š
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®šï¼ˆä¸‰è§’å½¢ï¼‰
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	gpipeline.NumRenderTargets = 1;	// æç”»å¯¾è±¡ã¯1ã¤
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½255æŒ‡å®šã®RGBA
	gpipeline.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 ãƒ¬ã‚¸ã‚¹ã‚¿

	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	#pragma warning(push)
	#pragma	warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[4];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsConstantBufferView(1, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[2].InitAsConstantBufferView(2, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[3].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è‡ªå‹•åˆ¤å®šã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}

void FbxObject3d::Initialize()
{
	HRESULT result;
	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
		// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataTransform) + 0xff) & ~0xff);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffTransform)
	);

	worldTransform.Initialize();
}

void FbxObject3d::Update()
{
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¡Œåˆ—æ›´æ–°ã¨è»¢é€
	worldTransform.UpdateMatrix();
}

void FbxObject3d::Draw(ViewProjection* viewProjection)
{
		// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(FbxObject3d::cmdList);

	// ãƒ¢ãƒ‡ãƒ«ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (model == nullptr) return;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform.GetBuff()->GetGPUVirtualAddress());

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›ãƒ‡ãƒ¼ã‚¿å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());
	// ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
	model->Draw(cmdList);
}

void FbxObject3d::StaticInitialize(ID3D12Device* device)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);

	FbxObject3d::device = device;

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã«ãƒ‡ãƒã‚¤ã‚¹ã‚’è²¸ã™
	WorldTransform::StaticInitialize(device);
}

void FbxObject3d::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	// PreDrawã¨PostDrawãŒãƒšã‚¢ã§å‘¼ã°ã‚Œã¦ã„ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼
	assert(FbxObject3d::cmdList == nullptr);

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ã‚»ãƒƒãƒˆ
	FbxObject3d::cmdList = cmdList;


	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	cmdList->SetPipelineState(pipelinestate.Get());
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã‚’è¨­å®š
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

}

void FbxObject3d::PostDraw()
{
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’è§£é™¤
	FbxObject3d::cmdList = nullptr;
}
</file_content>

<file_content path="engine/3d/FbxObject3d.h">
#pragma once

#include "FbxModel.h"
#include "ViewProjection.h"
#include "WorldTransform.h"
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#include <string>

class FbxObject3d {
protected://ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
public:
	static void StaticInitialize(ID3D12Device* device);
	static void SetCamera(ViewProjection* view_) { FbxObject3d::view = view_; }

	/// æç”»å‰å‡¦ç†
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);
	/// æç”»å¾Œå‡¦ç†
	static void PostDraw();
	
	static void CreateGraphicsPipeline();
private://é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°
	static ID3D12Device* device;
	static ViewProjection* view;
public://ã‚µãƒ–ã‚¯ãƒ©ã‚¹
	struct ConstBufferDataTransform {
		Matrix4 viewproj;
		Matrix4 world;
		Vector3 cameraPos;
	};
public://ãƒ¡ãƒ³ãƒé–¢æ•°
	void Initialize();

	void Update();

	void SetModel(FbxModel* model) { this->model = model; }

	void Draw(ViewProjection* viewProjection);

	const Vector3& GetPosition() const { return worldTransform.position_; }
	void SetPosition(const Vector3& position) { this->worldTransform.position_ = position; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤§ãã•
	void SetScale(const Vector3& scale) { this->worldTransform.scale_ = scale; }
	const Vector3& GetScale() const { return worldTransform.scale_; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å›è»¢
	void SetRotation(const Vector3& rotation) { this->worldTransform.rotation_ = rotation; }
	const Vector3& GetRotation() const { return worldTransform.rotation_; }

protected://ãƒ¡ãƒ³ãƒå¤‰æ•°
	ComPtr<ID3D12Resource> constBuffTransform;
private:
	static ComPtr<ID3D12RootSignature> rootsignature;
	static ComPtr<ID3D12PipelineState> pipelinestate;
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	static ID3D12GraphicsCommandList* cmdList;

	WorldTransform worldTransform;
	FbxModel* model = nullptr;
};
</file_content>

<file_content path="engine/3d/Model.cpp">
#include "Model.h"

#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <fstream>
#include <sstream>
#include <vector>
#include <cassert>

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®Ÿä½“
ID3D12Device* Model::device = nullptr;

Model* Model::LoadFromOBJ(const string& modelname, const string& texname)
{
	// æ–°ãŸãªModelå‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿
	Model* model = new Model();

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	model->InitializeDescriptorHeap();

	// OBJãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	model->LoadFromOBJInternal(modelname);

	// ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	model->CreateBuffers();

	//model->LoadTexture(texname);
	
	return model;
}

void Model::LoadMaterial(const std::string& directoryPath, const std::string& filename)
{
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
	std::ifstream file;
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(directoryPath + filename);
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’ãƒã‚§ãƒƒã‚¯
	if (file.fail()) {
		assert(0);
	}

	// 1è¡Œãšã¤èª­ã¿è¾¼ã‚€
	string line;
	while (getline(file, line)) {
		// 1è¡Œåˆ†ã®æ–‡å­—åˆ—ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¤‰æ›
		std::istringstream line_stream(line);

		// åŠè§’ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§è¡Œã®å…ˆé ­æ–‡å­—åˆ—ã‚’å–å¾—
		string key;
		getline(line_stream, key, ' ');

		// å…ˆé ­ã®ã‚¿ãƒ–æ–‡å­—ã¯ç„¡è¦–ã™ã‚‹
		if (key[0] == '\t')
		{
			key.erase(key.begin()); // å…ˆé ­ã®æ–‡å­—ã‚’å‰Šé™¤
		}
		// å…ˆé ­æ–‡å­—åˆ—ãŒnewmtlãªã‚‰ãƒãƒ†ãƒªã‚¢ãƒ«å
		if (key == "newmtl")
		{
			// ãƒãƒ†ãƒªã‚¢ãƒ«åèª­ã¿è¾¼ã¿
			line_stream >> material.name;
		}
		// å…ˆé ­æ–‡å­—åˆ—ãŒKaãªã‚‰ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆè‰²
		if (key == "Ka")
		{
			line_stream >> material.ambient.x;
			line_stream >> material.ambient.y;
			line_stream >> material.ambient.z;
		}
		// å…ˆé ­æ–‡å­—åˆ—ãŒKdãªã‚‰ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºè‰²
		if (key == "Kd")
		{
			line_stream >> material.diffuse.x;
			line_stream >> material.diffuse.y;
			line_stream >> material.diffuse.z;
		}
		// å…ˆé ­æ–‡å­—åˆ—ãŒKsãªã‚‰ã‚¹ãƒšã‚­ãƒ¥ãƒ©ãƒ¼è‰²
		if (key == "Ks")
		{
			line_stream >> material.specular.x;
			line_stream >> material.specular.y;
			line_stream >> material.specular.z;
		}
		// å…ˆé ­æ–‡å­—åˆ—ãŒmap_Kdãªã‚‰ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«å
		if (key == "map_Kd") {
			// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ•ã‚¡ã‚¤ãƒ«åèª­ã¿è¾¼ã¿
			line_stream >> material.textureFilename;
			// ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
			LoadTexture(directoryPath, material.textureFilename);
		}
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
	file.close();
}

void Model::LoadTexture(const std::string& directoryPath, const std::string& filename)
{
	HRESULT result = S_FALSE;

	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’çµåˆ
	string filepath = directoryPath + filename;

	// ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹
	wchar_t wfilepath[128];
	int iBufferSize = MultiByteToWideChar(CP_ACP, 0, filepath.c_str(), -1, wfilepath, _countof(wfilepath));
#pragma warning(push)
#pragma warning(disable:6054)
#pragma warning(disable:6001)
	result = LoadFromWICFile(
		wfilepath, WIC_FLAGS_NONE,
		&metadata, scratchImg
	);
	assert(SUCCEEDED(result));
#pragma warning(pop)

	ScratchImage mipChain{};
	// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ç”Ÿæˆ
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// èª­ã¿è¾¼ã‚“ã ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’SRGBã¨ã—ã¦æ‰±ã†
	metadata.format = MakeSRGB(metadata.format);

	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨æŒ‡å®š
		nullptr, IID_PPV_ARGS(&texbuff));
	assert(SUCCEEDED(result));

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // ç”Ÿãƒ‡ãƒ¼ã‚¿æŠ½å‡º
		result = texbuff->WriteToSubresource(
			(UINT)i,
			nullptr,              // å…¨é ˜åŸŸã¸ã‚³ãƒ”ãƒ¼
			img->pixels,          // å…ƒãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ‰ãƒ¬ã‚¹
			(UINT)img->rowPitch,  // 1ãƒ©ã‚¤ãƒ³ã‚µã‚¤ã‚º
			(UINT)img->slicePitch // 1æšã‚µã‚¤ã‚º
		);
		assert(SUCCEEDED(result));
	}

	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ä½œæˆ
	cpuDescHandleSRV = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);
	gpuDescHandleSRV = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // è¨­å®šæ§‹é€ ä½“
	D3D12_RESOURCE_DESC resDesc = texbuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texbuff.Get(), //ãƒ“ãƒ¥ãƒ¼ã¨é–¢é€£ä»˜ã‘ã‚‹ãƒãƒƒãƒ•ã‚¡
		&srvDesc, //ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®šæƒ…å ±
		cpuDescHandleSRV
	);

}

void Model::LoadTexture(const std::string& filename)
{
	HRESULT result = S_FALSE;

	TexMetadata metadata{};
	ScratchImage scratchImg{};

	// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’çµåˆ
	string filepath = filename;

	// ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹
	wchar_t wfilepath[128];
	int iBufferSize = MultiByteToWideChar(CP_ACP, 0, filepath.c_str(), -1, wfilepath, _countof(wfilepath));

	result = LoadFromWICFile(
		wfilepath, WIC_FLAGS_NONE,
		&metadata, scratchImg
	);
	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ç”Ÿæˆ
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result)) {
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}

	// èª­ã¿è¾¼ã‚“ã ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’SRGBã¨ã—ã¦æ‰±ã†
	metadata.format = MakeSRGB(metadata.format);

	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		metadata.format, metadata.width, (UINT)metadata.height, (UINT16)metadata.arraySize,
		(UINT16)metadata.mipLevels);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps =
		CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &texresDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, // ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨æŒ‡å®š
		nullptr, IID_PPV_ARGS(&texbuff));
	assert(SUCCEEDED(result));

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
	for (size_t i = 0; i < metadata.mipLevels; i++) {
		const Image* img = scratchImg.GetImage(i, 0, 0); // ç”Ÿãƒ‡ãƒ¼ã‚¿æŠ½å‡º
		result = texbuff->WriteToSubresource(
			(UINT)i,
			nullptr,              // å…¨é ˜åŸŸã¸ã‚³ãƒ”ãƒ¼
			img->pixels,          // å…ƒãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ‰ãƒ¬ã‚¹
			(UINT)img->rowPitch,  // 1ãƒ©ã‚¤ãƒ³ã‚µã‚¤ã‚º
			(UINT)img->slicePitch // 1æšã‚µã‚¤ã‚º
		);
		assert(SUCCEEDED(result));
	}

	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ä½œæˆ
	cpuDescHandleSRV = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);
	gpuDescHandleSRV = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize);

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{}; // è¨­å®šæ§‹é€ ä½“
	D3D12_RESOURCE_DESC resDesc = texbuff->GetDesc();

	srvDesc.Format = resDesc.Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;//2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
	srvDesc.Texture2D.MipLevels = 1;

	device->CreateShaderResourceView(texbuff.Get(), //ãƒ“ãƒ¥ãƒ¼ã¨é–¢é€£ä»˜ã‘ã‚‹ãƒãƒƒãƒ•ã‚¡
		&srvDesc, //ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®šæƒ…å ±
		cpuDescHandleSRV
	);

}

void Model::Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndexMaterial,float alpha_)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(cmdList);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
	cmdList->IASetVertexBuffers(0, 1, &vbView);
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š
	cmdList->IASetIndexBuffer(&ibView);
	//alphaå€¤è¨­å®š
	SetAlpha(alpha_);
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(rootParamIndexMaterial,
		constBuffB1->GetGPUVirtualAddress());

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®é…åˆ—
	ID3D12DescriptorHeap* ppHeaps[] = { descHeap.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	if (material.textureFilename.size() > 0) {
		// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
		cmdList->SetGraphicsRootDescriptorTable(3, gpuDescHandleSRV);
	}

	// æç”»ã‚³ãƒãƒ³ãƒ‰
	cmdList->DrawIndexedInstanced((UINT)indices.size(), 1, 0, 0, 0);
}

void Model::LoadFromOBJInternal(const string& modelname)
{
	HRESULT result = S_FALSE;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
	std::ifstream file;
	// .objãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	const string filename = modelname + ".obj"; // "modelname.obj"
	const string directoryPath = "Resources/" + modelname + "/"; // "Resources/modelname/"
	file.open(directoryPath + filename); // "Resources/modelname.obj"
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’ãƒã‚§ãƒƒã‚¯
	if (file.fail()) {
		assert(0);
	}
	vector<Vector3> positions; // é ‚ç‚¹åº§æ¨™
	vector<Vector3> normals;   // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«

	vector<Vector2> texcoords; // ãƒ†ã‚¯ã‚¹ãƒãƒ£UV
	// ï¼‘è¡Œãšã¤èª­ã¿è¾¼ã‚€
	string line;
	while (getline(file, line)) {

		// ï¼‘è¡Œåˆ†ã®æ–‡å­—åˆ—ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¤‰æ›ã—ã¦è§£æã—ã‚„ã™ãã™ã‚‹
		std::istringstream line_stream(line);

		// åŠè§’ã‚¹ãƒ‘ãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§è¡Œã®å…ˆé ­æ–‡å­—åˆ—ã‚’å–å¾—
		string key;
		getline(line_stream, key, ' ');

		// å…ˆé ­æ–‡å­—åˆ—ãŒï½–ãªã‚‰é ‚ç‚¹åº§æ¨™
		if (key == "v") {
			// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
			positions.emplace_back(position);
			// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
			/*VertexPosNormalUvSkin vertex{};
			vertex.pos = position;
			vertices.emplace_back(vertex);*/
		}

		// å…ˆé ­æ–‡å­—åˆ—ãŒï½†ãªã‚‰ãƒãƒªã‚´ãƒ³ï¼ˆä¸‰è§’å½¢ï¼‰
		if (key == "f") {
			// åŠè§’ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§è¡Œã®ç¶šãã‚’èª­ã¿è¾¼ã‚€
			string index_string;
			while (getline(line_stream, index_string, ' ')) {
				// é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‘å€‹åˆ†ã®æ–‡å­—åˆ—ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¤‰æ›ã—ã¦è§£æã—ã‚„ã™ãã™ã‚‹
				std::istringstream index_stream(index_string);
				unsigned short indexPosition, indexNormal, indexTexcoord;
				index_stream >> indexPosition;
				index_stream.seekg(1, ios_base::cur); // ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’é£›ã°ã™
				index_stream >> indexTexcoord;
				index_stream.seekg(1, ios_base::cur); // ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’é£›ã°ã™
				index_stream >> indexNormal;
				// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
				VertexPosNormalUvSkin vertex{};
				vertex.pos = positions[indexPosition - 1];
				vertex.normal = normals[indexNormal - 1];
				vertex.uv = texcoords[indexTexcoord - 1];
				vertices.emplace_back(vertex);
				// é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«è¿½åŠ 
				//indices.emplace_back(indexPosition - 1);
				indices.emplace_back((unsigned short)indices.size());
			}
		}

		// å…ˆé ­æ–‡å­—åˆ—ãŒvtãªã‚‰ãƒ†ã‚¯ã‚¹ãƒãƒ£
		if (key == "vt")
		{
			// U,Væˆåˆ†èª­ã¿è¾¼ã¿
			Vector2 texcoord{};
			line_stream >> texcoord.x;
			line_stream >> texcoord.y;
			// Væ–¹å‘åè»¢
			texcoord.y = 1.0f - texcoord.y;
			// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
			texcoords.emplace_back(texcoord);
		}

		// å…ˆé ­æ–‡å­—åˆ—ãŒvnãªã‚‰æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
		if (key == "vn") {
			// X,Y,Zæˆåˆ†èª­ã¿è¾¼ã¿
			Vector3 normal{};
			line_stream >> normal.x;
			line_stream >> normal.y;
			line_stream >> normal.z;
			// æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ãƒ†ãƒ¼ã‚¿ã«è¿½åŠ 
			normals.emplace_back(normal);
		}

		// å…ˆé ­æ–‡å­—åˆ—ãŒmtllibãªã‚‰ãƒãƒ†ãƒªã‚¢ãƒ«
		if (key == "mtllib")
		{
			// ãƒãƒ†ãƒªã‚¢ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«åèª­ã¿è¾¼ã¿
			string filename;
			line_stream >> filename;
			// ãƒãƒ†ãƒªã‚¢ãƒ«èª­ã¿è¾¼ã¿
			LoadMaterial(directoryPath, filename);
		}
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«ã¨é–‰ã˜ã‚‹
	file.close();
}

void Model::InitializeDescriptorHeap()
{
	assert(device);

	HRESULT result = S_FALSE;

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰è¦‹ãˆã‚‹ã‚ˆã†ã«
	descHeapDesc.NumDescriptors = 1; // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼1ã¤
	result = device->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap));//ç”Ÿæˆ
	if (FAILED(result)) {
		assert(0);
	}

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚ºã‚’å–å¾—
	descriptorHandleIncrementSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

void Model::CreateBuffers()
{
	HRESULT result = S_FALSE;

	std::vector<VertexPosNormalUvSkin> realVertices;

	/*UINT sizeVB = static_cast<UINT>(sizeof(vertices));*/
	UINT sizeVB = static_cast<UINT>(sizeof(VertexPosNormalUvSkin) * vertices.size());

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPosNormalUvSkin* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		/*memcpy(vertMap, vertices, sizeof(vertices));*/
		std::copy(vertices.begin(), vertices.end(), vertMap);
		vertBuff->Unmap(0, nullptr);
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	/*vbView.SizeInBytes = sizeof(vertices);*/
	vbView.SizeInBytes = sizeVB;
	vbView.StrideInBytes = sizeof(vertices[0]);

	/*UINT sizeIB = static_cast<UINT>(sizeof(indices));*/
	UINT sizeIB = static_cast<UINT>(sizeof(unsigned short) * indices.size());
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	resourceDesc.Width = sizeIB;

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&indexBuff));

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	unsigned short* indexMap = nullptr;
	result = indexBuff->Map(0, nullptr, (void**)&indexMap);
	if (SUCCEEDED(result)) {

		// å…¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾ã—ã¦
		//for (int i = 0; i < _countof(indices); i++)
		//{
		//	indexMap[i] = indices[i];	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚³ãƒ”ãƒ¼
		//}

		std::copy(indices.begin(), indices.end(), indexMap);

		indexBuff->Unmap(0, nullptr);
	}

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	ibView.BufferLocation = indexBuff->GetGPUVirtualAddress();
	ibView.Format = DXGI_FORMAT_R16_UINT;
	/*ibView.SizeInBytes = sizeof(indices);*/
	ibView.SizeInBytes = sizeIB;

	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps1 = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);

	//HRESULT result;

	resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB1) + 0xff) & ~0xff);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapProps1,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB1)
	);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã¸ãƒ‡ãƒ¼ã‚¿è»¢é€
	ConstBufferDataB1* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	if (SUCCEEDED(result)) {
		constMap1->ambient = material.ambient;
		constMap1->diffuse = material.diffuse;
		constMap1->specular = material.specular;
		constMap1->alpha = material.alpha;
		constBuffB1->Unmap(0, nullptr);
	}
}

void Model::SetAlpha(float alpha_) {

	HRESULT result = S_FALSE;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã¸ãƒ‡ãƒ¼ã‚¿è»¢é€
	ConstBufferDataB1* constMap1 = nullptr;
	result = constBuffB1->Map(0, nullptr, (void**)&constMap1);
	if (SUCCEEDED(result)) {
		constMap1->alpha = alpha_;
		constBuffB1->Unmap(0, nullptr);
	}
}
</file_content>

<file_content path="engine/3d/Model.h">
#pragma once

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <d3dx12.h>
#include <string>
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"
#pragma warning(push)
#pragma warning(disable:26495)
class Model 
{
private: // ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // ã‚µãƒ–ã‚¯ãƒ©ã‚¹
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
	struct VertexPosNormalUvSkin
	{
		Vector3 pos; // xyzåº§æ¨™
		Vector3 normal; // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
		Vector2 uv;  // uvåº§æ¨™
	};

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“B0
	struct ConstBufferDataB0
	{
		//XMFLOAT4 color;	// è‰² (RGBA)
		Matrix4 mat;	// ï¼“ï¼¤å¤‰æ›è¡Œåˆ—
	};

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“B1
	struct ConstBufferDataB1
	{
		Vector3 ambient; // ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆä¿‚æ•°
		float pad1;       // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
		Vector3 diffuse; // ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºä¿‚æ•°
		float pad2;       // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
		Vector3 specular; // ã‚¹ãƒšã‚­ãƒ¥ãƒ©ãƒ¼ä¿‚æ•°
		float alpha;       // ã‚¢ãƒ«ãƒ•ã‚¡
	};

	// ãƒãƒ†ãƒªã‚¢ãƒ«
	struct Material
	{
		std::string name; // ãƒãƒ†ãƒªã‚¢ãƒ«å
		Vector3 ambient; // ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆå½±éŸ¿åº¦
		Vector3 diffuse; // ãƒ‡ã‚£ãƒ•ã‚§ãƒ¼ã‚ºå½±éŸ¿åº¦
		Vector3 specular;// ã‚¹ãƒšã‚­ãƒ¥ãƒ©ãƒ¼å½±éŸ¿åº¦
		float alpha;      // ã‚¢ãƒ«ãƒ•ã‚¡
		std::string textureFilename; // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«å
		// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
		Material() {
			ambient = { 0.3f,0.3f,0.3f };
			diffuse = { 0.0f,0.0f,0.0f };
			specular = { 0.0f,0.0f,0.0f };
			alpha = 1.0f;
		}
	};

private: // å®šæ•°
	static const int division = 50; // åˆ†å‰²æ•°
	static const float radius; // åº•é¢ã®åŠå¾„
	static const float prizmHeight; // æŸ±ã®é«˜ã•
	static const int planeCount = division * 2 + division * 2; // é¢ã®æ•°
	static const int vertexCount = planeCount * 3; // é ‚ç‚¹æ•°

public: // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	
	// OBJãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰3Dãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
	static Model* LoadFromOBJ(const std::string& modelname, const std::string& texname = "Resources");

	// ãƒãƒ†ãƒªã‚¢ãƒ«èª­ã¿è¾¼ã¿
	void LoadMaterial(const std::string& directoryPath, const std::string& filename);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	void LoadTexture(const std::string& directoryPath, const std::string& filename);
	void LoadTexture(const std::string& filename = "Resources");

	// æç”»
	/// <param name="cmdList">æç”»ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="rootParamIndexMaterial">ãƒãƒ†ãƒªã‚¢ãƒ«ç”¨ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç•ªå·</param>
	void Draw(ID3D12GraphicsCommandList* cmdList, UINT rootParamIndexMaterial,float alpha_ = 1);

	// setter
	static void SetDevice(ID3D12Device* device) { Model::device = device; }

	void SetAlpha(float alpha_);


private: // é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ‡ãƒã‚¤ã‚¹
	static ID3D12Device* device;
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿é…åˆ—
	std::vector<VertexPosNormalUvSkin> vertices;
	// é ‚ç‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—
	std::vector<unsigned short> indices;
	// ãƒãƒ†ãƒªã‚¢ãƒ«
	Material material;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> texbuff;
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descHeap;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒ«(CPU)
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuDescHandleSRV;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒ«(CPU)
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuDescHandleSRV;
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	UINT descriptorHandleIncrementSize;
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> vertBuff;
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> indexBuff;
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vbView;
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_INDEX_BUFFER_VIEW ibView;
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ï¼ˆãƒãƒ†ãƒªã‚¢ãƒ«ï¼‰
	ComPtr<ID3D12Resource> constBuffB1; // å®šæ•°ãƒãƒƒãƒ•ã‚¡

private:// é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	// OBJãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰3Dãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€(éå…¬é–‹)
	void LoadFromOBJInternal(const std::string& modelname);

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®åˆæœŸåŒ–
	void InitializeDescriptorHeap();

	// å„ç¨®ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	void CreateBuffers();

};
</file_content>

<file_content path="engine/3d/Object3d.cpp">
#include "Object3d.h"
#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <fstream>
#include <sstream>
#include <vector>
#include <CollisionManager.h>

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;
using namespace std;

/// <summary>
/// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®Ÿä½“
/// </summary>
ID3D12Device* Object3d::device = nullptr;
ID3D12GraphicsCommandList* Object3d::cmdList = nullptr;
ComPtr<ID3D12RootSignature> Object3d::rootsignature;
ComPtr<ID3D12PipelineState> Object3d::pipelinestate;

Object3d::~Object3d()
{
	if (collider)
	{
		//ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã‹ã‚‰ç™»éŒ²ã‚’è§£é™¤ã™ã‚‹
		CollisionManager::GetInstance()->RemoveCollider(collider);

		delete collider;
	}
}

void Object3d::StaticInitialize(ID3D12Device * device, int window_width, int window_height)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);

	Object3d::device = device;

	// ãƒ¢ãƒ‡ãƒ«ã«ãƒ‡ãƒã‚¤ã‚¹ã‚’ã‚»ãƒƒãƒˆ
	Model::SetDevice(device);

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã«ãƒ‡ãƒã‚¤ã‚¹ã‚’è²¸ã™
	WorldTransform::StaticInitialize(device);

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åˆæœŸåŒ–
	InitializeGraphicsPipeline();
}

void Object3d::PreDraw(ID3D12GraphicsCommandList * cmdList)
{
	// PreDrawã¨PostDrawãŒãƒšã‚¢ã§å‘¼ã°ã‚Œã¦ã„ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼
	assert(Object3d::cmdList == nullptr);

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ã‚»ãƒƒãƒˆ
	Object3d::cmdList = cmdList;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	cmdList->SetPipelineState(pipelinestate.Get());
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã‚’è¨­å®š
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

void Object3d::PostDraw()
{
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’è§£é™¤
	Object3d::cmdList = nullptr;
}

Object3d * Object3d::Create()
{
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	Object3d* object3d = new Object3d();
	if (object3d == nullptr) {
		return nullptr;
	}

	// åˆæœŸåŒ–
	if (!object3d->Initialize()) {
		delete object3d;
		assert(0);
		return nullptr;
	}


	return object3d;
}

void Object3d::InitializeGraphicsPipeline()
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/OBJVS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/OBJPS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{ // uvåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æµã‚Œã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¹ã‚¯
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // æ¨™æº–è¨­å®š
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®šï¼ˆä¸‰è§’å½¢ï¼‰
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	gpipeline.NumRenderTargets = 1;	// æç”»å¯¾è±¡ã¯1ã¤
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½255æŒ‡å®šã®RGBA
	gpipeline.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 ãƒ¬ã‚¸ã‚¹ã‚¿

	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	#pragma warning(push)
	#pragma warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[4];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsConstantBufferView(1, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[2].InitAsConstantBufferView(2, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[3].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è‡ªå‹•åˆ¤å®šã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	result = device->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}

bool Object3d::Initialize()
{
	//worldTransformåˆæœŸåŒ–
	worldTransform_.Initialize();

	//ã‚¯ãƒ©ã‚¹åã®æ–‡å­—åˆ—ã‚’å–å¾—
	name = typeid(*this).name();

	isLocked = false;

	return true;
}

void Object3d::Update()
{
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¡Œåˆ—æ›´æ–°ã¨è»¢é€
	worldTransform_.UpdateMatrix();

	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}

}

void Object3d::Draw(ViewProjection* viewProjection)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(Object3d::cmdList);

	// ãƒ¢ãƒ‡ãƒ«ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (model == nullptr) return;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform_.GetBuff()->GetGPUVirtualAddress());

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›ãƒ‡ãƒ¼ã‚¿å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());

	// ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
	model->Draw(cmdList, 2,1);
}

void Object3d::Draw(ViewProjection* viewProjection,float alpha_)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);
	assert(Object3d::cmdList);
		
	// ãƒ¢ãƒ‡ãƒ«ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (model == nullptr) return;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, worldTransform_.GetBuff()->GetGPUVirtualAddress());

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›ãƒ‡ãƒ¼ã‚¿å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(1, viewProjection->GetBuff()->GetGPUVirtualAddress());

	// ãƒ¢ãƒ‡ãƒ«ã‚’æç”»
	model->Draw(cmdList, 2,alpha_);
}

void Object3d::SetCollider(BaseCollider* collider)
{
	collider->SetObject(this);
	this->collider = collider;
	//ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã«ç™»éŒ²
	CollisionManager::GetInstance()->AddCollider(collider);
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ›´æ–°ã—ã¦ãŠã
	collider->Update();
}

Vector3 Object3d::GetWorldPos() {
	Vector3 worldPos{ 0,0,0 };

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰åº§æ¨™ã‚’å–å¾—
	worldPos.x = worldTransform_.matWorld_.m[3][0];
	worldPos.y = worldTransform_.matWorld_.m[3][1];
	worldPos.z = worldTransform_.matWorld_.m[3][2];

	return worldPos;
}
</file_content>

<file_content path="engine/3d/Object3d.h">
#pragma once

#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include <d3dx12.h>
#include <string>
#include "WorldTransform.h"
#include "ViewProjection.h"
#include "Model.h"
#include "CollisionInfo.h"

class BaseCollider;

/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
class Object3d
{
private: // ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	/// é™çš„åˆæœŸåŒ–
	static void StaticInitialize(ID3D12Device* device, int window_width, int window_height);

	/// æç”»å‰å‡¦ç†
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);

	/// æç”»å¾Œå‡¦ç†
	static void PostDraw();

	/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	static Object3d* Create();

private: // é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ‡ãƒã‚¤ã‚¹
	static ID3D12Device* device;
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	static ID3D12GraphicsCommandList* cmdList;
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	static ComPtr<ID3D12RootSignature> rootsignature;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	static ComPtr<ID3D12PipelineState> pipelinestate;

private:// é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°

	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	static void InitializeGraphicsPipeline();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	//ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Object3d() = default;

	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~Object3d();

	//åˆæœŸåŒ–
	virtual bool Initialize();

	/// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†
	virtual void Update();

	/// æç”»
	void Draw(ViewProjection* viewProjection);
	void Draw(ViewProjection* viewProjection, float alpha_);

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®å–å¾—
	const Matrix4& GetMatWorld() { return matWorld; }

	// ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
	void SetModel(Model* model) { this->model = model; }

	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚»ãƒƒãƒˆ
	void SetCollider(BaseCollider* collider);

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	virtual void OnCollision(const CollisionInfo& info) {}
	virtual void OffCollision(const CollisionInfo& info) {}

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åº§æ¨™
	Vector3 GetWorldPos();
	const Vector3& GetPosition() const { return worldTransform_.position_; }
	bool GetIsLocked() { return isLocked; }
	void SetIsLocked(bool isLock) { isLocked = isLock; }
	const float& GetPositionZ() const { return worldTransform_.position_.z; }
	void SetPosition(const Vector3& position) { this->worldTransform_.position_ = position; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤§ãã•
	void SetScale(const Vector3& scale) { this->worldTransform_.scale_ = scale; }
	const Vector3& GetScale() const { return worldTransform_.scale_; }
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å›è»¢
	void SetRotation(const Vector3& rotation) { this->worldTransform_.rotation_ = rotation; }
	const Vector3& GetRotation() const { return worldTransform_.rotation_; }
	void SetRotationX(const float& rotation) { this->worldTransform_.rotation_.x = rotation; }
	void SetRotationY(const float& rotation) { this->worldTransform_.rotation_.y = rotation; }

	const char* GetName() const { return name; }
public:
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ãƒ‡ãƒ¼ã‚¿
	WorldTransform worldTransform_;
	const char* toCollisionName = nullptr;

protected: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	//ã‚¯ãƒ©ã‚¹å
	const char* name = nullptr;
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
	BaseCollider* collider = nullptr;
	// ãƒ¢ãƒ‡ãƒ«
	Model* model = nullptr;
	// ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›è¡Œåˆ—
	Matrix4 matWorld;
	//ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool isLocked;
};


</file_content>

<file_content path="engine/3d/Player.cpp">
#include "Player.h"
#include "string.h"
#include "RailCamera.h"
#include "SphereCollider.h"
#include"Input.h"

//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
Player::~Player() {
	delete playerModel;
}

//åˆæœŸåŒ–
bool Player::PlayerInitialize() {
	if (!Object3d::Initialize()) {
		return false;
	}

	input = Input::GetInstance();
	Initialize();

	// OBJã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	playerModel = Model::LoadFromOBJ("box");
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Create();
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ã²ã‚‚ä»˜ã‘ã‚‹
	SetModel(playerModel);
	SetPosition(Vector3(0, 0, 500));
	SetRotation(Vector3(0, 270, 0));

	hp = 100;
	coolTime = 0;
	len = 6.0f;
	pTimer = 0;
	isHit = false;
	isShooted = false;
	hitTime = 0;
	alpha = 1.0f;
	energy = 0;
	isUltimate = false;
	ultTime = 0;
	pos_ = { 0,0,0 };
	rot_ = { 0,0,0 };

	return true;
}

void Player::Update(Vector3 velo, std::vector<LockInfo>& info)
{
	if (isShooted == true) {
		isShooted = false;
	}


	Move();
	LockAttack(info);
	Attack(velo);
	//ULT
	if (energy >= 100) {
		if (input->TriggerKey(DIK_Q)) {
			if (isUltimate == false) {
				pos_ = GetPosition();
				rot_ = GetRotation();
				isUltimate = true;
			}
		}
	}
	for (std::unique_ptr<PlayerBullet>& bullet : bullets_) {
		if (bullet->GetIsHoming() == true) {
			bullet->HomingVec(GetWorldPos());
		}
		bullet->Update();
	}
	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°ã®ç«‹ã£ãŸæ•µã‚’å‰Šé™¤
	bullets_.remove_if([](std::unique_ptr < PlayerBullet>& bullets_) {
		return bullets_->IsDead();
		});

	if (isHit == true) {
		hitTime++;
		if (hitTime == 15) {
			hitTime = 0;
			isHit = false;
		}
	}

	worldTransform_.UpdateMatrix();
	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}
	if (alpha < 1.0f) {
		alpha += 0.01f;
	}
}

void Player::Move()
{
	move = { 0,0,0 };

	//playerç§»å‹•
	if (input->PushKey(DIK_W)) {
		if (input->PushKey(DIK_A) == true && input->PushKey(DIK_D) == false) {
			move = { -0.03f, 0.03f, 0 };
		}
		else if (input->PushKey(DIK_A) == false && input->PushKey(DIK_D) == true) {
			move = { 0.03f, 0.03f, 0 };
		}
		else {
			move = { 0, 0.04f, 0 };
		}
	}
	else if (input->PushKey(DIK_A)) {
		if (input->PushKey(DIK_S) == true && input->PushKey(DIK_W) == false) {
			move = { -0.03f, -0.03f, 0 };
		}
		else {
			move = { -0.04f, 0, 0 };
		}
	}
	else if (input->PushKey(DIK_D)) {
		if (input->PushKey(DIK_S) == true && input->PushKey(DIK_W) == false) {
			move = { 0.03f, -0.03f, 0 };
		}
		else {
			move = { 0.04f, 0, 0 };
		}
	}
	else if (input->PushKey(DIK_S)) {
		move = { 0, -0.04f, 0 };
	}

	Vector3 floating(0, 0, 0);
	//playerãµã‚ãµã‚
	if (pTimer < 75) {
		floating += Vector3(0, 0.005f, 0);
	}
	else if (pTimer < 150) {
		floating += Vector3(0, -0.005f, 0);
	}
	else {
		pTimer = 0;
	}

	Vector3 tmp = GetPosition() + move + floating;
	//
	if (abs(tmp.x) <= 3.0f) {
		if (tmp.y >= -1.5f && tmp.y <= 2.0f) {
			if (GetPosition().z < -1.6f) {
				SetPosition(GetPosition() + move + floating + Vector3(0.0f,0.0f,0.05f));
			}
			else {
				SetPosition(GetPosition() + move + floating);
			}
		}
	}
	else {
		move = { 0,0,0 };
	}
	pTimer++;
}

void Player::Attack(Vector3 velo) {
	
	if (Input::GetInstance()->PushMouseLeft()) {
		if (coolTime == 0) {
			//å¼¾ã‚’ç”Ÿæˆã—åˆæœŸåŒ–
		//è¤‡æ•°
			std::unique_ptr<PlayerBullet> newBullet = std::make_unique<PlayerBullet>();

			//å˜ç™º
			newBullet->BulletInitialize(velo + Vector3(0,0.05f,0));
			newBullet->SetCollider(new SphereCollider());

			//å¼¾ã®ç™»éŒ²
		   //è¤‡æ•°
			newBullet->SetPosition(GetWorldPos());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			bullets_.push_back(std::move(newBullet));


			//ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã‚’è¨­å®š
			coolTime = 6;
		}
		else if (coolTime > 0) {
			coolTime--;
		}

	}
}

void Player::LockAttack(std::vector<LockInfo>& info)
{
	if (Input::GetInstance()->TriggerMouseRight() == true) {
		for (int i = 0; i < info.size(); i++) {
			//å¼¾ã‚’ç”Ÿæˆã—åˆæœŸåŒ–
			std::unique_ptr<PlayerBullet> newBullet = std::make_unique<PlayerBullet>();
			Vector3 shotVec = (info[i].vec - GetWorldPos());
			//å˜ç™º
			newBullet->BulletInitialize(shotVec);
			newBullet->SetCollider(new SphereCollider());

			//å¼¾ã®ç™»éŒ²
		   //è¤‡æ•°
			newBullet->SetPosition(GetWorldPos());
			newBullet->SetScale({ 0.3f,0.3f,0.3f });
			newBullet->SetLock(info[i].obj);
			newBullet->SetisHoming(true);
			bullets_.push_back(std::move(newBullet));
		}
		isShooted = true;
	}
}

void Player::Ultimate()
{
	if (ultTime > 50 && ultTime < 175) {
		SetPosition(GetPosition() + Vector3(0.0f, 0.05f, 0.0f));
	}
	else if (ultTime == 175) {
		ultTime = 0;
		isUltimate = false;
		energy = 0;
	}
	worldTransform_.UpdateMatrix();
	ultTime++;
}

void Player::PlayerDraw(ViewProjection* viewProjection_) {
	if (hitTime % 5 == 0) {
		Draw(viewProjection_,alpha);
	}
	//å¼¾æç”»
	for (std::unique_ptr<PlayerBullet>& bullet : bullets_) {
		bullet->Draw(viewProjection_);
	}
}

void Player::BackRail()
{
	SetPosition(pos_);
	SetRotation(rot_);
}

void Player::OnCollision(const CollisionInfo& info)
{
	//è¡çªç›¸æ‰‹ã®åå‰
	const char* str1 = "class Enemy";
	const char* str2 = "class EnemyBullet";
	const char* str3 = "class BossBullet";
	const char* str4 = "class Energy";

	//ç›¸æ‰‹ãŒenemy
	if (strcmp(toCollisionName, str1) == 0) {
	}
	//ç›¸æ‰‹ãŒenemyã®å¼¾
	if (strcmp(toCollisionName, str2) == 0) {
		if (isHit == false) {
			hp-=10;
			isHit = true;
		}
	}
	//ç›¸æ‰‹ãŒbossã®å¼¾
	if (strcmp(toCollisionName, str3) == 0) {
		if (isHit == false) {
			hp-=25;
			isHit = true;
		}
	}

	//ç›¸æ‰‹ãŒenergy
	if (strcmp(toCollisionName, str4) == 0) {
		if (energy < 100) {
			energy += 5;
		}
	}
}
</file_content>

<file_content path="engine/3d/Player.h">
#pragma once
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "input.h"
#include "Spline.h"
#include "Model.h"
#include "Particle.h"
#include "PlayerBullet.h"

struct LockInfo {
	Vector3 vec = {0,0,0};
	 Object3d* obj = nullptr;
};

class Player : public Object3d
{
public:
	//ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Player();
	//åˆæœŸåŒ–
	bool PlayerInitialize();

	void Update(Vector3 velo, std::vector<LockInfo>& info);

	void Move();
	///</summary>
	void Attack(Vector3 velo);
	void LockAttack(std::vector<LockInfo>& info);
	void Ultimate();
	void PlayerDraw(ViewProjection* viewProjection_);
	void BackRail();

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void OnCollision(const CollisionInfo& info) override;


	/////getter/////
	//hp
	float GetHP() { return hp; }
	float GetEnergy() { return energy; }
	bool GetIsHit() { return isHit; }
	bool GetIsShooted() { return isShooted; }
	float GetLen() { return len; }
	bool GetIsUltimate() { return isUltimate; }
	Vector3 GetMove() { return move; }
	//setter
	void SetIsHit(bool isHit_) { isHit = isHit_; }
	void SetAlpha(float a) { alpha = a; }
	void SetIsUltimate(bool ult) { isUltimate = ult; }

	//å¼¾ãƒªã‚¹ãƒˆã‚’å–å¾—
	const std::list<std::unique_ptr<PlayerBullet>>& GetBullets() { return bullets_; }


private:
	Input* input = nullptr;
	// ãƒ¢ãƒ‡ãƒ«
	Model* playerModel = nullptr;
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	Particle* particle = nullptr;
	//å¼¾ 
	std::list<std::unique_ptr<PlayerBullet>> bullets_;
	//HP
	float hp;
	int coolTime = 0;
	float len = 6;
	int pTimer = 0;
	bool isHit;
	bool isShooted;
	int hitTime;
	float alpha;
	float energy;
	bool isUltimate;
	int ultTime;
	Vector3 pos_;
	Vector3 rot_;
	Vector3 move;
};

</file_content>

<file_content path="engine/3d/PlayerBullet.cpp">
#include "PlayerBullet.h"
#include "BaseCollider.h"

void PlayerBullet::BulletInitialize(const Vector3& velocity) {

	Initialize();

	// OBJã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	bulletModel = Model::LoadFromOBJ("triangle_mat");
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Create();
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ã²ã‚‚ä»˜ã‘ã‚‹
	SetModel(bulletModel);

	//å¼•æ•°ã§å—ã‘å–ã£ãŸé€Ÿåº¦ã‚’ãƒ¡ãƒ³ãƒå¤‰æ•°ã«ä»£å…¥
	velocity_ = velocity;
}

void PlayerBullet::Update() {

	SetPosition(GetPosition() + velocity_);

	worldTransform_.UpdateMatrix();

	//å½“ãŸã‚Šåˆ¤å®šæ›´æ–°
	if (collider)
	{
		collider->Update();
	}
	//æ™‚é–“çµŒéã§ãƒ‡ã‚¹
	if (--deathTimer_ <= 0) {
		isDead_ = true;
	}

}

void PlayerBullet::HomingVec(Vector3 pos)
{
	if (isHoming == true) {
		velocity_ = lockObj->GetWorldPos() - GetPosition();
		velocity_ = velocity_ * 0.25f;
	}
}

void PlayerBullet::OnCollision(const CollisionInfo& info)
{
	//è¡çªç›¸æ‰‹ã®åå‰
	const char* str1 = "class Enemy";
	const char* str2 = "class EnemyBullet";
	const char* str3 = "class Boss";
	const char* str4 = "class BossBullet";

	//ç›¸æ‰‹ãŒenemy
	if (strcmp(toCollisionName, str1) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

	//ç›¸æ‰‹ãŒenemyã®å¼¾
	if (strcmp(toCollisionName, str2) == 0) {
		if (isDead_ == false && isHoming == false) {
			isDead_ = true;
		}
	}
	//ç›¸æ‰‹ãŒãƒœã‚¹
	if (strcmp(toCollisionName, str3) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

	//ç›¸æ‰‹ãŒãƒœã‚¹ã®å¼¾
	if (strcmp(toCollisionName, str4) == 0) {
		if (isDead_ == false) {
			isDead_ = true;
		}
	}

}
</file_content>

<file_content path="engine/3d/PlayerBullet.h">
#pragma once
#include "Vector3.h"
#include <Model.h>
#include "ViewProjection.h"
#include <Model.h>
#include <WorldTransform.h>
#include <cassert>
#include "Object3d.h"

class PlayerBullet : public Object3d 
{
  public:
	///< summary>
	///åˆæœŸåŒ–
	///</summary>
	void BulletInitialize(const Vector3& velocity);

	///< summary>
	///åˆæœŸåŒ–
	///</summary>
	void Update();
	void HomingVec(Vector3 pos);


	//è¡çªã‚’æ¤œå‡ºã—ãŸã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	void OnCollision(const CollisionInfo& info) override;


  public:
	bool IsDead() const { return isDead_; }
	WorldTransform* GetWorldTransForm() { return &worldTransform_; }
	bool GetIsHoming() { return isHoming; }
	void SetisHoming(bool isHoming_) { isHoming = isHoming_; }
	void SetLock(Object3d* obj) { lockObj = obj; }

  private:
	//ãƒ¢ãƒ‡ãƒ«
	Model* bulletModel = nullptr;
	
	//é€Ÿåº¦
	Vector3 velocity_;
	
	//å¯¿å‘½
	static const int32_t kLifeTime = 60 * 8;
	//ãƒ‡ã‚¹ã‚¿ã‚¤ãƒãƒ¼
	int32_t deathTimer_ = kLifeTime;
	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°
	bool isDead_ = false;
	bool isHoming = false;
	Object3d* lockObj = nullptr;
};

</file_content>

<file_content path="engine/3d/RailCamera.cpp">
#include "RailCamera.h"

RailCamera::RailCamera() {
	isEnd = false;
}

RailCamera::~RailCamera() {
	delete viewProjection;
	delete camera;
}

//åˆæœŸåŒ–
void RailCamera::Initialize(Player* player_) {
	viewProjection = new ViewProjection;
	input = Input::GetInstance();
	viewProjection->Initialize();
	camera = Object3d::Create();
	viewProjection->eye = { 0, 1, 505 };
	viewProjection->target = { 0.3f,0.5f,499 };
	camera->SetPosition({0,0,500});
	camera->SetRotation(Vector3(0, 0, 0));
	SetPlayer(player_);
	oldCamera = { 0,0,0 };
	isEnd = false;
	OnRail = true;
	playerMoveVel = { 0,0,0 };
	cameraDelay = { 0,0,0 };
}

void RailCamera::ViewUpdate() {
	viewProjection->UpdateMatrix();
}

//æ›´æ–°
void RailCamera::Update(Player* player_, std::vector<Vector3>& point) {

	if (OnRail == true) {
		Vector3 target_ = spline_.Update(point, 0.00001f);
		camera->SetPosition(splineCam.Update(point, 0.0f));
		//æœ€åˆã®1ãƒ«ãƒ¼ãƒ—ã®ã¿ç¾åœ¨ä½ç½®ã‚’å…¥ã‚Œã‚‹
		if (oldCamera.x == 0 && oldCamera.y == 0 && oldCamera.z == 0) {
			oldCamera = camera->GetPosition();
		}

		//æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã®å–å¾—
		GetVec(camera->GetPosition(), target_);

		//ã‚«ãƒ¡ãƒ©æ–¹å‘ã«åˆã‚ã›ã¦Yè»¸ã®å›è»¢
		float radY = std::atan2(frontVec.x, frontVec.z);
		camera->SetRotationY(radY * 180.0f / 3.1415f);
		//ã‚«ãƒ¡ãƒ©æ–¹å‘ã«åˆã‚ã›ã¦Xè»¸ã®å›è»¢
		Vector3 rotaVec = { frontVec.x,0,frontVec.z };
		float length = rotaVec.length();
		float radX = std::atan2(-frontVec.y, length);
		camera->SetRotationX(radX * 180.0f / 3.1415f);

		if (spline_.GetIsEnd() == true) {
			OnRail = false;
		}
		Vector3 eyeTmp = camera->GetPosition() - frontVec * player_->GetLen();

		//æ›´æ–°
		camera->Update();
		viewProjection->target = ((target_ + frontVec));
		//playerã®ç§»å‹•ã‚’ã‚‚ã¨ã«ãƒ‡ã‚£ãƒ¬ã‚¤ã‚’ã‹ã‘ã¦æ›´æ–°
		viewProjection->eye = ((camera->GetPosition() + cameraDelay) - frontVec * player_->GetLen());
		if (viewProjection->eye.y > (eyeTmp.y + 1)) {
			viewProjection->eye.y += 0.05f;
		}

		viewProjection->UpdateMatrix();
		oldCamera = camera->GetPosition();
	}
	else {
		viewProjection->UpdateMatrix();
		camera->Update();
	}
	//cameraDelay
	playerMoveVel += (player_->GetMove() *= Vector3(1,-1,1));
	//
	if (playerMoveVel.x > 2.0f) {
		playerMoveVel.x = 2.0f;
	}
	else if (playerMoveVel.x < -2.0f) {
		playerMoveVel.x = -2.0f;
	}
	if (playerMoveVel.y > 1.2f) {
		playerMoveVel.y = 1.2f;
	}
	else if (playerMoveVel.y < -1.2f) {
		playerMoveVel.y = -1.2f;
	}
	//
	if (abs((playerMoveVel.x - cameraDelay.x)) > abs(0.05f)) {
		if (playerMoveVel.x > cameraDelay.x) {
			cameraDelay.x += 0.02f;
		}
		else if (playerMoveVel.x < cameraDelay.x) {
			cameraDelay.x += -0.02f;
		}
		else{}
	}
	if (abs((playerMoveVel.y - cameraDelay.y)) > abs(0.05f)) {
		if (playerMoveVel.y > cameraDelay.y) {
			cameraDelay.y += 0.02f;
		}
		else if (playerMoveVel.y < cameraDelay.y) {
			cameraDelay.y += -0.02f;
		}
		else {}
	}

}

void RailCamera::TitleR(Player* player_)
{
	viewProjection->eye.z -= 1.5;
}

void RailCamera::RailReset()
{
	splineCam.Reset();
	spline_.Reset();
}

////////////////////--------ã‚¯ãƒ©ã‚¹å†…ä¾¿åˆ©é–¢æ•°--------///////////////////////

//æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’å–å¾—
void RailCamera::GetVec(Vector3 a, Vector3 b) {
	Vector3 yTmpVec = { 0, 1, 0 };
	Vector3 frontTmp = { 0, 0, 0 };
	Vector3 a_ = { a.x,a.y,a.z };
	Vector3 b_ = { b.x,b.y,b.z };

	//Yè»¸ä»®ãƒ™ã‚¯ãƒˆãƒ«
	yTmpVec.normalize();
	//æ­£é¢ä»®ãƒ™ã‚¯ãƒˆãƒ«
	frontTmp = b_ - a_;
	frontTmp.normalize();
	//å³ãƒ™ã‚¯ãƒˆãƒ«
	rightVec = yTmpVec.cross(frontTmp);
	rightVec.normalize();
	//å·¦ãƒ™ã‚¯ãƒˆãƒ«
	leftVec = frontTmp.cross(yTmpVec);
	leftVec.normalize();
	//æ­£é¢ãƒ™ã‚¯ãƒˆãƒ«(Yåº§æ¨™ã‚’0ã«ã—ãŸ)
	frontVec = rightVec.cross(yTmpVec);
	frontVec.normalize();
}

void RailCamera::SetPlayer(Player* player_) {
	//è¦ªå­æ§‹é€ ã®ã‚»ãƒƒãƒˆ
	player_->worldTransform_.SetParent3d(&camera->worldTransform_);
	//æ‹¡å¤§å›è»¢åº§æ¨™å¤‰æ›
	player_->SetPosition(Vector3(0, 0, -1.5f));
	player_->SetScale(Vector3(0.3f, 0.3f, 0.3f));
}

void RailCamera::SetEye(Vector3 view) {
	this->viewProjection->eye = view;
	viewProjection->UpdateMatrix();
}

void RailCamera::SetTarget(Vector3 target_)
{
	this->viewProjection->target = target_;
	viewProjection->UpdateMatrix();
}

void RailCamera::ShakeCamera(float x, float y) {

	//ä¹±æ•°ç”Ÿæˆè£…ç½®
	std::random_device seed_gen;
	std::mt19937_64 engine(seed_gen());
	std::uniform_real_distribution<float>dist(x, y);
	std::uniform_real_distribution<float>dist2(x, y);


	viewProjection->eye = viewProjection->eye + Vector3(dist(engine), dist2(engine), dist2(engine));
	viewProjection->UpdateMatrix();
}
</file_content>

<file_content path="engine/3d/RailCamera.h">
#pragma once
#include "ViewProjection.h"
#include "Object3d.h"
#include "WinApp.h"
#include "Vector3.h"
#include "input.h"
#include "Spline.h"
#include "Player.h"

class RailCamera {
public:
	//ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	RailCamera();
	~RailCamera();
	//åˆæœŸåŒ–
	void Initialize(Player* player_);
	//æ›´æ–°
	void Update(Player* player_, std::vector<Vector3>& point);
	void ViewUpdate();

	void ShakeCamera(float x, float y);

	void TitleR(Player* player_);
	void RailReset();

	//Setter
	void SetPlayer(Player* player_);
	void SetEye(Vector3 view);
	void SetTarget(Vector3 target_);
	void SetOnRail(bool onrail) { OnRail = onrail; }

	//ãƒ™ã‚¯ãƒˆãƒ«ã‚’å–å¾—
	void GetVec(Vector3 a, Vector3 b);

	//Getter
	ViewProjection* GetView() { return viewProjection; }
	bool GetIsEnd() { return isEnd; }
	bool GetOnRail() { return OnRail; }
	Vector3 GetFrontVec() { return frontVec; }
	Object3d* GetCamera() { return camera; }
	Vector3 GetCameraPos() { return camera->worldTransform_.position_; }
	float GetPasPoint() { return splineCam.GetT(); }
private:
	Input* input_ = nullptr;
	ViewProjection* viewProjection = nullptr;
	Object3d* camera = nullptr;
	Input* input = nullptr;

	//ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³
	Spline spline_;
	Spline splineCam;

	Vector3 rightVec = { 0, 0, 0 };
	Vector3 leftVec = { 0, 0, 0 };
	Vector3 frontVec = { 0,0,0 };
	Vector3 oldCamera = { 0,0,0 };

	//ã‚«ãƒ¡ãƒ©ãƒ‡ã‚£ãƒ¬ã‚¤
	Vector3 playerMoveVel;
	Vector3 cameraDelay;

	//tmp
	Vector3 eyeTmp{};
	Vector3 targetTmp{};

	bool isEnd;
	bool OnRail;
};


</file_content>

<file_content path="engine/3d/ViewProjection.cpp">
#include "ViewProjection.h"
#include <d3dx12.h>
#include <cassert>
#include "WinApp.h"

Microsoft::WRL::ComPtr<ID3D12Device> ViewProjection::device_ = nullptr;

void ViewProjection::StaticInitialize(ID3D12Device* device)
{
	assert(device);
	device_ = device;
}

void ViewProjection::Initialize()
{
	CreateConstBuffer();
	Map();
	UpdateMatrix();
}

void ViewProjection::SetEye(Vector3 eye_)
{
	eye = eye_;
	UpdateMatrix();
}

void ViewProjection::SetTarget(Vector3 target_)
{
	target = target_;
	UpdateMatrix();
}

void ViewProjection::CreateConstBuffer()
{
	HRESULT result;

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataViewProjection) + 0xff) & ~0xff);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device_->CreateCommittedResource(
		&heapProps, // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¯èƒ½
		D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));
}

void ViewProjection::Map()
{
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã¨ã®ãƒ‡ãƒ¼ã‚¿ãƒªãƒ³ã‚¯
	HRESULT result = constBuff->Map(0, nullptr, (void**)&constMap);
	assert(SUCCEEDED(result));
}

void ViewProjection::UpdateMatrix()
{
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®ä½œæˆ
	matView.ViewMat(eye, target, up);
	// å°„å½±è¡Œåˆ—ã®ä½œæˆ
	matProjection.ProjectionMat(fovAngleY, aspectRatio, nearZ, farZ);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã¸ã®æ›¸ãè¾¼ã¿
	constMap->view = matView;
	constMap->projection = matProjection;
	constMap->cameraPos = eye;
}
</file_content>

<file_content path="engine/3d/ViewProjection.h">
#pragma once
#include"Vector3.h"
#include "Vector4.h"
#include"Matrix4.h"
#include "WinApp.h"
#include<d3d12.h>
#include<wrl.h>

class ViewProjection
{
public:// ã‚µãƒ–ã‚¯ãƒ©ã‚¹
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
	struct ConstBufferDataViewProjection {
		Matrix4 view;       // ãƒ¯ãƒ¼ãƒ«ãƒ‰ â†’ ãƒ“ãƒ¥ãƒ¼å¤‰æ›è¡Œåˆ—
		Matrix4 projection; // ãƒ“ãƒ¥ãƒ¼ â†’ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤‰æ›è¡Œåˆ—
		Vector3 cameraPos;  // ã‚«ãƒ¡ãƒ©åº§æ¨™ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰
	};
public:// ãƒ¡ãƒ³ãƒé–¢æ•°
	// é™çš„åˆæœŸåŒ–
	static void StaticInitialize(ID3D12Device* device);

	/// åˆæœŸåŒ–
	void Initialize();

	void SetEye(Vector3 eye_);
	Vector3 GetEye() { return eye; }
	void SetTarget(Vector3 terget_);
	Vector3 GetTarget() { return target; }
	Matrix4 GetMatView() { return matView; }
	Matrix4 GetMatProjection() { return matProjection; }


	/// è¡Œåˆ—ã‚’æ›´æ–°ã™ã‚‹
	void UpdateMatrix();

	// ãƒãƒƒãƒ•ã‚¡ã®ã‚²ãƒƒã‚¿ãƒ¼
	ID3D12Resource* GetBuff() { return constBuff.Get(); }


private:// ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆé–¢æ•°
	// å††å‘¨ç‡
	const float PI = 3.141592f;

	/// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	void CreateConstBuffer();

	/// ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹
	void Map();

	// åº¦æ•°ã‹ã‚‰ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›
	float ToRadian(float angle) { return angle * (PI / 180); }


public:// ãƒ‘ãƒ–ãƒªãƒƒã‚¯å¤‰æ•°
#pragma region ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®è¨­å®š
	// è¦–ç‚¹åº§æ¨™
	Vector3 eye = { 0, 5, -10.0f };
	// æ³¨è¦–ç‚¹åº§æ¨™
	Vector3 target = { 0, 0, 0 };
	// ä¸Šæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
	Vector3 up = { 0, 1, 0 };
#pragma endregion

#pragma region å°„å½±è¡Œåˆ—ã®è¨­å®š
	// å‚ç›´æ–¹å‘è¦–é‡è§’
	float fovAngleY = ToRadian(45.0f);
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	// æ·±åº¦é™ç•Œï¼ˆæ‰‹å‰å´ï¼‰
	float nearZ = 0.1f;
	// æ·±åº¦é™ç•Œï¼ˆå¥¥å´ï¼‰
	float farZ = 1000.0f;
#pragma endregion

	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—
	Matrix4 matView;
	// å°„å½±è¡Œåˆ—
	Matrix4 matProjection;

private:// ãƒ¡ãƒ³ãƒå¤‰æ•°

	// ãƒ‡ãƒã‚¤ã‚¹ï¼ˆå€Ÿã‚Šã¦ãã‚‹ï¼‰
	static Microsoft::WRL::ComPtr<ID3D12Device> device_;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
	Microsoft::WRL::ComPtr<ID3D12Resource> constBuff;

	// ãƒãƒƒãƒ”ãƒ³ã‚°æ¸ˆã¿ã‚¢ãƒ‰ãƒ¬ã‚¹
	ConstBufferDataViewProjection* constMap = nullptr;

};


</file_content>

<file_content path="engine/3d/WorldTransform.cpp">
#include "WorldTransform.h"
#include<cassert>
#include <d3dx12.h>

Microsoft::WRL::ComPtr<ID3D12Device> WorldTransform::device_ = nullptr;

void WorldTransform::StaticInitialize(ID3D12Device* device)
{
	assert(device);
	device_ = device;
}

void WorldTransform::Initialize()
{
	CreateConstBuffer();
	Map();
	UpdateMatrix();
}

void WorldTransform::CreateConstBuffer()
{
	assert(device_);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferDataB0) + 0xff) & ~0xff);

	HRESULT result;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device_->CreateCommittedResource(
		&heapProps, // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¯èƒ½
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuffB0));

	assert(SUCCEEDED(result));
}

void WorldTransform::Map()
{
	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ãƒãƒƒãƒ”ãƒ³ã‚°
	HRESULT result = constBuffB0->Map(0, nullptr, (void**)&constMap);//ãƒãƒƒãƒ”ãƒ³ã‚°
	assert(SUCCEEDED(result));
}

void WorldTransform::UpdateMatrix()
{

	Matrix4 matScale, matRot, matTrans;
	Matrix4 matRotX, matRotY, matRotZ;

	//å„è¡Œåˆ—è¨ˆç®—
	matScale = Matrix4::identity();
	matScale.scale(scale_);
	matRot = Matrix4::identity();
	matRot *= matRotZ.rotateZ(ToRadian(rotation_.z));
	matRot *= matRotX.rotateX(ToRadian(rotation_.x));
	matRot *= matRotY.rotateY(ToRadian(rotation_.y));
	matTrans = Matrix4::identity();
	matTrans.translate(position_);

	//ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®åˆæˆ
	matWorld_ = Matrix4::identity();
	matWorld_ *= matScale;
	matWorld_ *= matRot;
	matWorld_ *= matTrans;

	//è¦ªå­æ§‹é€ 
	if (parent_ != nullptr) 
	{
		matWorld_ *= parent_->matWorld_;
	}

	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«è»¢é€
	constMap->matWorld = matWorld_;
}

</file_content>

<file_content path="engine/3d/WorldTransform.h">
#pragma once
#include"Vector3.h"
#include "Vector4.h"
#include"Matrix4.h"
#include<d3d12.h>
#include<wrl.h>

class WorldTransform
{
private:
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;


public:// ã‚µãƒ–ã‚¯ãƒ©ã‚¹
	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
	struct ConstBufferDataB0 {
		Matrix4 matWorld;// è¡Œåˆ—
	};
public:// ãƒ¡ãƒ³ãƒé–¢æ•°
	// é™çš„åˆæœŸåŒ–
	static void StaticInitialize(ID3D12Device* device);

	/// åˆæœŸåŒ–
	void Initialize();

	/// è¡Œåˆ—ã‚’æ›´æ–°ã™ã‚‹
	void UpdateMatrix();

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ã‚²ãƒƒã‚¿ãƒ¼
	ID3D12Resource* GetBuff() { return constBuffB0.Get(); }

	/// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	void CreateConstBuffer();

	/// ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹
	void Map();

	const Vector3& GetPosition()const { return position_; }

	// åº¦æ•°ã‹ã‚‰ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›
	float ToRadian(float angle) { return angle * (PI / 180); }

	void SetParent3d(WorldTransform* parent) { this->parent_ = parent; }

public:// ãƒ‘ãƒ–ãƒªãƒƒã‚¯å¤‰æ•°
	// ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚±ãƒ¼ãƒ«
	Vector3 scale_ = { 1.0f, 1.0f, 1.0f };

	// X,Y,Zè»¸å›ã‚Šã®ãƒ­ãƒ¼ã‚«ãƒ«å›è»¢è§’
	Vector3 rotation_ = { 0, 0, 0 };

	// ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™
	Vector3 position_ = { 0, 0, 0 };

	// è‰²
	Vector4 color_ = { 1,1,1,1 };

	// ãƒ­ãƒ¼ã‚«ãƒ« â†’ ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›è¡Œåˆ—
	Matrix4 matWorld_;

	// è¦ªã¨ãªã‚‹ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	const WorldTransform* parent_ = nullptr;

	// å††å‘¨ç‡
	const float PI = 3.141592f;

private:// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ‡ãƒã‚¤ã‚¹
	static ComPtr<ID3D12Device> device_;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> constBuffB0;

	// ãƒãƒƒãƒ”ãƒ³ã‚°æ¸ˆã¿ã‚¢ãƒ‰ãƒ¬ã‚¹
	ConstBufferDataB0* constMap = nullptr;
};


</file_content>

<file_content path="engine/3d/XMViewProjection.cpp">
#include "XMViewProjection.h"
#include "WinApp.h"

using namespace DirectX;
XMViewProjection::XMViewProjection()
{
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®ç”Ÿæˆ
	UpdateViewMatrix();

	// é€è¦–æŠ•å½±ã«ã‚ˆã‚‹å°„å½±è¡Œåˆ—ã®ç”Ÿæˆ
	UpdateProjectionMatrix();

	matViewProjection_ = matView_ * matProjection_;

}

XMViewProjection::~XMViewProjection()
{
}

void XMViewProjection::Update()
{
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®ç”Ÿæˆ
	UpdateViewMatrix();

	// é€è¦–æŠ•å½±ã«ã‚ˆã‚‹å°„å½±è¡Œåˆ—ã®ç”Ÿæˆ
	UpdateProjectionMatrix();

	matViewProjection_ = matView_ * matProjection_;
}

void XMViewProjection::UpdateViewMatrix()
{
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®æ›´æ–°
	matView_ = XMMatrixLookAtLH(XMLoadFloat3(&eye_), XMLoadFloat3(&target_), XMLoadFloat3(&up_));
	//è¦–ç‚¹åº§æ¨™
	XMVECTOR eyePosition = XMLoadFloat3(&eye_);
	//æ³¨è¦–ç‚¹åº§æ¨™
	XMVECTOR targetPosition = XMLoadFloat3(&target_);
	//(ä»®ã®)ä¸Šæ–¹å‘
	XMVECTOR upVector = XMLoadFloat3(&up_);

	//ã‚«ãƒ¡ãƒ©Zè»¸(è¦–ç·šæ–¹å‘)
	XMVECTOR cameraAxisZ = XMVectorSubtract(targetPosition, eyePosition);
	//0ãƒ™ã‚¯ãƒˆãƒ«ã ã¨å‘ããŒå®šã¾ã‚‰ãªã„ã®ã§é™¤å¤–
	assert(!XMVector3Equal(cameraAxisZ, XMVectorZero()));
	assert(!XMVector3IsInfinite(cameraAxisZ));
	assert(!XMVector3Equal(upVector, XMVectorZero()));
	assert(!XMVector3IsInfinite(upVector));

	//ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ­£è¦åŒ–
	cameraAxisZ = XMVector3Normalize(cameraAxisZ);

	//ã‚«ãƒ¡ãƒ©ã®Xè»¸(å³æ–¹å‘)
	XMVECTOR cameraAxisX;
	//Xè»¸ã¯ä¸Šæ–¹å‘â†’Zè»¸ã®å¤–ç©ã§æ±ºã¾ã‚‹
	cameraAxisX = XMVector3Cross(upVector, cameraAxisZ);
	//ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ­£è¦åŒ–
	cameraAxisX = XMVector3Normalize(cameraAxisX);

	//ã‚«ãƒ¡ãƒ©ã®Yè»¸(ä¸Šæ–¹å‘)
	XMVECTOR cameraAxisY;
	//Yè»¸ã¯Zè»¸â†’Xè»¸ã®å¤–ç©ã§æ±ºã¾ã‚‹
	cameraAxisY = XMVector3Cross(cameraAxisZ, cameraAxisX);

	//ã‚«ãƒ¡ãƒ©å›è»¢è¡Œåˆ—
	XMMATRIX matCameraRot;
	//ã‚«ãƒ¡ãƒ©åº§æ¨™ç³»â†’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã®å¤‰æ›è¡Œåˆ—
	matCameraRot.r[0] = cameraAxisX;
	matCameraRot.r[1] = cameraAxisY;
	matCameraRot.r[2] = cameraAxisZ;
	matCameraRot.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);

	//è»¢ç½®ã«ã‚ˆã‚Šé€†è¡Œåˆ—(é€†å›è»¢)ã‚’è¨ˆç®—
	matView_ = XMMatrixTranspose(matCameraRot);

	//è¦–ç‚¹åº§æ¨™ã«-1ã‚’æ›ã‘ãŸåº§æ¨™
	XMVECTOR reverseEyePosition = XMVectorNegate(eyePosition);
	//ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‹ã‚‰ãƒ¯ãƒ¼ãƒ«ãƒ‰è¦–ç‚¹ã¸ã®ãƒ™ã‚¯ãƒˆãƒ«(ã‚«ãƒ¡ãƒ©åº§æ¨™ç³»)
	XMVECTOR tX = XMVector3Dot(cameraAxisX, reverseEyePosition);	//Xæˆåˆ†
	XMVECTOR tY = XMVector3Dot(cameraAxisY, reverseEyePosition);	//Yæˆåˆ†
	XMVECTOR tZ = XMVector3Dot(cameraAxisZ, reverseEyePosition);	//Zæˆåˆ†
	//ä¸€ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ã«ã¾ã¨ã‚ã‚‹
	XMVECTOR translation = XMVectorSet(tX.m128_f32[0], tY.m128_f32[1], tZ.m128_f32[2], 1.0f);

	//ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã«å¹³è¡Œç§»å‹•æˆåˆ†ã‚’è¨­å®š
	matView_.r[3] = translation;

#pragma region å…¨æ–¹å‘ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—ã®è¨ˆç®—
	//ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	matBillboard_.r[0] = cameraAxisX;
	matBillboard_.r[1] = cameraAxisY;
	matBillboard_.r[2] = cameraAxisZ;
	matBillboard_.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);
#pragma endregion

#pragma region Yè»¸å›ã‚Šãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—ã®è¨ˆç®—
	//ã‚«ãƒ¡ãƒ©X,Y,Zè»¸
	XMVECTOR yBillCameraAxisX, yBillCameraAxisY, yBillCameraAxisZ;

	//Xè»¸ã¯å…±é€š
	yBillCameraAxisX = cameraAxisX;
	//Yè»¸ã¯ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã®Yè»¸
	yBillCameraAxisY = XMVector3Normalize(upVector);
	//Zè»¸ã¯Xè»¸â†’Yè»¸ã®å¤–ç©ã§æ±ºã¾ã‚‹
	yBillCameraAxisZ = XMVector3Cross(yBillCameraAxisX, yBillCameraAxisY);

	//Yè»¸å›ã‚Šãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	matBillboardY_.r[0] = yBillCameraAxisX;
	matBillboardY_.r[1] = yBillCameraAxisY;
	matBillboardY_.r[2] = yBillCameraAxisZ;
	matBillboardY_.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);

#pragma endregion

}
void XMViewProjection::UpdateProjectionMatrix()
{
	matProjection_ = XMMatrixPerspectiveFovLH(
		XMConvertToRadians(45.0f),
		(float)WinApp::window_width / WinApp::window_height,
		0.1f, 1000.0f
	);
}
void XMViewProjection::CameraMoveVector(const XMFLOAT3& move)
{
	XMFLOAT3 eye_moved = eye_;
	XMFLOAT3 target_moved = target_;

	eye_moved.x += move.x;
	eye_moved.y += move.y;
	eye_moved.z += move.z;

	target_moved.x += move.x;
	target_moved.y += move.y;
	target_moved.z += move.z;

	SetEye(eye_moved);
	SetTarget(target_moved);
}

void XMViewProjection::CameraMoveVectorEye(const XMFLOAT3& move)
{
	XMFLOAT3 eye_moved = eye_;

	eye_moved.x += move.x;
	eye_moved.y += move.y;
	eye_moved.z += move.z;

	SetEye(eye_moved);
}



void XMViewProjection::SetEye(const XMFLOAT3& eye)
{
	this->eye_ = eye;
}

void XMViewProjection::SetTarget(const XMFLOAT3& target) {
	this->target_ = target;
}

void XMViewProjection::SetUp(const XMFLOAT3& up)
{
	this->up_ = up;
}
</file_content>

<file_content path="engine/3d/XMViewProjection.h">
#pragma once
#include <DirectXMath.h>
#include <wrl.h>

class XMViewProjection
{
private:
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::ã‚’çœç•¥
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMMATRIX = DirectX::XMMATRIX;
public:
	XMViewProjection();
	~XMViewProjection();
	//æ›´æ–°
	void Update();
	//ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—æ›´æ–°
	void UpdateViewMatrix();
	//ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—æ›´æ–°
	void UpdateProjectionMatrix();
	//ã‚«ãƒ¡ãƒ©ç§»å‹•
	void CameraMoveVector(const XMFLOAT3& move);
	//ã‚«ãƒ¡ãƒ©è¦–ç‚¹ç§»å‹•
	void CameraMoveVectorEye(const XMFLOAT3& move);

protected:
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—
	XMMATRIX matView_ = {};
	// å°„å½±è¡Œåˆ—
	XMMATRIX matProjection_ = {};

	XMMATRIX matViewProjection_ = {};

	// ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	XMMATRIX matBillboard_ = {};
	// Yè»¸å›ã‚Šãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	XMMATRIX matBillboardY_ = {};
	// è¦–ç‚¹åº§æ¨™
	XMFLOAT3 eye_ = { 0.0f, 0.0f, -100.0f };
	// æ³¨è¦–ç‚¹åº§æ¨™
	XMFLOAT3 target_ = { 0.0f,0.0f,0.0f };
	// ä¸Šæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
	XMFLOAT3 up_ = { 0.0f,1.0f,0.0f };

public://ã‚¢ã‚¯ã‚»ãƒƒã‚µ
	//ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—
	const XMMATRIX& GetMatView() { return matView_; }

	//ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	const XMMATRIX& GetMatProjection() { return matProjection_; }

	const XMMATRIX& GetMatViewProjection() { return matViewProjection_; }

	//ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	const XMMATRIX& GetMatBillboard() { return matBillboard_; }
	const XMMATRIX& GetMatBillboardY() { return matBillboardY_; }

	//è¦–ç‚¹
	const XMFLOAT3& GetEye() { return eye_; }
	void SetEye(const XMFLOAT3& eye);

	//æ³¨è¦–ç‚¹
	const XMFLOAT3& GetTarget() { return target_; }
	void SetTarget(const XMFLOAT3& target);

	//ä¸Šæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
	const XMFLOAT3& GetUp() { return up_; }
	void SetUp(const XMFLOAT3& up);
};

</file_content>

<file_content path="engine/base/DirectXCommon.cpp">
#include "DirectXCommon.h"
#include <vector>
#include <cassert>
#include <vector>
#include <string>

#pragma comment(lib, "d3d12.lib")
#pragma comment(lib, "dxgi.lib")

using namespace Microsoft::WRL;

DirectXCommon* DirectXCommon::GetInstance() 
{
	static DirectXCommon instance;

	return &instance;
}

void DirectXCommon::Initialize(WinApp* winApp) 
{
	// NULLæ¤œå‡º
	assert(winApp);

	// ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
	this->winApp = winApp;

	// FPSå›ºå®šåˆæœŸåŒ–
	fpsFixed = new FPSFixed();
	fpsFixed->InitializeFixFPS();
	// ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	InitializeDevice();
	// ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
	InitializeCommand();
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®åˆæœŸåŒ–
	InitializeSwapchain();
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	InitializeRenderTargetView();
	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®åˆæœŸåŒ–
	InitializeDepthBuffer();
	// ãƒ•ã‚§ãƒ³ã‚¹ã®åˆæœŸåŒ–
	InitializeFence();
}

void DirectXCommon::InitializeDevice()
{

#ifdef _DEBUG
	// ãƒ‡ãƒãƒƒã‚¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚ªãƒ³ã«
	ID3D12Debug1* debugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {
		debugController->EnableDebugLayer();
		debugController->SetEnableGPUBasedValidation(TRUE);
	}

#endif

	// DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ
	result = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));
	assert(SUCCEEDED(result));

	// ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®åˆ—æŒ™ç”¨
	std::vector<IDXGIAdapter4*> adapters;
	// ã“ã“ã«ç‰¹å®šã®åå‰ã‚’æŒã¤ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå…¥ã‚‹
	IDXGIAdapter4* tmpAdapter = nullptr;

	// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒé«˜ã„ã‚‚ã®ã‹ã‚‰é †ã«ã€å…¨ã¦ã®ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚’åˆ—æŒ™ã™ã‚‹
	for (UINT i = 0;
		dxgiFactory->EnumAdapterByGpuPreference(i,
			DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE,
			IID_PPV_ARGS(&tmpAdapter)) != DXGI_ERROR_NOT_FOUND;
		i++) {
		// å‹•çš„é…åˆ—ã«è¿½åŠ ã™ã‚‹
		adapters.push_back(tmpAdapter);
	}

	// å¦¥å½“ãªã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚’é¸åˆ¥ã™ã‚‹
	for (size_t i = 0; i < adapters.size(); i++) {
		DXGI_ADAPTER_DESC3 adapterDesc;
		// ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
		adapters[i]->GetDesc3(&adapterDesc);

		// ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒ‡ãƒã‚¤ã‚¹ã‚’å›é¿
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE)) {
			// ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¡ç”¨ã—ã¦ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			tmpAdapter = adapters[i];
			break;
		}
	}

	// å¯¾å¿œãƒ¬ãƒ™ãƒ«ã®é…åˆ—
	D3D_FEATURE_LEVEL levels[] = {
		D3D_FEATURE_LEVEL_12_1,
		D3D_FEATURE_LEVEL_12_0,
		D3D_FEATURE_LEVEL_11_1,
		D3D_FEATURE_LEVEL_11_0,
	};

	D3D_FEATURE_LEVEL featureLevel;

	for (size_t i = 0; i < _countof(levels); i++) {
		// æ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
		result = D3D12CreateDevice(tmpAdapter, levels[i],
			IID_PPV_ARGS(&device));
		if (result == S_OK) {
			// ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆã§ããŸæ™‚ç‚¹ã§ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			featureLevel = levels[i];
			break;
		}
	}

#ifdef _DEBUG
	ComPtr<ID3D12InfoQueue> infoQueue;
	if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true); // ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹

		// æŠ‘åˆ¶ã™ã‚‹ã‚¨ãƒ©ãƒ¼
		D3D12_MESSAGE_ID denyIds[] = {
			/*
			* Windows11ã§ã®DXGIãƒ‡ãƒãƒƒã‚¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨DX12ãƒ‡ãƒãƒƒã‚¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¸äº’ä½œç”¨ãƒã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
			* https://stackoverflow.com/questions/69805245/directx-12-application-is-crashing-in-windows-11
			*/
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE
		};
		// æŠ‘åˆ¶ã™ã‚‹è¡¨ç¤ºãƒ¬ãƒ™ãƒ«
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;
		// æŒ‡å®šã—ãŸã‚¨ãƒ©ãƒ¼ã®è¡¨ç¤ºã‚’æŠ‘åˆ¶
		infoQueue->PushStorageFilter(&filter);

		//infoQueue->Release();
	}
#endif
}

void DirectXCommon::InitializeCommand()
{
	// ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ç”Ÿæˆ
	result = device->CreateCommandAllocator(
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		IID_PPV_ARGS(&commandAllocator));
	assert(SUCCEEDED(result));

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
	result = device->CreateCommandList(0,
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		commandAllocator.Get(), nullptr,
		IID_PPV_ARGS(&commandList));
	assert(SUCCEEDED(result));

	// ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã®è¨­å®š
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};

	// ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆ
	result = device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&commandQueue));
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeSwapchain()
{
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®è¨­å®š
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
	swapChainDesc.Width = 1280;
	swapChainDesc.Height = 720;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//è‰²æƒ…å ±ã®æ›¸å¼
	swapChainDesc.SampleDesc.Count = 1;//ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã—ãªã„
	swapChainDesc.BufferUsage = DXGI_USAGE_BACK_BUFFER;//ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ç”¨
	swapChainDesc.BufferCount = 2;//ãƒãƒƒãƒ•ã‚¡æ•°ã‚’2ã¤ã«è¨­å®š
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;// ãƒ•ãƒªãƒƒãƒ—ç”¨ã¯ç ´æ£„
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// IDXGISwapChain1ã®Comptrã‚’ç”¨æ„
	ComPtr<IDXGISwapChain1> swapChain1;

	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆ
	result = dxgiFactory->CreateSwapChainForHwnd(
		commandQueue.Get(), winApp->GetHwnd(), &swapChainDesc, nullptr, nullptr,
		&swapChain1
	);
	//ç”Ÿæˆã—ãŸIDXGISwapChain1ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’IDXGISwapChain4ã«å¤‰æ›ã™ã‚‹
	swapChain1.As(&swapChain);
	assert(SUCCEEDED(result));
}

void DirectXCommon::InitializeRenderTargetView()
{
	DXGI_SWAP_CHAIN_DESC swcDesc = {};
    result = swapChain->GetDesc(&swcDesc);
    assert(SUCCEEDED(result));

	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®è¨­å®š
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
	swapChainDesc.Width = 1280;
	swapChainDesc.Height = 720;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;// è‰²æƒ…å ±ã®æ›¸å¼
	swapChainDesc.SampleDesc.Count = 1;// ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã—ãªã„
	swapChainDesc.BufferUsage = DXGI_USAGE_BACK_BUFFER;// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ç”¨
	swapChainDesc.BufferCount = 2;// ãƒãƒƒãƒ•ã‚¡æ•°ã‚’2ã¤ã«è¨­å®š
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;// ãƒ•ãƒªãƒƒãƒ—ç”¨ã¯ç ´æ£„
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc{};
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;//ãƒ¬ãƒ³ã‚²ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¬ãƒ“ãƒ¥ãƒ¼
	rtvHeapDesc.NumDescriptors = swapChainDesc.BufferCount;//è£è¡¨ã®2ã¤

	rtvHD = device->GetDescriptorHandleIncrementSize(rtvHeapDesc.Type);

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&rtvHeap));

	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡
	backBuffers.resize(swapChainDesc.BufferCount);

	// è£è¡¨ã®2ã¤åˆ†
	for (int i = 0; i < 2; i++) {
		// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®å…¨ã¦ã®ãƒãƒƒãƒ•ã‚¡ã«ã¤ã„ã¦å‡¦ç†ã™ã‚‹
		for (size_t i = 0; i < backBuffers.size(); i++) {
			// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ã‚’å–å¾—
			swapChain->GetBuffer((UINT)i, IID_PPV_ARGS(&backBuffers[i]));
			// ãƒ‡ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‹ã‚‰ãƒãƒƒãƒ•ã‚¡ã‚’å–å¾—
			D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = rtvHeap->GetCPUDescriptorHandleForHeapStart();
			// è£ã‹è¡¨ã‹ã§ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒãšã‚Œã‚‹
			rtvHandle.ptr += i * device->GetDescriptorHandleIncrementSize(rtvHeapDesc.Type);
			// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
			D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
			// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨ˆç®—çµæœã‚’SRGBã«å¤‰æ›ã—ã¦æ›¸ãè¾¼ã‚€
			rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
			rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
			// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ç”Ÿæˆ
			device->CreateRenderTargetView(backBuffers[i].Get(), &rtvDesc, rtvHandle);
		}
	}
}

void DirectXCommon::InitializeDepthBuffer()
{
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	D3D12_RESOURCE_DESC depthResourceDesc{};
	depthResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	depthResourceDesc.Width = WinApp::window_width;// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åˆã‚ã›ã‚‹
	depthResourceDesc.Height = WinApp::window_height;// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åˆã‚ã›ã‚‹
	depthResourceDesc.DepthOrArraySize = 1;
	depthResourceDesc.Format = DXGI_FORMAT_D32_FLOAT;//æ·±åº¦ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	depthResourceDesc.SampleDesc.Count = 1;
	depthResourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;//ãƒ†ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«

	// æ·±åº¦å€¤ç”¨ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	D3D12_HEAP_PROPERTIES depthHeapProp{};
	depthHeapProp.Type = D3D12_HEAP_TYPE_DEFAULT;
	// æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
	D3D12_CLEAR_VALUE depthClearValue{};//æ·±åº¦å€¤1.0f(æœ€å¤§å€¤)ã§ã‚¯ãƒªã‚¢
	depthClearValue.Format = DXGI_FORMAT_D32_FLOAT; //æ·±åº¦å€¤ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	depthClearValue.DepthStencil.Depth = 1.0f;

	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	ID3D12Resource* depthBuff = nullptr;
	result = device->CreateCommittedResource(
		&depthHeapProp,
		D3D12_HEAP_FLAG_NONE,
		&depthResourceDesc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&depthClearValue,
		IID_PPV_ARGS(&depthBuff));

	// æ·±åº¦ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ä½œæˆ
	D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc{};
	dsvHeapDesc.NumDescriptors = 1;//æ·±åº¦ãƒ“ãƒ¥ãƒ¼ã¯1ã¤
	dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	/*ID3D12DescriptorHeap* dsvHeap = nullptr;*/
	result = device->CreateDescriptorHeap(&dsvHeapDesc, IID_PPV_ARGS(&dsvHeap));

	// æ·±åº¦ãƒ“ãƒ¥ãƒ¼ä½œæˆ
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	device->CreateDepthStencilView(
		depthBuff,
		&dsvDesc,
		dsvHeap->GetCPUDescriptorHandleForHeapStart());
}

void DirectXCommon::InitializeFence()
{
	result = device->CreateFence(fenceVal, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence));
}

void DirectXCommon::PreDraw()
{
	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç•ªå·å–å¾—(ï¼’ã¤ãªã®ã§0ç•ªã‹1ç•ª)
	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	// 1.ãƒªã‚½ãƒ¼ã‚¹ãƒãƒªã‚¢ã§æ›¸ãè¾¼ã¿å¯èƒ½ã«å¤‰æ›´
	D3D12_RESOURCE_BARRIER barrierDesc{};
	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã‚’æŒ‡å®š
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;// è¡¨ç¤ºçŠ¶æ…‹ã‹ã‚‰
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;// æç”»çŠ¶æ…‹ã¸
	commandList->ResourceBarrier(1, &barrierDesc);
	//commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(backBuffers[bbIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

	// 2.æç”»å…ˆã®å¤‰æ›´
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle =
		CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeap->GetCPUDescriptorHandleForHeapStart(), bbIndex, rtvHD);
	/*rtvHandle.ptr += bbIndex * rtvH;*/
	// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle = 
		CD3DX12_CPU_DESCRIPTOR_HANDLE(dsvHeap->GetCPUDescriptorHandleForHeapStart());
	// æç”»å…ˆæŒ‡å®š
	commandList->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);

	// 3.æç”»ã‚¯ãƒªã‚¢ã€€ã€€ã€€ã€€ã€€
	// ç”»é¢ã‚’å¡—ã‚‹ã¤ã¶ã™è‰²    R    G      B     A
	FLOAT clearcolor[] = { 0.1f, 0.25f, 0.5f, 0.0f };// é’ã£ã½ã„è‰²
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¯ãƒªã‚¢
	commandList->ClearRenderTargetView(rtvHandle, clearcolor, 0, nullptr);
	// éœ‡åº¦ãƒãƒƒãƒ•ã‚¡ã‚¯ãƒªã‚¢
	commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

	bool ã‚­ãƒ¼ã‚’æŠ¼ã—ãŸçŠ¶æ…‹ã‹(uint8_t ã‚­ãƒ¼ç•ªå·);
	bool ã‚­ãƒ¼ã‚’é›¢ã—ãŸçŠ¶æ…‹ã‹(uint8_t ã‚­ãƒ¼ç•ªå·);
	bool ã‚­ãƒ¼ã‚’æŠ¼ã—ãŸç¬é–“ã‹(uint8_t ã‚­ãƒ¼ç•ªå·);
	bool ã‚­ãƒ¼ã‚’é›¢ã—ãŸç¬é–“ã‹(uint8_t ã‚­ãƒ¼ç•ªå·);

	//4.æç”»ã‚³ãƒãƒ³ãƒ‰ã¯ã“ã“ã‹ã‚‰
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¨­å®šã‚³ãƒãƒ³ãƒ‰
	D3D12_VIEWPORT viewport{};
	viewport.Width = WinApp::window_width;
	viewport.Height = WinApp::window_height;
	viewport.TopLeftX = 0;
	viewport.TopLeftY = 0;
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¨­å®šã‚³ãƒãƒ³ãƒ‰ã‚’ã€ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«ç©ã‚€
	commandList->RSSetViewports(1, &viewport);
	//commandList->RSSetViewports(1, &CD3DX12_VIEWPORT(0.0f, 0.0f, WinApp::window_width, WinApp::window_height));

	// ã‚·ã‚¶ãƒ¼çŸ©å½¢
	D3D12_RECT scissorRect{};
	scissorRect.left = 0;// åˆ‡ã‚ŠæŠœãåº§æ¨™å·¦
	scissorRect.right = scissorRect.left + WinApp::window_width;// åˆ‡ã‚ŠæŠœãåº§æ¨™å³
	scissorRect.top = 0;// åˆ‡ã‚ŠæŠœãåº§æ¨™ä¸Š
	scissorRect.bottom = scissorRect.top + WinApp::window_height;// åˆ‡ã‚ŠæŠœãåº§æ¨™ä¸‹
	// ã‚·ã‚¶ãƒ¼çŸ©å½¢è¨­å®šã‚³ãƒãƒ³ãƒ‰ã‚’ã€ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«ç©ã‚€
	commandList->RSSetScissorRects(1, &scissorRect);
	//commandList->RSSetScissorRects(1, &CD3DX12_RECT(0, 0, WinApp::window_width, WinApp::window_height));
}

void DirectXCommon::PostDraw()
{
	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç•ªå·å–å¾—(ï¼’ã¤ãªã®ã§0ç•ªã‹1ç•ª)
	UINT bbIndex = swapChain->GetCurrentBackBufferIndex();

	// 5.ãƒªã‚½ãƒ¼ã‚¹ãƒãƒªã‚¢ã‚’æˆ»ã™
	D3D12_RESOURCE_BARRIER barrierDesc{};
	barrierDesc.Transition.pResource = backBuffers[bbIndex].Get();// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã‚’æŒ‡å®š
	barrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET; // è¡¨ç¤ºçŠ¶æ…‹ã‹ã‚‰
	barrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT; // æç”»çŠ¶æ…‹ã¸
	commandList->ResourceBarrier(1, &barrierDesc);

	// å‘½ä»¤ã®ã‚¯ãƒ­ãƒ¼ã‚º
	result = commandList->Close();
	assert(SUCCEEDED(result));

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œ
	ID3D12CommandList* commandLists[] = { commandList.Get()};
	commandQueue->ExecuteCommandLists(1, commandLists);

	// ç”»é¢ã«è¡¨ç¤ºã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªãƒƒãƒ—(è£è¡¨ã®å…¥ã‚Œæ›¿ãˆ)
	result = swapChain->Present(1, 0);
	assert(SUCCEEDED(result));

	// ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œå®Œäº†ã‚’æŒã¤
	commandQueue->Signal(fence.Get(), ++fenceVal);
	if (fence->GetCompletedValue() != fenceVal) {
		HANDLE event = CreateEvent(nullptr, false, false, nullptr);
		fence->SetEventOnCompletion(fenceVal, event);
		WaitForSingleObject(event, INFINITE);
		CloseHandle(event);
	}

	// FPSå›ºå®š
	fpsFixed->UpdateFixFPS();

	// ã‚­ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢
	result = commandAllocator->Reset();
	assert(SUCCEEDED(result));

	// å†ã³ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’è²¯ã‚ã‚‹æº–å‚™
	result = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(result));
}

void DirectXCommon::fpsFixedFinalize()
{
	safe_delete(fpsFixed);
}

</file_content>

<file_content path="engine/base/DirectXCommon.h">
#pragma once 
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>
#include <d3dx12.h>
#include <chrono>
#include <thread>

#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)

#include "WinApp.h"
#include "FPSFixed.h"

using namespace Microsoft::WRL;

// DirectXåŸºç›¤
class DirectXCommon final
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize(WinApp* winApp);
	// ãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
	void InitializeDevice();
	// ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
	void InitializeCommand();
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®åˆæœŸåŒ–
	void InitializeSwapchain();
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	void InitializeRenderTargetView();
	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®åˆæœŸåŒ–
	void InitializeDepthBuffer();
	// ãƒ•ã‚§ãƒ³ã‚¹ã®åˆæœŸåŒ–
	void InitializeFence();
	// æç”»å‰å‡¦ç†
	void PreDraw();
	// æç”»å¾Œå‡¦ç†
	void PostDraw();
	// çµ‚äº†å‡¦ç†
	void fpsFixedFinalize();

private: // ãƒ¡ãƒ³ãƒé–¢æ•°
	template <class T>
	inline void safe_delete(T*& p) {
		delete p;
		p = nullptr;
	}

public:
	static DirectXCommon* GetInstance();

private:
	DirectXCommon() = default;
	~DirectXCommon() = default;
	DirectXCommon(const DirectXCommon&) = delete;
	DirectXCommon& operator=(const DirectXCommon&) = delete;
	

public: // Getter
	// ãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—
	ID3D12Device* GetDevice() const { return device.Get(); }
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆå–å¾—
	ID3D12GraphicsCommandList* GetCommandList() const { return commandList.Get(); }
	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ•°ã‚’å–å¾—
	size_t GetBackBufferCount() const { return backBuffers.size(); }

private: 
	// WindowsAPI
	WinApp* winApp = nullptr;
	// FPS
	FPSFixed* fpsFixed = nullptr;

	HRESULT result;
	// DirectX12ãƒ‡ãƒã‚¤ã‚¹
	ComPtr<ID3D12Device> device;
	// DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒª
	ComPtr<IDXGIFactory7> dxgiFactory;
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³
	ComPtr<IDXGISwapChain4> swapChain;
	// ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿
	ComPtr<ID3D12CommandAllocator> commandAllocator;
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	ComPtr<ID3D12GraphicsCommandList> commandList;
	// ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼
	ComPtr<ID3D12CommandQueue> commandQueue;
	ComPtr<ID3D12DescriptorHeap> rtvHeap;
	ComPtr<ID3D12DescriptorHeap> dsvHeap;


	//ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡
	std::vector<ComPtr<ID3D12Resource>> backBuffers;
	// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆ
	ComPtr<ID3D12Fence> fence;

	UINT rtvHD;
	UINT64 fenceVal = 0;
};
</file_content>

<file_content path="engine/base/FPSFixed.cpp">
#include "FPSFixed.h"

void FPSFixed::InitializeFixFPS() {
	// ç¾åœ¨æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();
}

void FPSFixed::UpdateFixFPS() {
	// 1/60ç§’ã´ã£ãŸã‚Šã®æ™‚é–“
	const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 105.0f));
	// 1/60ç§’ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“
	const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 100.0f));

	// ç¾åœ¨ã®æ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
	// å‰å›è¨˜éŒ²ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::microseconds elapsed =
		std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

	// 1/60ç§’(ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“)çµŒã£ã¦ã„ãªã„å ´åˆ
	if (elapsed < kMinCheckTime) {
		// 1/60ç§’çµŒéã™ã‚‹ã¾ã§å¾®å°åã‚¹ãƒªãƒ¼ãƒ—ã‚’ç¹°ã‚Šè¿”ã™
		while (std::chrono::steady_clock::now() - reference_ < kMinTime) {
			// 1ãƒã‚¤ã‚¯ãƒ­ç§’ã‚¹ãƒªãƒ¼ãƒ—
			std::this_thread::sleep_for(std::chrono::microseconds(1));
		}
	}
	// ç¾åœ¨ã®æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();
}
</file_content>

<file_content path="engine/base/FPSFixed.h">
#pragma once

#include <chrono>
#include <thread>

class FPSFixed 
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// FPSå›ºå®šåˆæœŸåŒ–
	void InitializeFixFPS();
	// FPSå›ºå®šæ›´æ–°
	void UpdateFixFPS();

	// è¨˜éŒ²æ™‚é–“(FPSå›ºå®šç”¨)
	std::chrono::steady_clock::time_point reference_;
};
</file_content>

<file_content path="engine/base/Input.cpp">
#include "Input.h"
#include <cassert>

#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")

//using namespace Microsoft::WRL;

Input* Input::GetInstance()
{
	static Input instance;

	return &instance;
}

void Input::Initialize(WinApp* winApp)
{
	// å€Ÿã‚Šã¦ããŸWinAppã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winApp = winApp;

	HRESULT result;

	// DirectInputã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆ
	/*ComPtr<IDirectInput8> directInput = nullptr;*/
	result = DirectInput8Create(winApp->GetHInstance(), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&directInput, nullptr);
	assert(SUCCEEDED(result));

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	//ComPtr<IDirectInputDevice8> keyboard = nullptr;
	result = directInput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));

	// å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetDataFormat(&c_dfDIKeyboard); // æ¨™æº–å½¢å¼
	assert(SUCCEEDED(result));

	// æ’ä»–åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetCooperativeLevel(winApp->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));

	//ãƒã‚¦ã‚¹ãƒ‡ãƒã‚¤ã‚¹ã®ã‚»ãƒƒãƒˆ
	result = directInput->CreateDevice(GUID_SysMouse, &mouse, NULL);
	assert(SUCCEEDED(result));

	// å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	result = mouse->SetDataFormat(&c_dfDIMouse); // æ¨™æº–å½¢å¼
	assert(SUCCEEDED(result));
	
	// æ’ä»–åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetCooperativeLevel(winApp->GetHwnd(), DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
	assert(SUCCEEDED(result));

	//ãƒ‡ãƒã‚¤ã‚¹ã®è¨­å®š
	DIPROPDWORD diprop;
	diprop.diph.dwSize = sizeof(diprop);
	diprop.diph.dwHeaderSize = sizeof(diprop.diph);
	diprop.diph.dwObj = 0;
	diprop.diph.dwHow = DIPH_DEVICE;
	diprop.dwData = DIPROPAXISMODE_REL;

	result = mouse->SetProperty(DIPROP_AXISMODE, &diprop.diph);
	assert(SUCCEEDED(result));
	//ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã‚’éš ã™
	ShowCursor(FALSE);
}

void Input::Update()
{
	HRESULT result;

	// å‰å›ã®ã‚­ãƒ¼å…¥åŠ›ã‚’ä¿æŒ
	memcpy(keyPre, key, sizeof(key));

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æƒ…å ±ã®å–å¾—é–‹å§‹
	result = keyboard->Acquire();

	// å…¨ã‚­ãƒ¼ã®å…¥åŠ›çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹
	/*BYTE key[256] = {};*/
	result = keyboard->GetDeviceState(sizeof(key), key);

	//ãƒã‚¦ã‚¹åˆ¶å¾¡é–‹å§‹
	memcpy(&mouseState_bak, &mouseState, sizeof(mouseState_bak));
	mouse->Acquire();

	result = mouse->GetDeviceState(sizeof(DIMOUSESTATE), &mouseState);
}

//ãƒã‚¦ã‚¹å·¦
bool Input::PushMouseLeft()
{
	if (mouseState.rgbButtons[0] != 0) {
		return true;
	}
	return false;
}

bool Input::TriggerMouseLeft()
{
	if (mouseState.rgbButtons[0] > 0 && mouseState_bak.rgbButtons[0] == 0) {
		return true;
	}
	return false;
}

bool Input::PushMouseRight()
{
	if (mouseState.rgbButtons[1] > 0) {
		return true;
	}
	return false;
}

bool Input::TriggerMouseRight()
{
	if (mouseState.rgbButtons[1] > 0 && mouseState_bak.rgbButtons[1] == 0) {
		return true;
	}
	return false;
}

Vector3 Input::GetMousePos()
{
	POINT p;
	GetCursorPos(&p);
	ScreenToClient(winApp->GetHwnd(), &p);

	//zæˆåˆ†ã‚’0ã§è¿”ã™
	return Vector3((float)p.x,(float)p.y,0.0f);
}

Vector3 Input::GetMouseVelo()
{
	return Vector3((float)mouseState.lX - mouseState_bak.lX,(float)mouseState.lY - mouseState_bak.lY,0);
}

void Input::SetMousePos(Vector2 pos)
{
	POINT p{ (long)pos.x,(long)pos.y };
	SetCursorPos(p.x,p.y);
}

bool Input::PushKey(BYTE keyNumber) 
{
	// æŒ‡å®šã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã„ã‚Œã°trueã‚’è¿”ã™
	if (key[keyNumber]) {
		return true;
	}
	// ãã†ã§ã¯ãªã‘ã‚Œã°falseã‚’è¿”ã™
	return false;
}

bool Input::TriggerKey(BYTE keyNumber)
{
	if (key[keyNumber] && keyPre[keyNumber] == false) {
		return true;
	}
	
	return false;
}

bool Input::AnyKey()
{
	for (int i = 0; i < sizeof(key); i++) {
		if (key[i] && keyPre[i] == false) {
			return true;
		}
	}

	return false;
}

</file_content>

<file_content path="engine/base/Input.h">
#pragma once
#include <windows.h>
#include <wrl.h>
#include <dinput.h>
#include "WinApp.h"
#include <dwrite.h>
#include <wchar.h>
#include <wrl/client.h>
#include <random>
#include <xinput.h>
#include "Vector3.h"
#include "Vector2.h"

#pragma comment(lib,"d3d11.lib")
#pragma comment(lib,"d2d1.lib")
#pragma comment(lib,"dwrite.lib")
#pragma comment (lib, "xinput.lib")

#define MaxCountrollers 4  
#define MaxVibration 65535
//#define DIRECTINPUT_VERSION 0x0800 // DirectInputã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š

// å…¥åŠ›
class Input final
{
public:
	static Input* GetInstance();

public:
	struct CountrolerState
	{
		XINPUT_STATE state; // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®çŠ¶æ…‹ã®å–å¾—
		XINPUT_VIBRATION vibration;  // ãƒã‚¤ãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
		//bool Connected;
	};
	/*CountrolerState GamePad;*/

public:
	// namespace
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize(WinApp* winApp);

	// æ›´æ–°
	void Update();

	//ãƒã‚¦ã‚¹
	bool PushMouseLeft();
	bool TriggerMouseLeft();
	bool PushMouseRight();
	bool TriggerMouseRight();
	//åº§æ¨™
	Vector3 GetMousePos();
	Vector3 GetMouseVelo();

	void SetMousePos(Vector2 pos);

	/// <summary>
	/// ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name = "keyNumber">ã‚­ãƒ¼ç•ªå·(DIK_0 ç­‰)</param>
	/// <returns>æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹</returns>
	bool PushKey(BYTE keyNumber);

	/// <summary>
	/// ã‚­ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// </param name="keyNumber">ã‚­ãƒ¼ç•ªå·( DIK_0 ç­‰)</param>
	/// <reutrns>ãƒˆãƒªã‚¬ãƒ¼ã‹</params>
	bool TriggerKey(BYTE keyNumber);
	bool AnyKey();

private:
	Input() = default;
	~Input() = default;
	Input(const Input&) = delete;
	Input& operator=(const Input&) = delete;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®ãƒ‡ãƒã‚¤ã‚¹
	ComPtr<IDirectInputDevice8> keyboard;
	//ãƒã‚¦ã‚¹ã®ãƒ‡ãƒã‚¤ã‚¹
	ComPtr<IDirectInputDevice8> mouse;
	// DirectInputã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	ComPtr<IDirectInput8> directInput;
	// å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE key[256] = {};
	// å‰å›ã®å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE keyPre[256] = {};
	//ãƒã‚¦ã‚¹ã®çŠ¶æ…‹
	DIMOUSESTATE mouseState = {};
	DIMOUSESTATE mouseState_bak = {};	// ãƒã‚¦ã‚¹æƒ…å ±(å¤‰åŒ–æ¤œçŸ¥ç”¨)
	// WindowsAPI
	WinApp* winApp = nullptr;
};
</file_content>

<file_content path="engine/base/JsonLoader.cpp">
#include "JsonLoader.h"

#pragma warning(push)
#pragma	warning(disable:4281)
#include <json.hpp>
#pragma warning(pop)
#include <fstream>
#include <cassert>

const std::string JsonLoader::kDefaultBaseDirectory = "Resources/levels/";
const std::string JsonLoader::kExtension = ".json";

//ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
LevelData* JsonLoader::LoadFile(const std::string& fileName) {
	// é€£çµã—ã¦ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’å¾—ã‚‹
	const std::string fullpath = kDefaultBaseDirectory + fileName + kExtension;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
	std::ifstream file;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(fullpath);
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’ãƒã‚§ãƒƒã‚¯
	if (file.fail()) {
		assert(0);
	}

	// JSONæ–‡å­—åˆ—ã‹ã‚‰è§£å‡ã—ãŸãƒ‡ãƒ¼ã‚¿
	nlohmann::json deserialized;

	// è§£å‡
	file >> deserialized;

	// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
	assert(deserialized.is_object());
	assert(deserialized.contains("name"));
	assert(deserialized["name"].is_string());

	// "name"ã‚’æ–‡å­—åˆ—ã¨ã—ã¦å–å¾—
	std::string name = deserialized["name"].get<std::string>();
	// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
	assert(name.compare("scene") == 0);

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	LevelData* levelData = new LevelData();

	// "objects"ã®å…¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èµ°æŸ»
	for (nlohmann::json& object : deserialized["objects"]) {
		assert(object.contains("type"));

		// ç¨®åˆ¥ã‚’å–å¾—
		std::string type = object["type"].get<std::string>();

		// MESH
		if (type.compare("MESH") == 0) {
			// è¦ç´ è¿½åŠ 
			levelData->objects.emplace_back(LevelData::ObjectData{});
			// ä»Šè¿½åŠ ã—ãŸè¦ç´ ã®å‚ç…§ã‚’å¾—ã‚‹
			LevelData::ObjectData& objectData = levelData->objects.back();

			if (object.contains("file_name")) {
				// ãƒ•ã‚¡ã‚¤ãƒ«å
				objectData.fileName = object["file_name"];
			}

			// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
			nlohmann::json& transform = object["transform"];
			// å¹³è¡Œç§»å‹•
			objectData.translation.x = (float)transform["translation"][1];
			objectData.translation.y = (float)transform["translation"][2];
			objectData.translation.z = (float)transform["translation"][0] * -1;
			objectData.translation.w = 1.0f;
			// å›è»¢è§’
			objectData.rotation.x = (float)transform["rotation"][1] * -1;
			objectData.rotation.y = (float)transform["rotation"][2] * -1;
			objectData.rotation.z = (float)transform["rotation"][0];
			objectData.rotation.w = 0.0f;
			// ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
			objectData.scaling.x = (float)transform["scaling"][1];
			objectData.scaling.y = (float)transform["scaling"][2];
			objectData.scaling.z = (float)transform["scaling"][0];
			objectData.scaling.w = 0.0f;

			// TODO: ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
		}

		// TODO: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆèµ°æŸ»ã‚’å†å¸°é–¢æ•°ã«ã¾ã¨ã‚ã€å†å¸°å‘¼å‡ºã§æã‚’èµ°æŸ»ã™ã‚‹
		if (object.contains("children")) {

		}
	}

	return levelData;
}
</file_content>

<file_content path="engine/base/JsonLoader.h">
#pragma once
#include "Vector4.h"
#pragma warning(push)
#pragma	warning(disable:4282)
#pragma	warning(disable:4283)
#pragma	warning(disable:4285)
#include <json.hpp>
#pragma warning(pop)
#include <string>
#include <vector>
#include "Matrix4.h"

// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿
struct LevelData {

	struct ObjectData {
		// ãƒ•ã‚¡ã‚¤ãƒ«å
		std::string fileName;
		// å¹³è¡Œç§»å‹•
		Vector4 translation;
		// å›è»¢è§’
		Vector4 rotation;
		// ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
		Vector4 scaling;
	};

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—
	std::vector<ObjectData> objects;
};

class JsonLoader {
public:
	//ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
	LevelData* LoadFile(const std::string& fileName);
public:
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®èª­ã¿è¾¼ã¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
	static const std::string kDefaultBaseDirectory;
	// ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­
	static const std::string kExtension;

};
</file_content>

<file_content path="engine/base/WinApp.cpp">
#include "WinApp.h"

WinApp* WinApp::GetInstance() 
{
	static WinApp instance;

	return &instance;
}

LRESULT WinApp::WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{

	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§åˆ†å²
	switch (msg) {
	case WM_DESTROY: // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒç ´æ£„ã•ã‚ŒãŸ
		PostQuitMessage(0); // OSã«å¯¾ã—ã¦ã€ã‚¢ãƒ—ãƒªã®çµ‚äº†ã‚’ä¼ãˆã‚‹
		return 0;
	}
	return DefWindowProc(hwnd, msg, wparam, lparam); // æ¨™æº–ã®å‡¦ç†ã‚’è¡Œã†
}

void WinApp::Initialize()
{
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®è¨­å®š
	//WNDCLASSEX w{};
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.lpfnWndProc = (WNDPROC)WindowProc;    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ã‚’è¨­å®š
	wc.lpszClassName = L"DirectXGame";       // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¯ãƒ©ã‚¹å
	wc.hInstance = GetModuleHandle(nullptr); // ã‚¦ã‚£ãƒ³ãƒ‰ãƒãƒ³ãƒ‰ãƒ«
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);// ã‚«ãƒ¼ã‚½ãƒ«æŒ‡å®š

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¯ãƒ©ã‚¹ã‚’OSã«ç™»éŒ²ã™ã‚‹
	RegisterClassEx(&wc);
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚µã‚¤ã‚º{Xåº§æ¨™ã€€Yåº§æ¨™ã€€æ¨ªå¹…ã€€ç¸¦å¹…}
	RECT wrc = { 0, 0, window_width, window_height };
	// è‡ªå‹•ã§ã‚µã‚¤ã‚ºã‚’è£œæ­£ã™ã‚‹
	AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ
	hwnd = CreateWindow(wc.lpszClassName, // ã‚¯ãƒ©ã‚¹å
		L"DirectXGame",       // ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ã®æ–‡å­—
		WS_OVERLAPPEDWINDOW,  // æ¨™æº–çš„ãªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ã‚¿ã‚¤ãƒ«
		CW_USEDEFAULT,        // æ¨™æº–Xåº§æ¨™ (05ã«ä»»ã›ã‚‹)
		CW_USEDEFAULT,        // æ¨™æº–Yåº§æ¨™ (05ã«ä»»ã›ã‚‹)
		wrc.right - wrc.left, // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¨ªå¹…
		wrc.bottom - wrc.top, // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç¸¦å¹…
		nullptr,
		nullptr,
		wc.hInstance,
		nullptr);

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºçŠ¶æ…‹ã«ã™ã‚‹
	ShowWindow(hwnd, SW_SHOW);

}

void WinApp::Finalize()
{
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’ç™»éŒ²è§£é™¤
	UnregisterClass(wc.lpszClassName, wc.hInstance);
}

bool WinApp::ProcessMessage()
{
	MSG msg{};// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

	if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg); //ã‚­ãƒ¼å…¥åŠ›ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
		DispatchMessage(&msg);  //ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ¼ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
	}

	if (msg.message == WM_QUIT) {
		return true;
	}

	return false;
}

</file_content>

<file_content path="engine/base/WinApp.h">
#pragma once
#include <Windows.h>

// WindowsAPI
class WinApp final
{
public: // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	static LRESULT WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// WindowsAPIã®åˆæœŸåŒ–
	void Initialize();

	// çµ‚äº†
	void Finalize();

	// getter
	HWND GetHwnd() const { return hwnd; }
	HINSTANCE GetHInstance() const { return wc.hInstance; }

	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
	bool ProcessMessage();

public:
	static WinApp* GetInstance();

private:
	WinApp() = default;
	~WinApp() = default;
	WinApp(const WinApp&) = delete;
	WinApp& operator=(const WinApp&) = delete;

public: // å®šæ•°
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¨ªå¹…
	static const int window_width = 1280;
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç¸¦å¹…
	static const int window_height = 720;

private:
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
	HWND hwnd = nullptr;
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®è¨­å®š
	WNDCLASSEX wc{};
};
</file_content>

<file_content path="engine/collision/BaseCollider.h">
#pragma once

#include "CollisionTypes.h"
#include "Object3d.h"
#include "CollisionInfo.h"

//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼åŸºåº•ã‚¯ãƒ©ã‚¹
class BaseCollider
{
public:
	BaseCollider() = default;
	//ä»®æƒ³ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~BaseCollider() = default;

	inline void SetObject(Object3d* object)
	{
		this->object3d = object;
		collname = object->GetName();
	}
	inline Object3d* GetObject3d()
	{
		return object3d;
	}
	void SetName(const char* name_) {
		this->collname = name_;
	}
	const char* GetName() {
		return collname;
	}

	//æ›´æ–°
	virtual void Update() = 0;

	//å½¢çŠ¶ã‚¿ã‚¤ãƒ—å–å¾—
	inline CollisionShapeType GetShapeType()
	{
		return shapeType;
	}

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	inline void OnCollision(const CollisionInfo& info)
	{
		object3d->OnCollision(info);
	}

	//è¡çªæ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
	inline void OffCollision(const CollisionInfo& info)
	{
		object3d->OffCollision(info);
	}

protected:
	Object3d* object3d = nullptr;
	//å½¢çŠ¶ã‚¿ã‚¤ãƒ—
	CollisionShapeType shapeType = SHAPE_UNKNOWN;
	//è¡çªå…ˆã‚¯ãƒ©ã‚¹å
	const char* collname = nullptr;
};
</file_content>

<file_content path="engine/collision/Collision.cpp">
#include "Collision.h"
using namespace DirectX;


bool Collision::CheckSphere2Sphere(const Sphere& sphereA, const Sphere& sphereB, Vector3* inter, Vector3* reject)
{
	float x = (sphereB.center.x - sphereA.center.x) * (sphereB.center.x - sphereA.center.x);
	float y = (sphereB.center.y - sphereA.center.y) * (sphereB.center.y - sphereA.center.y);
	float z = (sphereB.center.z - sphereA.center.z) * (sphereB.center.z - sphereA.center.z);

	float dist = x + y + z;
	float radius = (sphereA.radius + sphereB.radius) * (sphereA.radius + sphereB.radius);

	if (dist <= radius) {
		if (inter) {
			// Aã®åŠå¾„ãŒ0ã®æ™‚åº§æ¨™ã¯Bã®ä¸­å¿ƒ  Bã®åŠå¾„ãŒ0ã®æ™‚åº§æ¨™ã¯Aã®ä¸­å¿ƒ  ã¨ãªã‚‹ã‚ˆã†ã«è£œé–“
			float t = sphereB.radius / (sphereA.radius + sphereB.radius);
			*inter = Vector3::lerp(sphereA.center, sphereB.center, t);
		}
		if (reject) {
			float rejectLen = sphereA.radius + sphereB.radius - sqrtf(dist);
			Vector3 center = sphereA.center - sphereB.center;
			*reject = center.normalize();
			*reject *= rejectLen;

		}
		return true;
	}
	return false;
}

bool Collision::CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter)
{
	// åº§æ¨™ç³»ã®åŸç‚¹ã‹ã‚‰çƒã®ä¸­å¿ƒåº§æ¨™ã¸ã®è·é›¢
	Vector3 V;
	float distV = V.dot(sphere.center, plane.normal);
	// å¹³é¢ã®åŸç‚¹è·é›¢ã‚’æ¸›ç®—ã™ã‚‹ã“ã¨ã§ã€å¹³é¢ã¨çƒã®ä¸­å¿ƒã¨ã®è·é›¢ãŒå‡ºã‚‹
	float dist = distV - plane.distance;
	// è·é›¢ã®çµ¶å¯¾å€¤ãŒåŠå¾„ã‚ˆã‚Šå¤§ãã‘ã‚Œã°å½“ãŸã£ã¦ã„ãªã„
	if (fabsf(dist) > sphere.radius) return false;

	// ç–‘ä¼¼äº¤ç‚¹ã‚’è¨ˆç®—
	if (inter) {
		// å¹³é¢ä¸Šã®æœ€è¿‘æ¥ç‚¹ã‚’ã€ç–‘ä¼¼äº¤ç‚¹ã¨ã™ã‚‹
		*inter = -dist * plane.normal + sphere.center;
	}

	return true;
}

void Collision::ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest)
{
	// pointãŒp0ã®å¤–å´ã®é ‚ç‚¹é ˜åŸŸã®ä¸­ã«ã‚ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	Vector3 p0_p2 = triangle.p2 - triangle.p0;
	Vector3 p0_pt = point - triangle.p0;

	Vector3 V;
	float d1 = V.dot(p0_p1, p0_pt);
	float d2 = V.dot(p0_p2, p0_pt);

	if (d1 <= 0.0f && d2 <= 0.0f)
	{
		// p0ãŒæœ€è¿‘å‚
		*closest = triangle.p0;
		return;
	}

	// pointãŒp1ã®å¤–å´ã®é ‚ç‚¹é ˜åŸŸã®ä¸­ã«ã‚ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
	Vector3 p1_pt = point - triangle.p1;

	float d3 = V.dot(p0_p1, p1_pt);
	float d4 = V.dot(p0_p2, p1_pt);

	if (d3 >= 0.0f && d4 <= d3)
	{
		// p1ãŒæœ€è¿‘å‚
		*closest = triangle.p1;
		return;
	}

	// pointãŒp0_p1ã®è¾ºé ˜åŸŸã®ä¸­ã«ã‚ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã—ã€ã‚ã‚Œã°pointã®p0_p1ä¸Šã«å¯¾ã™ã‚‹å°„å½±ã‚’è¿”ã™
	float vc = d1 * d4 - d3 * d2;
	if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
	{
		float v = d1 / (d1 - d3);
		*closest = triangle.p0 + v * p0_p1;
		return;
	}

	// pointãŒp2ã®å¤–å´ã®é ‚ç‚¹é ˜åŸŸã®ä¸­ã«ã‚ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
	Vector3 p2_pt = point - triangle.p2;

	float d5 = V.dot(p0_p1, p2_pt);
	float d6 = V.dot(p0_p2, p2_pt);
	if (d6 >= 0.0f && d5 <= d6)
	{
		*closest = triangle.p2;
		return;
	}

	// pointãŒp0_p2ã®è¾ºé ˜åŸŸã®ä¸­ã«ã‚ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã—ã€ã‚ã‚Œã°pointã®p0_p2ä¸Šã«å¯¾ã™ã‚‹å°„å½±ã‚’è¿”ã™
	float vb = d5 * d2 - d1 * d6;
	if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
	{
		float w = d2 / (d2 - d6);
		*closest = triangle.p0 + w * p0_p2;
		return;
	}

	// pointãŒp1_p2ã®è¾ºé ˜åŸŸã®ä¸­ã«ã‚ã‚‹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã—ã€ã‚ã‚Œã°pointã®p1_p2ä¸Šã«å¯¾ã™ã‚‹å°„å½±ã‚’è¿”ã™
	float va = d3 * d6 - d5 * d4;
	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
	{
		float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
		*closest = triangle.p1 + w * (triangle.p2 - triangle.p1);
		return;
	}

	float denom = 1.0f / (va + vb + vc);
	float v = vb * denom;
	float w = vc * denom;
	*closest = triangle.p0 + p0_p1 * v + p0_p2 * w;
}

bool Collision::CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter, Vector3* reject)
{
	Vector3 p;
	// çƒã®ä¸­å¿ƒã«å¯¾ã™ã‚‹æœ€è¿‘æ¥ç‚¹ã§ã‚ã‚‹ä¸‰è§’å½¢ä¸Šã«ã‚ã‚‹ç‚¹pã‚’è¦‹ã¤ã‘ã‚‹
	ClosestPtPoint2Triangle(sphere.center, triangle, &p);

	// ç‚¹pã¨çƒã®ä¸­å¿ƒã®å·®åˆ†ãƒ™ã‚¯ãƒˆãƒ«
	Vector3 v = p - sphere.center;
	Vector3 VV;
	// è·é›¢ã®äºŒä¹—ã‚’æ±‚ã‚ã‚‹
	// ï¼ˆåŒã˜ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®å†…ç©ã¯ä¸‰å¹³æ–¹ã®å®šç†ã®ãƒ«ãƒ¼ãƒˆå†…éƒ¨ã®å¼ã¨ä¸€è‡´ã™ã‚‹ï¼‰
	float vvv = VV.dot(v, v);

	// çƒã¨ä¸‰è§’å½¢ã®è·é›¢ãŒåŠå¾„ä»¥ä¸‹ãªã‚‰å½“ãŸã£ã¦ã„ãªã„
	if (vvv > sphere.radius * sphere.radius)return false;

	// ç–‘ä¼¼äº¤ç‚¹ã‚’è¨ˆç®—
	if (inter) {
		// ä¸‰è§’å½¢ä¸Šã®æœ€è¿‘æ¥ç‚¹pã‚’ç–‘ä¼¼äº¤ç‚¹ã¨ã™ã‚‹
		*inter = p;
	}
	// æŠ¼ã—å‡ºã™ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
	if (reject) {
		float ds = Vector3::dot(sphere.center, triangle.normal);
		float dt = Vector3::dot(triangle.p0, triangle.normal);
		float rejectLen = dt - ds + sphere.radius;
		*reject = triangle.normal * rejectLen;
	}
	return true;
}

bool Collision::CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance, Vector3* inter)
{
	const float epsilon = 1.0e-5f; // èª¤å·®å¸åç”¨ã®å¾®å°ãªå€¤
	// é¢æ³•ç·šãƒˆãƒ¬ã‚¤ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã®å†…ç©
	Vector3 V;
	float d1 = V.dot(plane.normal, ray.dir);
	// è£é¢ã«ã¯å½“ãŸã‚‰ãªã„
	if (d1 > -epsilon) { return false; }
	// å§‹ç‚¹ã¨åŸç‚¹ã®è·é›¢ï¼ˆå¹³é¢ã®æ³•ç·šæ–¹å‘ï¼‰
	// é¢æ³•ç·šãƒˆãƒ¬ã‚¤ã®è¦–ç‚¹åº§æ¨™ï¼ˆä½ç½®ãƒ™ã‚¯ãƒˆãƒ«ï¼‰ã®å†…ç©
	float d2 = V.dot(plane.normal, ray.start);
	// å§‹ç‚¹ã¨å¹³é¢ã®è·é›¢ï¼ˆå¹³é¢ã®æ³•ç·šæ–¹å‘ï¼‰
	float dist = d2 - plane.distance;
	// å§‹ç‚¹ã¨å¹³é¢ã®è·é›¢ï¼ˆãƒ¬ã‚¤æ–¹å‘ï¼‰
	float t = dist / -d1;
	// äº¤ç‚¹ãŒå§‹ç‚¹ã‚ˆã‚Šå¾Œã‚ã«ã‚ã‚‹ã®ã§ã€å½“ãŸã‚‰ãªã„
	if (t < 0)return false;
	// è·é›¢ã‚’æ›¸ãè¾¼ã‚€
	if (distance) { *distance = t; }

	// äº¤ç‚¹ã‚’è¨ˆç®—
	if (inter) { *inter = ray.start + t * ray.dir; }

	return true;
}

bool Collision::CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance, Vector3* inter)
{
	// ä¸‰è§’å½¢ãŒä¹—ã£ã¦ã„ã‚‹å¹³é¢ã‚’ç®—å‡º
	Plane plane;
	Vector3 interPlane;
	Vector3 V;
	plane.normal = triangle.normal;
	plane.distance = V.dot(triangle.normal, triangle.p0);

	// ãƒ¬ã‚¤ã¨å¹³é¢ãŒå½“ãŸã£ã¦ã„ãªã‘ã‚Œã°ã€å½“ãŸã£ã¦ã„ãªã„
	if (!CheckRay2Plane(ray, plane, distance, &interPlane)) { return false; }

	// ãƒ¬ã‚¤ã¨å¹³é¢ãŒå½“ãŸã£ã¦ã„ãŸã®ã§ã€è·é›¢ã¨äº¤ç‚¹ãŒæ›¸ãè¾¼ã¾ã‚ŒãŸ
	// ãƒ¬ã‚¤ã¨å¹³é¢ã®äº¤ç‚¹ãŒä¸‰è§’å½¢ã®å†…å´ã«ã‚ã‚‹ã‹åˆ¤å®š
	const float epsilon = 1.0e-5f;// èª¤å·®å¸åç”¨ã®å¾®å°ãªå€¤
	Vector3 m;

	// è¾ºp0_p1ã«ã¤ã„ã¦
	Vector3 pt_p0 = triangle.p0 - interPlane;
	Vector3 p0_p1 = triangle.p1 - triangle.p0;
	m = pt_p0.cross(p0_p1);

	// è¾ºã®å¤–å´ã§ã‚ã‚Œã°å½“ãŸã£ã¦ã„ãªã„ã®ã§åˆ¤å®šã‚’æ‰“ã¡åˆ‡ã‚‹
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// è¾ºp1_p2ã«ã¤ã„ã¦
	Vector3 pt_p1 = triangle.p1 - interPlane;
	Vector3 p1_p2 = triangle.p2 - triangle.p1;
	m = pt_p1.cross(p1_p2);

	// è¾ºã®å¤–å´ã§ã‚ã‚Œã°å½“ãŸã£ã¦ã„ãªã„ã®ã§åˆ¤å®šã‚’æ‰“ã¡åˆ‡ã‚‹
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// è¾ºp2_p0ã«ã¤ã„ã¦
	Vector3 pt_p2 = triangle.p2 - interPlane;
	Vector3 p2_p0 = triangle.p0 - triangle.p2;
	m = pt_p2.cross(p2_p0);

	// è¾ºã®å¤–å´ã§ã‚ã‚Œã°å½“ãŸã£ã¦ã„ãªã„ã®ã§åˆ¤å®šã‚’æ‰“ã¡åˆ‡ã‚‹
	if (V.dot(m, triangle.normal) < -epsilon) { return false; }

	// å†…å´ãªã®ã§ã€å½“ãŸã£ã¦ã„ã‚‹
	if (inter) {
		*inter = interPlane;
	}

	return true;
}

bool Collision::CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance, Vector3* inter)
{
	Vector3 m = ray.start - sphere.center;
	Vector3 V;
	float b = V.dot(m, ray.dir);
	float c = V.dot(m, m) - sphere.radius * sphere.radius;

	// rayã®å§‹ç‚¹ãŒsphereã®å¤–å´ã«ã‚ã‚Š(c>0)ã€rayãŒsphereã‹ã‚‰é›¢ã‚Œã¦ã„ãæ–¹å‘ã‚’å·®ã—ã¦ã„ã‚‹å ´åˆ(b>0)ã€å½“ãŸã‚‰ãªã„
	if (c > 0.0f && b > 0.0f) { return false; }

	float discr = b * b - c;

	// è² ã®åˆ¤åˆ¥å¼ã¯ä¾‹ãŒçƒã‚’å¤–ã‚Œã¦ã„ã‚‹ã“ã¨ã«ä¸€è‡´
	if (discr < 0.0f) { return false; }

	// ãƒ¬ã‚¤ã¯çƒã¨äº¤å·®ã—ã¦ã„ã‚‹
	// äº¤å·®ã™ã‚‹æœ€å°ã®å€¤tã‚’è¨ˆç®—
	float t = -b - sqrtf(discr);

	// ï½”ãŒè² ã§ã‚ã‚‹å ´åˆã€ãƒ¬ã‚¤ã¯çƒã®å†…å´ã‹ã‚‰é–‹å§‹ã—ã¦ã„ã‚‹ã®ã§ï½”ã‚’ã‚¼ãƒ­ã«ã‚¯ãƒ©ãƒ³ãƒ—
	if (t < 0)t = 0.0f;
	if (distance) { *distance = t; }

	if (inter) { *inter = ray.start + t * ray.dir; }

	return true;
}

</file_content>

<file_content path="engine/collision/Collision.h">
#pragma once

#include "CollisionPrimitive.h"

class Collision
{
public:
	//çƒã¨çƒã®å½“ãŸã‚Šåˆ¤å®š
	static bool CheckSphere2Sphere(const Sphere& sphereA, const Sphere& sphereB, Vector3* inter = nullptr, Vector3* reject = nullptr);
	//çƒã¨å¹³é¢ã®å½“ãŸã‚Šåˆ¤å®š
	static bool CheckSphere2Plane(const Sphere& sphere, const Plane& plane, Vector3* inter = nullptr);

	//ç‚¹ã¨ä¸‰è§’å½¢ã®æœ€è¿‘ã›ã£ã¦ã‚’æ±‚ã‚ã‚‹
	static void ClosestPtPoint2Triangle(const Vector3& point, const Triangle& triangle, Vector3* closest);

	//çƒã¨æ³•ç·šä»˜ãä¸‰è§’å½¢ã®å½“ãŸã‚Šãƒã‚§ãƒƒã‚¯
	static bool CheckSphere2Triangle(const Sphere& sphere, const Triangle& triangle, Vector3* inter = nullptr, Vector3* reject = nullptr);

	//ãƒ¬ã‚¤ã¨å¹³é¢ã®å½“ãŸã‚Šåˆ¤å®š
	static bool CheckRay2Plane(const Ray& ray, const Plane& plane, float* distance = nullptr, Vector3* inter = nullptr);

	//ãƒ¬ã‚¤ã¨æ³•ç·šä»˜ãä¸‰è§’å½¢ã®å½“ãŸã‚Šåˆ¤å®š
	static bool CheckRay2Triangle(const Ray& ray, const Triangle& triangle, float* distance = nullptr, Vector3* inter = nullptr);

	//ãƒ¬ã‚¤ã¨çƒã®å½“ãŸã‚Šåˆ¤å®š
	static bool CheckRay2Sphere(const Ray& ray, const Sphere& sphere, float* distance = nullptr, Vector3* inter = nullptr);
};


</file_content>

<file_content path="engine/collision/CollisionInfo.h">
#pragma once
#include"Vector3.h"

class Object3d;
class BaseCollider;


struct CollisionInfo
{
public:
	CollisionInfo(Object3d* object, BaseCollider* collider, const Vector3& inter) {
		this->object = object;
		this->collider = collider;
		this->inter = inter;
	}

	// è¡çªç›¸æ‰‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	Object3d* object = nullptr;
	// è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
	BaseCollider* collider = nullptr;
	// è¡çªç‚¹
	Vector3 inter;

};
</file_content>

<file_content path="engine/collision/CollisionManager.cpp">
#include "CollisionManager.h"
#include "BaseCollider.h"
#include "Collision.h"

using namespace DirectX;

CollisionManager* CollisionManager::GetInstance()
{
	static CollisionManager instance;
	return &instance;
}

void CollisionManager::CheckAllCollisions()
{
	std::forward_list<BaseCollider*>::iterator itA;
	std::forward_list<BaseCollider*>::iterator itB;

	//å…¨ã¦ã®çµ„ã¿åˆã‚ã›ã«ã¤ã„ã¦ç·å½“ãŸã‚Šãƒã‚§ãƒƒã‚¯
	itA = colliders.begin();
	for (; itA != colliders.end(); ++itA)
	{
		itB = itA;
		++itB;
		for (; itB != colliders.end(); ++itB)
		{
			BaseCollider* colA = *itA;
    		BaseCollider* colB = *itB;
			//è¡çªç›¸æ‰‹ã‚’è¨˜æ†¶
			colA->GetObject3d()->toCollisionName = colB->GetName();
			colB->GetObject3d()->toCollisionName = colA->GetName();
			

			// ã¨ã‚‚ã«çƒ
			if (colA->GetShapeType() == COLLISIONSHAPE_SPHERE &&
				colB->GetShapeType() == COLLISIONSHAPE_SPHERE) {
				Sphere* SphereA = dynamic_cast<Sphere*>(colA);
				Sphere* SphereB = dynamic_cast<Sphere*>(colB);
				Vector3 inter;
				Vector3 reject;
				if (Collision::CheckSphere2Sphere(*SphereA, *SphereB, &inter,&reject)) {
					colA->OnCollision(CollisionInfo(colB->GetObject3d(), colB, inter));
					colB->OnCollision(CollisionInfo(colA->GetObject3d(), colA, inter));
				}
			}
		}
	}
}

bool CollisionManager::Raycast(const Ray& ray, RaycastHit* hitInfo, float maxDistance)
{
	bool result = false;
	//èµ°æŸ»ç”¨ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿
	std::forward_list<BaseCollider*>::iterator it;
	//ä»Šã¾ã§ã§æœ€ã‚‚è¿‘ã„ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿
	std::forward_list<BaseCollider*>::iterator it_hit;
	//ä»Šã¾ã§ã§æœ€ã‚‚è¿‘ã„ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è·é›¢ã‚’è¨˜éŒ²ã™ã‚‹å¤‰æ•°
	float distance = maxDistance;
	//ä»Šã¾ã§ã§æœ€ã‚‚è¿‘ã„ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¨ã®äº¤ç‚¹ã‚’è¨˜éŒ²ã™ã‚‹å¤‰æ•°
	Vector3 inter;

	//å…¨ã¦ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¨ç·å½“ãŸã‚Šãƒã‚§ãƒƒã‚¯
	it = colliders.begin();
	for (; it != colliders.end(); ++it)
	{
		BaseCollider* colA = *it;
		//çƒã®å ´åˆ
		if (colA->GetShapeType() == COLLISIONSHAPE_SPHERE)
		{
			Sphere* sphere = dynamic_cast<Sphere*>(colA);
			float tempDistance;
			Vector3 tempInter;
			//å½“ãŸã‚‰ãªã‘ã‚Œã°é™¤å¤–
			if (!Collision::CheckRay2Sphere(ray, *sphere, &tempDistance, &tempInter))continue;
			//è·é›¢ãŒæœ€å°å‡ºãªã‘ã‚Œã°é™¤å¤–
			if (tempDistance >= distance)continue;
			//ä»Šã¾ã§ã§æœ€ã‚‚è¿‘ã„ã®ã§è¨˜éŒ²ã‚’ã¨ã‚‹
			result = true;
			distance = tempDistance;
			inter = tempInter;
			it_hit = it;
			//æœ€çµ‚çš„ã«ä½•ã‹ã«å½“ãŸã£ã¦ã„ãŸã‚‰çµæœã‚’æ›¸ãè¾¼ã‚€
			if (result && hitInfo)
			{
				hitInfo->distance = distance;
				hitInfo->inter = inter;
				hitInfo->collider = *it_hit;
				hitInfo->object = hitInfo->collider->GetObject3d();
			}
			return result;
		}
	}
	return false;
}
</file_content>

<file_content path="engine/collision/CollisionManager.h">
#pragma once
#include "CollisionPrimitive.h"
#include "RaycastHit.h"

#include <forward_list>
#include <d3d12.h>

class BaseCollider;

class CollisionManager
{
public://é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	static CollisionManager* GetInstance();

public://ãƒ¡ãƒ³ãƒé–¢æ•°
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¿½åŠ 
	inline void AddCollider(BaseCollider* collider)
	{
		colliders.push_front(collider);
	}
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®å‰Šé™¤
	inline void RemoveCollider(BaseCollider* collider)
	{
		colliders.remove(collider);
	}
	//å…¨ã¦ã®è¡çªãƒã‚§ãƒƒã‚¯
	void CheckAllCollisions();
	//ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆ
	bool Raycast(const Ray& ray, RaycastHit* hitInfo = nullptr, float maxDistance = D3D12_FLOAT32_MAX);
private:
	CollisionManager() = default;
	CollisionManager(const CollisionManager&) = delete;
	~CollisionManager() = default;
	CollisionManager& operator = (const CollisionManager&) = delete;
	//ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒªã‚¹ãƒˆ
	std::forward_list<BaseCollider*>colliders;
};


</file_content>

<file_content path="engine/collision/CollisionPrimitive.cpp">
#include "CollisionPrimitive.h"

void Triangle::ComputeNormal()
{
	Vector3 p0_p1 = p1 - p0;
	Vector3 p0_p2 = p2 - p0;
	Vector3 V;

	// å¤–ç©ã«ã‚ˆã‚Šã€ï¼’è¾ºã«å‚ç›´ãªãƒ™ã‚¯ãƒˆãƒ«ã‚’ç®—å‡ºã™ã‚‹
	normal = p0_p1.cross(p0_p2);
	normal.normalize();
}
</file_content>

<file_content path="engine/collision/CollisionPrimitive.h">
#pragma once
#pragma once
#include<DirectXMath.h>
#include "Vector3.h"

//çƒ
struct Sphere
{
	//ä¸­å¿ƒåº§æ¨™
	Vector3 center = { 0,0,0 };
	//åŠå¾„
	float radius = 1.0f;
	//åº§æ¨™
	Vector3 position = { 0,0,0 };
};
//å¹³é¢
struct Plane
{
	//æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
	Vector3 normal = { 0,1,0 };
	//åŸç‚¹(0,0,0)ã‹ã‚‰ã®è·é›¢
	float distance = 0.0f;
};
//ãƒ¬ã‚¤
struct Ray
{
	//å§‹ç‚¹åº§æ¨™
	Vector3 start = { 0,0,0 };

	//æ–¹å‘
	Vector3 dir = { 1,0,0 };
};

//æ³•ç·šä»˜ãä¸‰è§’å½¢(æ™‚è¨ˆå›ã‚ŠãŒè¡¨é¢)
class Triangle
{
public:
	//é ‚ç‚¹3ã¤
	Vector3 p0;
	Vector3 p1;
	Vector3 p2;
	//æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
	Vector3 normal;

	//æ³•ç·šã®è¨ˆç®—
	void ComputeNormal();
};

class CollisionPrimitive
{
public:
};


</file_content>

<file_content path="engine/collision/CollisionTypes.h">
#pragma once

//è¡çªåˆ¤å®šç”¨ã®å‹å®šç¾©

enum CollisionShapeType
{
	SHAPE_UNKNOWN = -1,//æœªè¨­å®š

	COLLISIONSHAPE_SPHERE,//çƒ
};
</file_content>

<file_content path="engine/collision/RaycastHit.h">
#pragma once
#include "BaseCollider.h"
#include <DirectXMath.h>

class Object3d;

//ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã«ã‚ˆã‚‹æƒ…å ±ã‚’å¾—ã‚‹ãŸã‚ã®æ§‹é€ ä½“
struct RaycastHit
{
	//è¡çªç›¸æ‰‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	Object3d* object = nullptr;
	//è¡çªç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
	BaseCollider* collider = nullptr;
	//è¡çªç‚¹
	Vector3 inter;
	//è¡çªç‚¹ã¾ã§ã®è·é›¢
	float distance = 0.0f;
};
</file_content>

<file_content path="engine/collision/SphereCollider.cpp">
#include "SphereCollider.h"

void SphereCollider::Update()
{
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰åº§æ¨™ã‚’æŠ½å‡º
	const Matrix4& matWorld = object3d->worldTransform_.matWorld_;

	const Vector3& position = { matWorld.m[3][0],matWorld.m[3][1] ,matWorld.m[3][2] };

	//Vector4 matVec;
	//matVec.x = matWorld.m[3][0];
	//matVec.y = matWorld.m[3][1];
	//matVec.z = matWorld.m[3][2];
	//matVec.w = matWorld.m[3][3];

	// çƒã®ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚’æ›´æ–°
	Sphere::center = position + offset;
	Sphere::radius = radius;
}
</file_content>

<file_content path="engine/collision/SphereCollider.h">
#pragma once
#include "BaseCollider.h"
#include "CollisionPrimitive.h"

#include "Vector3.h"
#include "Matrix4.h"


class SphereCollider :public BaseCollider, public Sphere
{
private:// ã‚¨ã‚¤ãƒªã‚¢ã‚¹
public:
	SphereCollider(Vector3 offset = { 0,0,0 }, float radius = 1.0f) :offset(offset), radius(radius) {
		// çƒå½¢çŠ¶ã‚’ã‚»ãƒƒãƒˆ
		shapeType = COLLISIONSHAPE_SPHERE;
	}

	// æ›´æ–°
	void Update()override;

	inline const Vector3& GetOffset() { return offset; }

	inline void SetOffset(const Vector3& offset) { this->offset = offset; }

	inline float GetRadius() { return radius; }

	inline void SetRadius(float radius) { this->radius = radius; }

private:
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸­å¿ƒã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	Vector3 offset;
	// åŠå¾„
	float radius;
};
</file_content>

<file_content path="engine/effect/Particle.cpp">
#include "Particle.h"
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)
#include <Windows.h>
#include <cassert>
#include <sstream>
#include <string>
#include <fstream>
#include <vector>

using namespace DirectX;
using namespace std;

//é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®Ÿä½“
ID3D12Device* Particle::device_ = nullptr;
std::string Particle::defaultTextureDirectoryPath_ = "Resources/";

Particle* Particle::LoadParticleTexture(const std::string& fileName)
{
	//æ–°ãŸãªModelå‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿
	Particle* particle = new Particle();

	//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ç”Ÿæˆ
	particle->InitializeDescriptorHeap();

	//OBJãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
	particle->LoadTexture(fileName);

	//èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‚’å…ƒã«å„ç¨®ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	particle->CreateBuffers();

	return particle;
}

void Particle::InitializeDescriptorHeap()
{

	HRESULT result = S_FALSE;

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ	
	D3D12_DESCRIPTOR_HEAP_DESC descHeapDesc = {};
	descHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	descHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;//ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰è¦‹ãˆã‚‹ã‚ˆã†ã«
	descHeapDesc.NumDescriptors = 1; // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼1ã¤
	result = device_->CreateDescriptorHeap(&descHeapDesc, IID_PPV_ARGS(&descHeap_));//ç”Ÿæˆ
	if (FAILED(result)) {
		assert(0);
	}

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚ºã‚’å–å¾—
	descriptorHandleIncrementSize_ = device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

void Particle::LoadTexture(const std::string& fileName)
{
	HRESULT result;

	//ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‚’é€£çµã—ã¦ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’å¾—ã‚‹
	std::string fullPath = defaultTextureDirectoryPath_ + fileName;

	//ãƒ¯ã‚¤ãƒ‰æ–‡å­—åˆ—ã«å¤‰æ›ã—ãŸéš›ã®æ–‡å­—åˆ—ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
	int filePathBufferSize = MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, nullptr, 0);

	//ãƒ¯ã‚¤ãƒ‰æ–‡å­—åˆ—ã«å¤‰æ›
	std::vector<wchar_t> wfilePath(filePathBufferSize);
	MultiByteToWideChar(CP_ACP, 0, fullPath.c_str(), -1, wfilePath.data(), filePathBufferSize);

	//ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ç”¨æ„
	TexMetadata metadata{};
	ScratchImage scratchImg{};
	//WICãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ­ãƒ¼ãƒ‰
	result = LoadFromWICFile(
		wfilePath.data(),	//Resourcesãƒ•ã‚©ãƒ«ãƒ€ã®texture.png
		WIC_FLAGS_NONE,
		&metadata, scratchImg);

	assert(SUCCEEDED(result));

	ScratchImage mipChain{};
	//ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ç”Ÿæˆ
	result = GenerateMipMaps(
		scratchImg.GetImages(), scratchImg.GetImageCount(), scratchImg.GetMetadata(),
		TEX_FILTER_DEFAULT, 0, mipChain);
	if (SUCCEEDED(result))
	{
		scratchImg = std::move(mipChain);
		metadata = scratchImg.GetMetadata();
	}
	//èª­ã¿è¾¼ã‚“ã ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’SRGBã¨ã—ã¦æ‰±ã†
	metadata.format = MakeSRGB(metadata.format);

	// ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_HEAP_PROPERTIES textureHeapProp{};
	textureHeapProp.Type = D3D12_HEAP_TYPE_CUSTOM;
	textureHeapProp.CPUPageProperty =
		D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
	textureHeapProp.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;
	//ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	D3D12_RESOURCE_DESC textureResourceDesc{};
	textureResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	textureResourceDesc.Format = metadata.format;
	textureResourceDesc.Width = metadata.width;							//å¹…
	textureResourceDesc.Height = (UINT)metadata.height;				//é«˜ã•
	textureResourceDesc.DepthOrArraySize = (UINT16)metadata.arraySize;
	textureResourceDesc.MipLevels = (UINT16)metadata.mipLevels;
	textureResourceDesc.SampleDesc.Count = 1;

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device_->CreateCommittedResource(
		&textureHeapProp,
		D3D12_HEAP_FLAG_NONE,
		&textureResourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&texBuff_));
	assert(SUCCEEDED(result));

	for (size_t i = 0; i < metadata.mipLevels; i++)
	{
		//ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã‚’æŒ‡å®šã—ã¦ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’å–å¾—
		const Image* img = scratchImg.GetImage(i, 0, 0);
		//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
		result = texBuff_->WriteToSubresource(
			(UINT)i,
			nullptr,							//å…¨é ˜åŸŸã¸ã‚³ãƒ”ãƒ¼
			img->pixels,						//å…ƒãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ‰ãƒ¬ã‚¹
			(UINT)img->rowPitch,				//1ãƒ©ã‚¤ãƒ³ã‚µã‚¤ã‚º
			(UINT)img->slicePitch				//1æšã‚µã‚¤ã‚º
		);
		assert(SUCCEEDED(result));
	}


	//SRVãƒ’ãƒ¼ãƒ—ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	cpuDescHandleSRV_ = CD3DX12_CPU_DESCRIPTOR_HANDLE(descHeap_->GetCPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize_);
	gpuDescHandleSRV_ = CD3DX12_GPU_DESCRIPTOR_HANDLE(descHeap_->GetGPUDescriptorHandleForHeapStart(), 0, descriptorHandleIncrementSize_);

	//ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};				//è¨­å®šæ§‹é€ ä½“
	srvDesc.Format = textureResourceDesc.Format;
	srvDesc.Shader4ComponentMapping =
		D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;	//2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
	srvDesc.Texture2D.MipLevels = textureResourceDesc.MipLevels;

	//ãƒãƒ³ãƒ‰ãƒ«ã®æŒ‡ã™ä½ç½®ã«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ä½œæˆ
	device_->CreateShaderResourceView(texBuff_.Get(), &srvDesc, cpuDescHandleSRV_);

}

void Particle::CreateBuffers()
{
	HRESULT result = S_FALSE;

	std::vector<VertexPosScale> realVertices;

	UINT sizeVB = static_cast<UINT>(sizeof(vertices_));

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(sizeVB);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	result = device_->CreateCommittedResource(
		&heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&vertBuff_));
	assert(SUCCEEDED(result));

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPosScale* vertMap = nullptr;
	result = vertBuff_->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result)) {
		memcpy(vertMap, vertices_, sizeof(vertices_));
		vertBuff_->Unmap(0, nullptr);
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	vbView_.BufferLocation = vertBuff_->GetGPUVirtualAddress();
	vbView_.SizeInBytes = sizeof(vertices_);
	vbView_.StrideInBytes = sizeof(vertices_[0]);


}

void Particle::Update()
{
	HRESULT result;
	//å¯¿å‘½ãŒå°½ããŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å…¨å‰Šé™¤
	particles_.remove_if([](OneParticle& x) {return x.frame >= x.num_frame; });
	//å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
	for (std::forward_list<OneParticle>::iterator it = particles_.begin();
		it != particles_.end(); it++)
	{
		//çµŒéãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
		it->frame++;
		//é€Ÿåº¦ã«åŠ é€Ÿåº¦ã‚’åŠ ç®—
		it->velocity = it->velocity + it->accel;
		//é€Ÿåº¦ã«ã‚ˆã‚‹ç§»å‹•
		it->position = it->position + it->velocity;

		//é€²è¡Œåº¦ã‚’0~1ã®ç¯„å›²ã«æ›ç®—
		float f = (float)it->frame / it->num_frame;
		//ã‚¹ã‚±ãƒ¼ãƒ«ã®ç·šå½¢è£œé–“
		it->scale = (it->e_Scale - it->s_Scale) * f;
		it->scale += it->s_Scale;
	}
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPosScale* vertMap = nullptr;
	result = vertBuff_->Map(0, nullptr, (void**)&vertMap);
	if (SUCCEEDED(result))
	{
		//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æƒ…å ±ã‚’1ã¤ãšã¤åæ˜ 
		for (std::forward_list<OneParticle>::iterator it = particles_.begin();
			it != particles_.end(); it++)
		{
			//åº§æ¨™
			vertMap->pos = it->position;
			//ã‚¹ã‚±ãƒ¼ãƒ«
			vertMap->scale = it->scale;
			//æ¬¡ã®é ‚ç‚¹ã¸
			vertMap++;
		}
		vertBuff_->Unmap(0, nullptr);
	}

}

void Particle::Draw(ID3D12GraphicsCommandList* cmdList)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device_);
	assert(cmdList);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š
	cmdList->IASetVertexBuffers(0, 1, &vbView_);

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®é…åˆ—
	ID3D12DescriptorHeap* ppHeaps[] = { descHeap_.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootDescriptorTable(1, gpuDescHandleSRV_);

	// æç”»ã‚³ãƒãƒ³ãƒ‰
	cmdList->DrawInstanced((UINT)std::distance(particles_.begin(), particles_.end()), 1, 0, 0);

}

void Particle::Add(int life, XMFLOAT3 position, XMFLOAT3 velocity, XMFLOAT3 accel, float start_scale, float end_scale)
{
	//ãƒªã‚¹ãƒˆã«è¦ç´ ã‚’è¿½åŠ 
	particles_.emplace_front();
	//è¿½åŠ ã—ãŸè¦ç´ ã®å‚ç…§
	OneParticle& p = particles_.front();
	//å€¤ã‚»ãƒƒãƒˆ
	p.position = position;
	p.velocity = velocity;
	p.accel = accel;
	p.num_frame = life;

	p.s_Scale = start_scale;
	p.e_Scale = end_scale;
	p.scale = p.s_Scale;
}

const DirectX::XMFLOAT3 operator+(const DirectX::XMFLOAT3& lhs, const DirectX::XMFLOAT3& rhs)
{
	XMFLOAT3 result;

	result.x = lhs.x + rhs.x;
	result.y = lhs.y + rhs.y;
	result.z = lhs.z + rhs.z;
	return result;
}
</file_content>

<file_content path="engine/effect/Particle.h">
#pragma once
#include <d3d12.h>
#include <d3dx12.h>
#include <DirectXMath.h>
#include <wrl.h>
#include <forward_list>

class Particle
{
private://ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::ã‚’çœç•¥
	using XMFLOAT2 = DirectX::XMFLOAT2;
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMFLOAT4 = DirectX::XMFLOAT4;
	using XMMATRIX = DirectX::XMMATRIX;

public://ã‚µãƒ–ã‚¯ãƒ©ã‚¹

	struct VertexPosScale
	{
		XMFLOAT3 pos; // xyzåº§æ¨™
		float scale;  //ã‚¹ã‚±ãƒ¼ãƒ«
	};

	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ä¸€ç²’
	struct OneParticle
	{
		//DirectX::ã‚’çœç•¥
		using XMFLOAT3 = DirectX::XMFLOAT3;

		//åº§æ¨™
		XMFLOAT3 position = {};
		//é€Ÿåº¦
		XMFLOAT3 velocity = {};
		//åŠ é€Ÿåº¦
		XMFLOAT3 accel = {};
		//ç¾åœ¨ãƒ•ãƒ¬ãƒ¼ãƒ 
		int frame = 0;
		//çµ‚äº†ãƒ•ãƒ¬ãƒ¼ãƒ 
		int num_frame = 0;

		//ã‚¹ã‚±ãƒ¼ãƒ«
		float scale = 1.0f;
		//åˆæœŸå€¤
		float s_Scale = 1.0f;
		//æœ€çµ‚å€¤
		float e_Scale = 0.0f;
	};

private://å®šæ•°
	static const int vertexCount = 1024;		// é ‚ç‚¹æ•°

public://ãƒ¡ãƒ³ãƒé–¢æ•°

	//OBJãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
	static Particle* LoadParticleTexture(const std::string& fileName);
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®åˆæœŸåŒ–
	void InitializeDescriptorHeap();
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	void LoadTexture(const std::string& fileName);

	//å„ç¨®ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	void CreateBuffers();
	//æ›´æ–°
	void Update();
	// æç”»
	void Draw(ID3D12GraphicsCommandList* cmdList);

	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è¿½åŠ 
	void Add(int life, XMFLOAT3 position, XMFLOAT3 velocity, XMFLOAT3 accel,
		float start_scale, float end_scale);

private://ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ‡ãƒã‚¤ã‚¹
	static ID3D12Device* device_;
	//ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£æ ¼ç´ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
	static std::string defaultTextureDirectoryPath_;

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	UINT descriptorHandleIncrementSize_;
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descHeap_;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> texBuff_;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒ«(CPU)
	CD3DX12_CPU_DESCRIPTOR_HANDLE cpuDescHandleSRV_;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒ«(CPU)
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuDescHandleSRV_;
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> vertBuff_;
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vbView_;
	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿é…åˆ—
	VertexPosScale vertices_[vertexCount];

	std::forward_list<OneParticle> particles_;

public://setter
	//ãƒ‡ãƒã‚¤ã‚¹
	static void SetDevice(ID3D12Device* device) { Particle::device_ = device; }

};

const DirectX::XMFLOAT3 operator+(const DirectX::XMFLOAT3& lhs, const DirectX::XMFLOAT3& rhs);
</file_content>

<file_content path="engine/effect/ParticleManager.cpp">
#include "ParticleManager.h"
#include <d3dcompiler.h>
#pragma warning(push)
#pragma warning(disable:26813)
#include<DirectXTex.h>
#pragma warning(pop)

#pragma comment(lib, "d3dcompiler.lib")

using namespace DirectX;
using namespace Microsoft::WRL;

/// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®Ÿä½“
ID3D12Device* ParticleManager::device_ = nullptr;
ID3D12GraphicsCommandList* ParticleManager::cmdList = nullptr;
ComPtr<ID3D12RootSignature> ParticleManager::rootsignature;
ComPtr<ID3D12PipelineState> ParticleManager::pipelinestate;

void ParticleManager::StaticInitialize(ID3D12Device* device)
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device);

	device_ = device;

	Particle::SetDevice(device_);

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åˆæœŸåŒ–
	InitializeGraphicsPipeline();
}

void ParticleManager::PreDraw(ID3D12GraphicsCommandList* cmdList)
{
	// PreDrawã¨PostDrawãŒãƒšã‚¢ã§å‘¼ã°ã‚Œã¦ã„ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼
	assert(ParticleManager::cmdList == nullptr);

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ã‚»ãƒƒãƒˆ
	ParticleManager::cmdList = cmdList;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	cmdList->SetPipelineState(pipelinestate.Get());
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	cmdList->SetGraphicsRootSignature(rootsignature.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã‚’è¨­å®š
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_POINTLIST);
}

void ParticleManager::PostDraw()
{
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’è§£é™¤
	ParticleManager::cmdList = nullptr;
}

ParticleManager* ParticleManager::Create()
{
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	ParticleManager* object3d = new ParticleManager();
	if (object3d == nullptr) {
		return nullptr;
	}

	// åˆæœŸåŒ–
	if (!object3d->Initialize()) {
		delete object3d;
		assert(0);
		return nullptr;
	}

	return object3d;
}

void ParticleManager::InitializeGraphicsPipeline()
{
	HRESULT result = S_FALSE;
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> gsBlob; // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob;	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticleVS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticleGS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "gs_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚¯ç”¨è¨­å®š
		0,
		&gsBlob, &errorBlob
	);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "/n";
		//ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/shaders/ParticlePS.hlsl",	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0",	// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string errstr;
		errstr.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			errstr.begin());
		errstr += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(errstr.c_str());
		exit(1);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
		{//ã‚¹ã‚±ãƒ¼ãƒ«
			"TEXCOORD", 0, DXGI_FORMAT_R32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

	};

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æµã‚Œã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC gpipeline{};
	gpipeline.VS = CD3DX12_SHADER_BYTECODE(vsBlob.Get());
	gpipeline.GS = CD3DX12_SHADER_BYTECODE(gsBlob.Get());
	gpipeline.PS = CD3DX12_SHADER_BYTECODE(psBlob.Get());

	// ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¹ã‚¯
	gpipeline.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // æ¨™æº–è¨­å®š
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	//gpipeline.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
	//gpipeline.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
	// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ
	gpipeline.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	//ãƒ‡ãƒ—ã‚¹ã®æ›¸ãè¾¼ã¿ã‚’ç¦æ­¢
	gpipeline.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC blenddesc{};
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;	// RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»
	blenddesc.BlendEnable = true;
	//åŠé€æ˜åˆæˆ
	/*blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;*/

	//åŠ ç®—åˆæˆ
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlend = D3D12_BLEND_ONE;
	blenddesc.DestBlend = D3D12_BLEND_ONE;
	//æ¸›ç®—åˆæˆ
	/*blenddesc.BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
	blenddesc.SrcBlend = D3D12_BLEND_ONE;
	blenddesc.DestBlend = D3D12_BLEND_ONE;*/

	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	gpipeline.BlendState.RenderTarget[0] = blenddesc;

	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	gpipeline.DSVFormat = DXGI_FORMAT_D32_FLOAT;

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	gpipeline.InputLayout.pInputElementDescs = inputLayout;
	gpipeline.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®šï¼ˆä¸‰è§’å½¢ï¼‰
	gpipeline.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;

	gpipeline.NumRenderTargets = 1;	// æç”»å¯¾è±¡ã¯1ã¤
	gpipeline.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½255æŒ‡å®šã®RGBA
	gpipeline.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸
	CD3DX12_DESCRIPTOR_RANGE descRangeSRV;
	descRangeSRV.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); // t0 ãƒ¬ã‚¸ã‚¹ã‚¿

	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	#pragma warning(push)
	#pragma warning(disable:6001)
	CD3DX12_ROOT_PARAMETER rootparams[2];
	rootparams[0].InitAsConstantBufferView(0, 0, D3D12_SHADER_VISIBILITY_ALL);
	rootparams[1].InitAsDescriptorTable(1, &descRangeSRV, D3D12_SHADER_VISIBILITY_ALL);
	#pragma warning(pop)

	// ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	CD3DX12_STATIC_SAMPLER_DESC samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init_1_0(_countof(rootparams), rootparams, 1, &samplerDesc, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è‡ªå‹•åˆ¤å®šã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1_0, &rootSigBlob, &errorBlob);
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	result = device_->CreateRootSignature(0, rootSigBlob->GetBufferPointer(), rootSigBlob->GetBufferSize(), IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	gpipeline.pRootSignature = rootsignature.Get();

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	result = device_->CreateGraphicsPipelineState(&gpipeline, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));

}


bool ParticleManager::Initialize()
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device_);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDesc =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferData) + 0xff) & ~0xff);

	HRESULT result;

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device_->CreateCommittedResource(
		&heapProps, // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¯èƒ½
		D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));

	return true;
}

void ParticleManager::Update()
{

	HRESULT result;

	particle->Update();
	XMMATRIX matView = xmViewProjection->GetMatViewProjection();
	XMMATRIX matBillboard = xmViewProjection->GetMatBillboard();

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã¸ãƒ‡ãƒ¼ã‚¿è»¢é€
	ConstBufferData* constMap = nullptr;
	result = constBuff->Map(0, nullptr, (void**)&constMap);
	//è¡Œåˆ—ã®åˆæˆ
	constMap->mat = matView;
	constMap->matBillboard = matBillboard;
	constBuff->Unmap(0, nullptr);
}

void ParticleManager::Draw()
{
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(device_);
	assert(ParticleManager::cmdList);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootConstantBufferView(0, constBuff->GetGPUVirtualAddress());

	particle->Draw(cmdList);
}

void ParticleManager::Fire(Particle* particle, const float& setpos, const float& setvel, const float& setacc, const int& setnum, const XMFLOAT2& setscale)
{
	for (int i = 0; i < setnum; i++)
	{
		//X,Y,Zå…¨ã¦{-20.0f,20.0f}ã§ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†å¸ƒ
		const float md_pos = setpos;
		XMFLOAT3 pos{};
		pos.x = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		pos.y = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		pos.z = (float)rand() / RAND_MAX * md_pos - md_pos / 2.0f;
		//X,Y,Zå…¨ã¦{0.1f,0.1f}ã§ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†å¸ƒ
		const float md_vel = setvel;
		XMFLOAT3 vel{};
		vel.x = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		vel.y = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		vel.z = (float)rand() / RAND_MAX * md_vel - md_vel / 2.0f;
		//é‡åŠ›ã«è¦‹ç«‹ã¦ã¦Yã®ã¿{0.001f,0}ã§ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†å¸ƒ
		XMFLOAT3 acc{};
		const float md_acc = setacc;
		acc.y = -(float)rand() / RAND_MAX * md_acc;

		//è¿½åŠ 
		particle->Add(60, pos, vel, acc, setscale.x, setscale.y);
	}
}
</file_content>

<file_content path="engine/effect/ParticleManager.h">
#pragma once

#include "Particle.h"
#include "XMViewProjection.h"
#include <Windows.h>
#include <wrl.h>
#include <d3d12.h>
#include <DirectXMath.h>
#include <d3dx12.h>

/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
class ParticleManager
{
private: // ã‚¨ã‚¤ãƒªã‚¢ã‚¹
	// Microsoft::WRL::ã‚’çœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;
	// DirectX::ã‚’çœç•¥
	using XMFLOAT2 = DirectX::XMFLOAT2;
	using XMFLOAT3 = DirectX::XMFLOAT3;
	using XMFLOAT4 = DirectX::XMFLOAT4;
	using XMMATRIX = DirectX::XMMATRIX;

public: // ã‚µãƒ–ã‚¯ãƒ©ã‚¹
	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
	struct ConstBufferData
	{
		//XMFLOAT4 color;	// è‰² (RGBA)
		XMMATRIX mat;	// ï¼“ï¼¤å¤‰æ›è¡Œåˆ—
		XMMATRIX matBillboard;	//ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	};
public: // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	/// é™çš„åˆæœŸåŒ–
	static void StaticInitialize(ID3D12Device* device);

	/// æç”»å‰å‡¦ç†
	static void PreDraw(ID3D12GraphicsCommandList* cmdList);

	/// æç”»å¾Œå‡¦ç†
	static void PostDraw();

	/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	static ParticleManager* Create();

private: // é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ‡ãƒã‚¤ã‚¹
	static ID3D12Device* device_;
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	static ID3D12GraphicsCommandList* cmdList;
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	static ComPtr<ID3D12RootSignature> rootsignature;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	static ComPtr<ID3D12PipelineState> pipelinestate;

private:// é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°

	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	static void InitializeGraphicsPipeline();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	bool Initialize();
	/// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†
	void Update();

	/// æç”»
	void Draw();

	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºå°„
	void Fire(Particle* particle, const float& setpos, const float& setvel, const float& setacc, const int& setnum, const XMFLOAT2& setscale);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	ComPtr<ID3D12Resource> constBuff; // å®šæ•°ãƒãƒƒãƒ•ã‚¡
	//ã‚¹ã‚±ãƒ¼ãƒ«
	XMFLOAT3 scale = { 1,1,1 };

	//DirectXMathã‚’ä½¿ã£ãŸViewProjection
	XMViewProjection* xmViewProjection = nullptr;
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	Particle* particle = nullptr;

public://setter
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ¢ãƒ‡ãƒ«
	void SetParticleModel(Particle* particlemodel) { this->particle = particlemodel; }
	//ã‚«ãƒ¡ãƒ©
	void SetXMViewProjection(XMViewProjection* xmViewProjection) { this->xmViewProjection = xmViewProjection; }
};
</file_content>

<file_content path="engine/effect/PostEffect.cpp">
#include "PostEffect.h"
#include "WinApp.h"

const float PostEffect::clearColor[4] = { 0.25f,0.5f,0.1f,0.0f };

void PostEffect::Initialize(ID3D12Device* dev)
{
	device = dev;
	HRESULT result;

	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	VertexPosUv vertices[] = {
		{{	-1.0f, -1.0f,	0.0f},{0.0f,1.0f}},
		{{	-1.0f,	+1.0f,	0.0f},{0.0f,0.0f}},
		{{	+1.0f, -1.0f,	0.0f},{1.0f,1.0f}},
		{{	+1.0f,	+1.0f,	0.0f},{1.0f,0.0f}},
	};

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapPropsVertexBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDescVertexBuffer =
		CD3DX12_RESOURCE_DESC::Buffer(sizeof(vertices));

	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapPropsVertexBuffer, // ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&resourceDescVertexBuffer, // ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertBuff));
	assert(SUCCEEDED(result));

	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã¸ã®ãƒ‡ãƒ¼ã‚¿è»¢é€
	VertexPosUv* vertMap = nullptr;
	result = vertBuff->Map(0, nullptr, (void**)&vertMap);
	memcpy(vertMap, vertices, sizeof(vertices));
	vertBuff->Unmap(0, nullptr);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
// GPUä»®æƒ³ã‚¢ãƒ‰ãƒ¬ã‚¹
	vbView.BufferLocation = vertBuff->GetGPUVirtualAddress();
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚º
	vbView.SizeInBytes = sizeof(VertexPosUv) * 4;
	// é ‚ç‚¹1ã¤åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º
	vbView.StrideInBytes = sizeof(VertexPosUv);

	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapPropsConstantBuffer = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	// ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC resourceDescConstantBuffer =
		CD3DX12_RESOURCE_DESC::Buffer((sizeof(ConstBufferData) + 0xff) & ~0xff);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapPropsConstantBuffer, // ãƒ’ãƒ¼ãƒ—è¨­å®š
		D3D12_HEAP_FLAG_NONE,
		&resourceDescConstantBuffer, // ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&constBuff));
	assert(SUCCEEDED(result));

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
	ConstBufferData* constMap = nullptr;
	result = this->constBuff->Map(0, nullptr, (void**)&constMap); // ãƒãƒƒãƒ”ãƒ³ã‚°
	if (SUCCEEDED(result)) {
		constMap->color = this->color;
		constMap->mat = this->mat.identity();
		this->constBuff->Unmap(0, nullptr);
	}


	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC texresDesc = CD3DX12_RESOURCE_DESC::Tex2D(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
		WinApp::window_width, (UINT)WinApp::window_height,
		1, 0, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);
	// ãƒ’ãƒ¼ãƒ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
	CD3DX12_HEAP_PROPERTIES heapPropsTex = CD3DX12_HEAP_PROPERTIES(D3D12_CPU_PAGE_PROPERTY_WRITE_BACK, D3D12_MEMORY_POOL_L0);
	CD3DX12_CLEAR_VALUE valTex = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, clearColor);

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	result = device->CreateCommittedResource(
		&heapPropsTex, D3D12_HEAP_FLAG_NONE,
		&texresDesc, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		&valTex, IID_PPV_ARGS(&texBuff));
	assert(SUCCEEDED(result));

	const UINT pixelCount = WinApp::window_width * WinApp::window_height;
	const UINT rowPitch = sizeof(UINT) * WinApp::window_width;
	const UINT depthPitch = rowPitch * WinApp::window_height;
	//ç”»åƒã‚¤ãƒ¡ãƒ¼ã‚¸
	UINT* img = new UINT[pixelCount];
	for (int i = 0; i < pixelCount; i++) {
		img[i] = 0xff0000ff;
	}
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡ã«ãƒ‡ãƒ¼ã‚¿è»¢é€
	result = texBuff->WriteToSubresource(0, nullptr, img, rowPitch, depthPitch);
	assert(SUCCEEDED(result));
	delete[] img;
	//SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC srvDescHeapDesc = {};
	srvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	srvDescHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	srvDescHeapDesc.NumDescriptors = 1;
	//SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ
	result = device->CreateDescriptorHeap(&srvDescHeapDesc, IID_PPV_ARGS(&descHeapSRV));
	assert(SUCCEEDED(result));
	//SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;
	//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã«SRVä½œæˆ
	device->CreateShaderResourceView(texBuff.Get(), &srvDesc, descHeapSRV->GetCPUDescriptorHandleForHeapStart());
	
	//RTVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC rtvDescHeapDesc{};
	rtvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvDescHeapDesc.NumDescriptors = 1;
	//RTVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ
	result = device->CreateDescriptorHeap(&rtvDescHeapDesc, IID_PPV_ARGS(&descHeapRTV));
	assert(SUCCEEDED(result));
	//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
	D3D12_RENDER_TARGET_VIEW_DESC renderTargetViewDesc{};
	//ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨ˆç®—çµæœã‚’SRGBã«å¤‰æ›ã—ã¦æ›¸ãè¾¼ã‚€
	renderTargetViewDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	renderTargetViewDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
	//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã«RTVã‚’ä½œæˆ
	device->CreateRenderTargetView(texBuff.Get(), &renderTargetViewDesc, descHeapRTV->GetCPUDescriptorHandleForHeapStart());

	//æ·±åº¦ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹è¨­å®š
	CD3DX12_RESOURCE_DESC depthResDesc =
		CD3DX12_RESOURCE_DESC::Tex2D(
			DXGI_FORMAT_D32_FLOAT, WinApp::window_width, WinApp::window_height,
			1, 0, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL
		);

	CD3DX12_CLEAR_VALUE valDepth = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_D32_FLOAT, 1.0f, 0);
	//æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	CD3DX12_HEAP_PROPERTIES heapPropsDepth = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
	result = device->CreateCommittedResource(&heapPropsDepth, D3D12_HEAP_FLAG_NONE,
		&depthResDesc, D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&valDepth,
		IID_PPV_ARGS(&depthBuff));
	assert(SUCCEEDED(result));

	//DSVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC DescHeapDesc{};
	DescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	DescHeapDesc.NumDescriptors = 1;

	//DSVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ä½œæˆ
	result = device->CreateDescriptorHeap(&DescHeapDesc, IID_PPV_ARGS(&descHeapDSV));
	//ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã«DSVä½œæˆ
	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
	dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	device->CreateDepthStencilView(depthBuff.Get(), &dsvDesc, descHeapDSV->GetCPUDescriptorHandleForHeapStart());
	
	CreateGraphicsPipelineState();

}

void PostEffect::Draw(ID3D12GraphicsCommandList* cmdList_)
{
	this->cmdList = cmdList_;
	 
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®šã‚³ãƒãƒ³ãƒ‰
	cmdList->SetPipelineState(pipelinestate.Get());
	cmdList->SetGraphicsRootSignature(rootsignature.Get());

	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å½¢çŠ¶ã®è¨­å®šã‚³ãƒãƒ³ãƒ‰
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP); // ä¸‰è§’å½¢ãƒªã‚¹ãƒˆ

	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
	ID3D12DescriptorHeap* ppHeaps[] = { descHeapSRV.Get() };
	cmdList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®è¨­å®šã‚³ãƒãƒ³ãƒ‰
	cmdList->IASetVertexBuffers(0, 1, &vbView);

	// å®šæ•°ãƒãƒƒãƒ•ã‚¡(CBV)ã®è¨­å®šã‚³ãƒãƒ³ãƒ‰
	cmdList->SetGraphicsRootConstantBufferView(0, constBuff->GetGPUVirtualAddress());

	//ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootDescriptorTable(
		1, descHeapSRV->GetGPUDescriptorHandleForHeapStart());

	//ãƒãƒªã‚´ãƒ³ã®æç”»
	cmdList->DrawInstanced(4, 1, 0, 0);
}

void PostEffect::PreDrawScene(ID3D12GraphicsCommandList* cmdList_)
{
	CD3DX12_RESOURCE_BARRIER rb = CD3DX12_RESOURCE_BARRIER::Transition(texBuff.Get(),
		D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
		D3D12_RESOURCE_STATE_RENDER_TARGET);
	cmdList_->ResourceBarrier(1, &rb);

	//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE rtvH =
		descHeapRTV->GetCPUDescriptorHandleForHeapStart();
	//æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE dsvH =
		descHeapDSV->GetCPUDescriptorHandleForHeapStart();
	//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚»ãƒƒãƒˆ
	cmdList_->OMSetRenderTargets(1, &rtvH, false, &dsvH);
	//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®è¨­å®š
	CD3DX12_VIEWPORT vp = CD3DX12_VIEWPORT(0.0f, 0.0f, WinApp::window_width, WinApp::window_height);
	cmdList_->RSSetViewports(1, &vp);
	//å…¨ç”»é¢ã‚¯ãƒªã‚¢
	cmdList_->ClearRenderTargetView(rtvH, clearColor, 0, nullptr);
	cmdList_->ClearDepthStencilView(dsvH, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
}

void PostEffect::PostDrawScene(ID3D12GraphicsCommandList* cmdList_)
{
	//ãƒªã‚½ãƒ¼ã‚¹ãƒãƒªã‚¢ã‚’å¤‰æ›´(æç”»å¯èƒ½->ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹)
	CD3DX12_RESOURCE_BARRIER rb = CD3DX12_RESOURCE_BARRIER::Transition(texBuff.Get(),
		D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
	cmdList_->ResourceBarrier(1, &rb);
}

void PostEffect::CreateGraphicsPipelineState()
{
	HRESULT result;
	//ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
	ComPtr<ID3DBlob> vsBlob; // é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> psBlob; // ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	ComPtr<ID3DBlob> errorBlob; // ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/PostEffectVS.hlsl", // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "vs_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&vsBlob, &errorBlob);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã®èª­ã¿è¾¼ã¿ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	result = D3DCompileFromFile(
		L"Resources/Shaders/PostEffectPS.hlsl",   // ã‚·ã‚§ãƒ¼ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«å
		nullptr,
		D3D_COMPILE_STANDARD_FILE_INCLUDE, // ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰å¯èƒ½ã«ã™ã‚‹
		"main", "ps_5_0", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆåã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«æŒ‡å®š
		D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION, // ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
		0,
		&psBlob, &errorBlob);

	// ã‚¨ãƒ©ãƒ¼ãªã‚‰
	if (FAILED(result)) {
		// errorBlobã‹ã‚‰ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’stringå‹ã«ã‚³ãƒ”ãƒ¼
		std::string error;
		error.resize(errorBlob->GetBufferSize());

		std::copy_n((char*)errorBlob->GetBufferPointer(),
			errorBlob->GetBufferSize(),
			error.begin());
		error += "\n";
		// ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«è¡¨ç¤º
		OutputDebugStringA(error.c_str());
		assert(0);
	}

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputLayout[] = {
		{ // xyzåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},

		{ // uvåº§æ¨™(1è¡Œã§æ›¸ã„ãŸã»ã†ãŒè¦‹ã‚„ã™ã„)
			"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0,
			D3D12_APPEND_ALIGNED_ELEMENT,
			D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0
		},
	};

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸ã®è¨­å®š
	CD3DX12_DESCRIPTOR_RANGE descriptorRange{};
	descriptorRange.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);

	CD3DX12_ROOT_PARAMETER rootParams[2];
	rootParams[0].InitAsConstantBufferView(0);
	rootParams[1].InitAsDescriptorTable(1, &descriptorRange, D3D12_SHADER_VISIBILITY_ALL);

	// ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ³ãƒ—ãƒ©ãƒ¼ã®è¨­å®š
	D3D12_STATIC_SAMPLER_DESC samplerDesc{};
	samplerDesc.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //æ¨ªç¹°ã‚Šè¿”ã—ï¼ˆã‚¿ã‚¤ãƒªãƒ³ã‚°ï¼‰
	samplerDesc.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP; //ç¸¦ç¹°ã‚Šè¿”ã—ï¼ˆã‚¿ã‚¤ãƒªãƒ³ã‚°ï¼‰
	samplerDesc.AddressW = D3D12_TEXTURE_ADDRESS_MODE_BORDER; //å¥¥è¡Œç¹°ã‚Šè¿”ã—ï¼ˆã‚¿ã‚¤ãƒªãƒ³ã‚°ï¼‰
	samplerDesc.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK; //ãƒœãƒ¼ãƒ€ãƒ¼ã®æ™‚ã¯é»’
	samplerDesc.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; //å…¨ã¦ãƒªãƒ‹ã‚¢è£œé–“
	samplerDesc.MaxLOD = D3D12_FLOAT32_MAX; //ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—æœ€å¤§å€¤
	samplerDesc.MinLOD = 0.0f; //ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—æœ€å°å€¤
	samplerDesc.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	samplerDesc.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; //ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰ã®ã¿ä½¿ç”¨å¯èƒ½

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineDesc{};

	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	pipelineDesc.VS.pShaderBytecode = vsBlob->GetBufferPointer();
	pipelineDesc.VS.BytecodeLength = vsBlob->GetBufferSize();
	pipelineDesc.PS.pShaderBytecode = psBlob->GetBufferPointer();
	pipelineDesc.PS.BytecodeLength = psBlob->GetBufferSize();

	// ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¹ã‚¯ã®è¨­å®š
	pipelineDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK; // æ¨™æº–è¨­å®š

	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;  // ã‚«ãƒªãƒ³ã‚°ã—ãªã„
	//pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID; // ãƒãƒªã‚´ãƒ³å†…å¡—ã‚Šã¤ã¶ã—
	//pipelineDesc.RasterizerState.DepthClipEnable = true; // æ·±åº¦ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰è¨­å®š
	D3D12_RENDER_TARGET_BLEND_DESC& blenddesc = pipelineDesc.BlendState.RenderTarget[0];
	blenddesc.RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; // RBGAå…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æç”»

	blenddesc.BlendEnable = true;                   // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚’æœ‰åŠ¹ã«ã™ã‚‹
	blenddesc.BlendOpAlpha = D3D12_BLEND_OP_ADD;    // åŠ ç®—
	blenddesc.SrcBlendAlpha = D3D12_BLEND_ONE;      // ã‚½ãƒ¼ã‚¹ã®å€¤ã‚’100% ä½¿ã†
	blenddesc.DestBlendAlpha = D3D12_BLEND_ZERO;    // ãƒ‡ã‚¹ãƒˆã®å€¤ã‚’  0% ä½¿ã†

	// åŠé€æ˜åˆæˆ
	blenddesc.BlendOp = D3D12_BLEND_OP_ADD;             // åŠ ç®—
	blenddesc.SrcBlend = D3D12_BLEND_SRC_ALPHA;         // ã‚½ãƒ¼ã‚¹ã®ã‚¢ãƒ«ãƒ•ã‚¡å€¤
	blenddesc.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;    // 1.0f-ã‚½ãƒ¼ã‚¹ã®ã‚¢ãƒ«ãƒ•ã‚¡å€¤

	// é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	pipelineDesc.InputLayout.pInputElementDescs = inputLayout;
	pipelineDesc.InputLayout.NumElements = _countof(inputLayout);

	// å›³å½¢ã®å½¢çŠ¶è¨­å®š
	pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	// ãã®ä»–ã®è¨­å®š
	pipelineDesc.NumRenderTargets = 1; // æç”»å¯¾è±¡ã¯1ã¤
	pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB; // 0ï½255æŒ‡å®šã®RGBA
	pipelineDesc.SampleDesc.Count = 1; // 1ãƒ”ã‚¯ã‚»ãƒ«ã«ã¤ã1å›ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

	//ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS; // å¸¸ã«ä¸Šæ›¸ããƒ«ãƒ¼ãƒ«

	pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);
	pipelineDesc.DepthStencilState.DepthEnable = false;

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨­å®š
	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
	rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	rootSignatureDesc.pParameters = rootParams; //ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹
	rootSignatureDesc.NumParameters = _countof(rootParams);        //ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ•°

	rootSignatureDesc.pStaticSamplers = &samplerDesc;
	rootSignatureDesc.NumStaticSamplers = 1;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚»ãƒƒãƒˆ

	ComPtr<ID3DBlob> rootSigBlob;
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è‡ªå‹•åˆ¤å®šã§ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
	result = D3D12SerializeRootSignature(
		&rootSignatureDesc,
		D3D_ROOT_SIGNATURE_VERSION_1_0,
		&rootSigBlob,
		&errorBlob);
	assert(SUCCEEDED(result));
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	result = device->CreateRootSignature(
		0,
		rootSigBlob->GetBufferPointer(),
		rootSigBlob->GetBufferSize(),
		IID_PPV_ARGS(&rootsignature));
	assert(SUCCEEDED(result));

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	pipelineDesc.pRootSignature = rootsignature.Get();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	result = device->CreateGraphicsPipelineState(&pipelineDesc, IID_PPV_ARGS(&pipelinestate));
	assert(SUCCEEDED(result));
}

</file_content>

<file_content path="engine/effect/PostEffect.h">
#pragma once
#include <Windows.h>
#include <D3dx12.h>
#include <d3dcompiler.h>
#include <cassert>
#include <DirectXTex.h>
#include <wrl.h>
#include <array>
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include"Matrix4.h"

#include "DirectXCommon.h"

#pragma comment(lib, "d3dcompiler.lib")

struct VertexPosUv {
	Vector3 pos;
	Vector2 uv;
};
class PostEffect
{
public:
	//åˆæœŸåŒ–
	void Initialize(ID3D12Device* dev);
	//æç”»
	void Draw(ID3D12GraphicsCommandList* cmdList_);
	//æç”»å‰å¾Œ
	void PreDrawScene(ID3D12GraphicsCommandList* cmdList_);
	void PostDrawScene(ID3D12GraphicsCommandList* cmdList_);
	//ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆ
	void CreateGraphicsPipelineState();


private:
	static const float clearColor[4];

private:
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> texBuff;
	//æ·±åº¦ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> depthBuff;
	//SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descHeapSRV;
	//RTVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descHeapRTV;
	//DSVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descHeapDSV;
	//ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	ComPtr<ID3D12RootSignature> rootsignature;
	//ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
	ComPtr<ID3D12PipelineState> pipelinestate;
	//cmdList
	ComPtr<ID3D12GraphicsCommandList> cmdList;
	//Device
	ComPtr<ID3D12Device> device;
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> vertBuff;
	//é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	//å®šæ•°ãƒãƒƒãƒ•ã‚¡
	ComPtr<ID3D12Resource> constBuff;
	//å®šæ•°ãƒãƒƒãƒ•ã‚¡ç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
	struct ConstBufferData {
		Vector4 color; // è‰² (RGBA)
		Matrix4 mat; //åº§æ¨™
	};
	Vector4 color = { 1,1,1,1 }; // è‰² (RGBA)
	Matrix4 mat; //åº§æ¨™
};


</file_content>

<file_content path="engine/math/Matrix4.cpp">
// ========================
// Matrix4 å‹ Matrix4.cpp
// ========================
#include "Matrix4.h"
#include "Vector3.h"
#include <cmath> // sin cos

const float EPSILON = 0.000001f;

Matrix4::Matrix4()
{
	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};
	// ä»£å…¥
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}
}

// ä»£å…¥
Matrix4::Matrix4(float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33)
{
	m[0][0] = m00, m[0][1] = m01, m[0][2] = m02, m[0][3] = m03,
		m[1][0] = m10, m[1][1] = m11, m[1][2] = m12, m[1][3] = m13,
		m[2][0] = m20, m[2][1] = m21, m[2][2] = m22, m[2][3] = m23,
		m[3][0] = m30, m[3][1] = m31, m[3][2] = m32, m[3][3] = m33;

}

// å˜ä½è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
Matrix4 Matrix4::identity()
{
	static const Matrix4 result
	{
		1.0f, 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f, 0.0f, 0.0f,
		0.0f, 0.0f, 1.0f, 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	};

	return result;
}

// é€†è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
Matrix4 Matrix4::MakeInverse()
{
	Matrix4 temp;
	float mat[4][8] = { 0 };

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			mat[i][j] = m[i][j];
		}
	}

	mat[0][4] = 1;
	mat[1][5] = 1;
	mat[2][6] = 1;
	mat[3][7] = 1;

	for (int n = 0; n < 4; n++) {
		//æœ€å¤§ã®çµ¶å¯¾å€¤ã‚’æ¢ç´¢ã™ã‚‹(ã¨ã‚Šã‚ãˆãšå¯¾è±¡æˆåˆ†ã‚’æœ€å¤§ã¨ä»®å®šã—ã¦ãŠã)
		float max = abs(mat[n][n]);
		int maxIndex = n;

		for (int i = n + 1; i < 4; i++) {
			if (abs(mat[i][n]) > max) {
				max = abs(mat[i][n]);
				maxIndex = i;
			}
		}

		float a = abs(mat[maxIndex][n]);
		//æœ€å¤§ã®çµ¶å¯¾å€¤ãŒ0ã ã£ãŸã‚‰é€†è¡Œåˆ—ã¯æ±‚ã‚ã‚‰ã‚Œãªã„
		if (abs(mat[maxIndex][n]) <= EPSILON) {
			return temp; //ã¨ã‚Šã‚ãˆãšå˜ä½è¡Œåˆ—è¿”ã—ã¡ã‚ƒã†
		}

		//å…¥ã‚Œæ›¿ãˆ
		if (n != maxIndex) {
			for (int i = 0; i < 8; i++) {
				float f = mat[maxIndex][i];
				mat[maxIndex][i] = mat[n][i];
				mat[n][i] = f;
			}
		}

		//æ›ã‘ãŸã‚‰1ã«ãªã‚‹å€¤ã‚’ç®—å‡º
		float mul = 1 / mat[n][n];

		//æ›ã‘ã‚‹
		for (int i = 0; i < 8; i++) {
			mat[n][i] *= mul;
		}

		//ä»–å…¨éƒ¨0ã«ã™ã‚‹
		for (int i = 0; i < 4; i++) {
			if (n == i) {
				continue;
			}

			float mul = -mat[i][n];

			for (int j = 0; j < 8; j++) {
				mat[i][j] += mat[n][j] * mul;
			}
		}
	}

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++)
		{
			temp.m[i][j] = mat[i][j + 4];
		}
	}

	*this = temp;

	return *this;
}

// æ‹¡å¤§ç¸®å°è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
Matrix4 Matrix4::scale(const Vector3& s) {
	float result[4][4]
	{
		s.x ,0.0f,0.0f,0.0f,
		0.0f,s.y ,0.0f,0.0f,
		0.0f,0.0f,s.z ,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ä»£å…¥
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// xè»¸ã¾ã‚ã‚Šã®å›è»¢è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
Matrix4 Matrix4::rotateX(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f, cos, sin,0.0f,
		0.0f,-sin, cos,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ä»£å…¥
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// yè»¸ã¾ã‚ã‚Šã®å›è»¢è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
Matrix4 Matrix4::rotateY(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		cos ,0.0f,-sin,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		sin ,0.0f, cos,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ä»£å…¥
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// zè»¸ã¾ã‚ã‚Šã®å›è»¢ã®è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
Matrix4 Matrix4::rotateZ(float angle)
{
	float sin = std::sin(angle);
	float cos = std::cos(angle);

	float result[4][4]
	{
		cos , sin,0.0f,0.0f,
		-sin, cos,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		0.0f,0.0f,0.0f,1.0f
	};

	// ä»£å…¥
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// å¹³è¡Œç§»å‹•è¡Œåˆ—ã®è¨­å®š
Matrix4 Matrix4::translate(const Vector3& t)
{
	float result[4][4]
	{
		1.0f,0.0f,0.0f,0.0f,
		0.0f,1.0f,0.0f,0.0f,
		0.0f,0.0f,1.0f,0.0f,
		t.x ,t.y ,t.z ,1.0f
	};

	// ä»£å…¥
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result[i][j];
		}
	}

	return *this;
}

// åº§æ¨™å¤‰æ›ï¼ˆãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®æ›ã‘ç®—ï¼‰ã‚’è¡Œã†transformé–¢æ•°ã‚’ä½œæˆã™ã‚‹ã€‚ã€€ï¼ˆé€è¦–å¤‰æ›ã«ã‚‚å¯¾å¿œã—ã¦ã„ã‚‹ï¼‰
Vector3 Matrix4::transform(const Vector3& v, const Matrix4& m)
{
	float w = v.x * m.m[0][3] + v.y * m.m[1][3] + v.z * m.m[2][3] + m.m[3][3];

	Vector3 result
	{
		(v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0] + m.m[3][0]) / w,
		(v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1] + m.m[3][1]) / w,
		(v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2] + m.m[3][2]) / w
	};

	return result;
}

// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®ä½œæˆ
Matrix4 Matrix4::ViewMat(Vector3 eye, Vector3 target, Vector3 up)
{
	Vector3 zaxis = target - eye;
	zaxis.normalize();
	Vector3 xaxis = up.cross(zaxis);
	xaxis.normalize();
	Vector3 yaxis = zaxis.cross(xaxis);
	yaxis.normalize();

	Matrix4 LookAt = {
		xaxis.x,	xaxis.y,	xaxis.z,	0,
		yaxis.x,	yaxis.y,	yaxis.z,	0,
		zaxis.x,	zaxis.y,	zaxis.z,	0,
		eye.x,		eye.y,		eye.z,		1
	};

	LookAt.MakeInverse();

	*this = LookAt;

	return *this;
}

// å°„å½±è¡Œåˆ—ã®ä½œæˆ
Matrix4 Matrix4::ProjectionMat(float fovAngleY, float aspectRatio, float nearZ, float farZ)
{
	float h = 1 / tanf(fovAngleY / 2);
	float w = h / aspectRatio;
	float a = farZ / (farZ - nearZ);
	float b = (-nearZ * farZ) / (farZ - nearZ);

	Matrix4 perspectiveFovLH = {
		w,		 0,		 0,		 0,
		0,		 h,		 0,		 0,
		0,		 0,		 a,		 1,
		0,		 0,		 b,		 0
	};

	*this = perspectiveFovLH;

	return *this;
}

Matrix4 Matrix4::ViewPortMat(float width, float height, Vector2 offset)
{
	float w = width / 2;
	float h = height / 2;
	float a = width / 2 + offset.x;
	float b = height / 2 + offset.y;

	Matrix4 projectiveTlansformationLH = {
		w,		 0,		 0,		 0,
		0,		 -h,		 0,		 0,
		0,		 0,		 1,		 0,
		a,		 b,		 0,		 1
	};

	*this = projectiveTlansformationLH;

	return *this;
}

// ä»£å…¥æ¼”ç®—å­ã€€*=ã€€ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰é–¢æ•°ï¼ˆè¡Œåˆ—ã¨è¡Œåˆ—ã®ç©ï¼‰
Matrix4& Matrix4::operator*=(const Matrix4& m1)
{
	Matrix4 result;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			float Total = 0.0f;
			for (int k = 0; k < 4; k++) {
				Total += m[i][k] * m1.m[k][j];
			}
			result.m[i][j] = Total;
		}
	}

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] = result.m[i][j];
		}
	}

	return *this;
}

// ï¼’é …æ¼”ç®—å­ã€€*ã€€ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰é–¢æ•°ï¼ˆè¡Œåˆ—ã¨è¡Œåˆ—ã®ç©ï¼‰
Matrix4 Matrix4::operator*(const Matrix4& m1)
{
	return *this *= m1;
}

// ï¼’é …æ¼”ç®—å­ã€€*ã€€ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰é–¢æ•°ï¼ˆãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®ç©ï¼‰
Vector3 operator*(const Vector3& v, const Matrix4& m)
{
	float W = v.x * m.m[0][3] + v.y * m.m[1][3] + v.z * m.m[2][3] + m.m[3][3];
	Vector3 result
	{
		(v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0] + m.m[3][0]) / W,
		(v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1] + m.m[3][1]) / W,
		(v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2] + m.m[3][2]) / W
	};
	return result;
}

float Matrix4::ConvertToRadian(float rad) {
	return rad * ((float)3.141592 / 180);
}
</file_content>

<file_content path="engine/math/Matrix4.h">
// ===============================
// Matrix4 å‹ Matrix4.h
// ===============================
#pragma once

#include "Vector3.h"
#include "Vector2.h"

class Matrix4
{
public:

	// Matrix4 æ§‹é€ ä½“
	float m[4][4];


	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Matrix4();
	// æˆåˆ†ã‚’æŒ‡å®šã—ã¦ã®ç”Ÿæˆ
	Matrix4(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33);

	// å˜ä½è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
	static Matrix4 identity();

	// é€†è¡Œåˆ—ã‚’æ±‚ã‚ã‚‹
	Matrix4 MakeInverse();

	// æ‹¡å¤§ç¸®å°è¡Œåˆ—ã®è¨­å®š
	Matrix4 scale(const Vector3& s);

	// å›è»¢è¡Œåˆ—ã®è¨­å®š
	Matrix4 rotateX(float angle);
	Matrix4 rotateY(float angle);
	Matrix4 rotateZ(float angle);

	// å¹³è¡Œç§»å‹•è¡Œåˆ—ã®ä½œæˆ
	Matrix4 translate(const Vector3& t);

	// åº§æ¨™å¤‰æ›ï¼ˆãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®æ›ã‘ç®—ã‚’ã™ã‚‹ï¼‰
	Vector3 transform(const Vector3& v, const Matrix4& m);

	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ä½œæˆ
	Matrix4 ViewMat(Vector3 eye, Vector3 target, Vector3 up);

	// å°„å½±è¡Œåˆ—ä½œæˆ
	Matrix4 ProjectionMat(float fovAngleY, float aspectRatio, float nearZ, float farZ);
	Matrix4 ViewPortMat(float width, float height, Vector2 offset);

	// ä»£å…¥æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Matrix4& operator*=(const Matrix4& m1);

	Matrix4 operator*(const Matrix4& m1);

	static float ConvertToRadian(float rad);

};

	// 2é …æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Vector3 operator*(const Vector3& v, const Matrix4& m);


</file_content>

<file_content path="engine/math/Spline.cpp">
#include "Spline.h"
#include <windows.h>
#include <sysinfoapi.h>

void Spline::Initialize() {
	isEnd = false;
	t = 0.0f;
}

Vector3 Spline::Update(std::vector<Vector3>& points, float val) {

	t = t + val;

	//timeRateãŒ1.0fä»¥ä¸Šã«ãªã£ãŸã‚‰ã€æ¬¡ã®åŒºé–“ã«é€²ã‚€
	if (t >= 1.0f) {
		if (startIndex < points.size() - 3) {

			startIndex++;

			t -= 1.0f;
			integer += 1.0f;
		}
		else {
			isEnd = true;
			t = 1.0f;
		}
	}

	Vector3 pos = SplinePosition(points, startIndex, t);

	t += (float)0.002;
	//float integer = (float)floor(val);
	//float few = (float)fmod(val, 1);

	//Vector3 pos = SplinePosition(points, (size_t)integer, few);

	//if (integer >= (float)points.size() - 3.0f) {
	//	isEnd = true;
	//}
	
	return pos;
}

Vector3 Spline::EnemyPosition(std::vector<Vector3>& points, float val)
{
	float integer = (float)floor(val);
	float few = (float)fmod(val, 1);

	Vector3 pos = SplinePosition(points, (size_t)integer, few);

	return pos;
}

Vector3 Spline::pointCal(std::vector<Vector3>& points) {

	const int INDEXMAX = (int)points.size() - 1;

	float nowPoint = (float)startIndex / (float)INDEXMAX;

	Vector3 pos = SplinePosition(points, startIndex, t);

	if (t >= 1) {
		startIndex++;
		t = 0;
	}
	else {
		t += 0.01f;
	}

	return pos;
}

void Spline::Reset()
{			 
	t = 0;
	integer = 0;
	startIndex = 1;
}

Vector3 Spline::SplinePosition(const std::vector<Vector3>& points, size_t startIndex, float t) {
	//è£œé–“ã™ã¹ãç‚¹
	size_t n = points.size() - 2;

	if (startIndex > n) return points[n];
	if (startIndex < 1) return points[1];

	//p0~p3ã®åˆ¶å¾¡ç‚¹ã‚’å–å¾—ã™ã‚‹
	Vector3 p0_ = points[startIndex - 1];
	Vector3 p1_ = points[startIndex];
	Vector3 p2_ = points[startIndex + 1];
	Vector3 p3_ = points[startIndex + 2];

	//Catmull-Rom ã®å¼ã«ã‚ˆã‚‹è£œé–“
	Vector3 position = 0.5 * (p1_ * 2 + (-p0_ + p2_) *
							  t + (p0_ * 2 - p1_ * 5 + p2_ * 4 - p3_) *
							  (t * t) + (-p0_ + p1_ * 3 - p2_ * 3 + p3_) *
							  (t * t * t));

	return position;
}
</file_content>

<file_content path="engine/math/Spline.h">
#pragma once

#include "Vector3.h"
#include <Vector>

class Spline 
{
public:
	//åˆæœŸåŒ–
	void Initialize();

	//æ›´æ–°
	Vector3 Update(std::vector<Vector3>& points,float val);

	Vector3 EnemyPosition(std::vector<Vector3>& points, float val);

	//æ›´æ–°
	Vector3 pointCal(std::vector<Vector3>& points);

	void Reset();

	//åˆ¶å¾¡ç‚¹ã®é›†åˆ(vectorã‚³ãƒ³ãƒ†ãƒŠ)ã€è£œé–“ã™ã‚‹åŒºé–“ã®æ·»å­—ã€æ™‚é–“çµŒéç‡
	Vector3 SplinePosition(const std::vector<Vector3>& point, size_t startIndex, float t);

	bool GetIsEnd() { return isEnd; }
	float GetT() { return t + integer; }

private:
	//P1ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹
	size_t startIndex = 1;
	bool isEnd = false;
	float t = 0;
	float integer = 0;


	//çƒã®ä½ç½®
	Vector3 position;
};
</file_content>

<file_content path="engine/math/Vector2.cpp">
#include "Vector2.h"
#include <cmath>      // sqrt

Vector2::Vector2()
	:x(0) , y(0)
{
}

Vector2::Vector2(float x,float y)
	:x(x) , y(y)
{
}

float Vector2::length() const
{
	return sqrt(x * x + y * y);
}

Vector2& Vector2::normalize()
{
	float len = length();
	if (len != 0)
	{
		return *this /= len;
	}
	return *this;
}

float Vector2::dot(const Vector2& v) const
{
	return x * v.x + y * v.y;
}

float Vector2::cross(const Vector2& v) const
{
	return x * v.y - y * v.x;
}

Vector2 Vector2::operator+() const
{
	return *this;
}

Vector2 Vector2::operator-() const
{
	return Vector2(-x, -y);
}

Vector2& Vector2::operator+=(const Vector2& v)
{
	x += v.x;
	y += v.y;
	return *this;
}

Vector2& Vector2::operator-=(const Vector2& v)
{
	x -= v.x;
	y -= v.y;
	return *this;
}

Vector2& Vector2::operator*=(float s)
{
	x *= s;
	y *= s;
	return *this;
}

Vector2& Vector2::operator/=(float s)
{
	x /= s;
	y /= s;
	return *this;
}

// Vector2 ã‚¯ãƒ©ã‚¹ã«å±ã•ãªã„é–¢æ•°ç¾¤
// äºŒé …æ¼”ç®—å­
const Vector2 operator+(const Vector2& v1, const Vector2& v2)
{
	Vector2 temp(v1);
	return temp += v2;
}

const Vector2 operator-(const Vector2& v1, const Vector2& v2)
{
	Vector2 temp(v1);
	return temp -= v2;
}

const Vector2 operator*(const Vector2& v, float s)
{
	Vector2 temp(v);
	return temp *= s;
}

const Vector2 operator*(float s, const Vector2& v)
{
	return v * s;
}

const Vector2 operator/(const Vector2& v, float s)
{
	Vector2 temp(v);
	return temp /= s;
}
</file_content>

<file_content path="engine/math/Vector2.h">
#pragma once
class Vector2
{
public:
	float x; // xæˆåˆ†
	float y; // yæˆåˆ†

public:
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Vector2();                  // é›¶ãƒ™ã‚¯ãƒˆãƒ«ã¨ã—ã¦ç”Ÿæˆ
	Vector2(float x, float y);  // xæˆåˆ† , yæˆåˆ†ã‚’æŒ‡å®šã—ã¦ã®ç”Ÿæˆ

	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	float length() const;
	Vector2& normalize();
	float dot(const Vector2& v) const;
	float cross(const Vector2& v)const;

	// å˜é …æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Vector2 operator+() const;
	Vector2 operator-() const;

	// ä»£å…¥æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Vector2& operator+=(const Vector2& v);
	Vector2& operator-=(const Vector2& v);
	Vector2& operator*=(float s);
	Vector2& operator/=(float s);

};

// 2é …æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
// â€»ã„ã‚ã‚“ãªå¼•æ•°(å¼•æ•°ã®å‹ã¨é †åº)ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æº–å‚™ã—ã¦ã‚‹
const Vector2 operator+(const Vector2& v1, const Vector2& v2);
const Vector2 operator-(const Vector2& v1, const Vector2& v2);
const Vector2 operator*(const Vector2& v, float s);
const Vector2 operator*(float s, const Vector2& v);
const Vector2 operator/(const Vector2& v, float s);


</file_content>

<file_content path="engine/math/Vector3.cpp">
// ===================
// Vector3 å‹
// ===================
#include "Vector3.h"

Vector3::Vector3()
	:x(0), y(0), z(0)
{
}
Vector3::Vector3(float x, float y, float z)
	: x(x), y(y), z(z)
{
}
float Vector3::length() const
{
	return std::sqrt(x * x + y * y + z * z);
}
Vector3& Vector3::normalize()
{
	float len = length();
	if (len != 0)
	{
		return*this /= len;
	}
	return*this;
}
float Vector3::dot(const Vector3& v, const Vector3& v2)
{
	return v.x * v2.x + v.y * v2.y + v.z * v2.z;
}
Vector3 Vector3::cross(const Vector3& v)const
{
	Vector3 temp;
	temp.x = this->y * v.z - this->z * v.y;
	temp.y = this->z * v.x - this->x * v.z;
	temp.z = this->x * v.y - this->y * v.x;
	return temp;
}

const Vector3 Vector3::lerp(const Vector3& start, const Vector3& end, const float t)
{
	return start * (1.0f - t) + end * t;
}

Vector3 Vector3::operator+()const
{
	return *this;
}
Vector3 Vector3::operator-()const
{
	return Vector3(-x, -y, -z);
}
Vector3& Vector3::operator+=(const Vector3& v)
{
	x += v.x;
	y += v.y;
	z += v.z;
	return *this;
}
Vector3& Vector3::operator-=(const Vector3& v)
{
	x -= v.x;
	y -= v.y;
	z -= v.z;
	return *this;
}
Vector3& Vector3::operator*=(const Vector3& v)
{
	x *= v.x;
	y *= v.y;
	z *= v.z;
	return *this;
}
Vector3& Vector3::operator*=(float s)
{
	x *= s;
	y *= s;
	z *= s;
	return *this;
}
Vector3& Vector3::operator/=(float s)
{
	x /= s;
	y /= s;
	z /= s;
	return *this;
}
// Vector3 ã‚¯ãƒ©ã‚¹ã«å±ã•ãªã„é–¢æ•°ç¾¤
// äºŒé …æ¼”ç®—å­
const Vector3 operator+ (const Vector3& v1, const Vector3& v2)
{
	Vector3 temp(v1);
	return temp += v2;
}
const Vector3 operator-(const Vector3& v1, const Vector3& v2)
{
	Vector3 temp(v1);
	return temp -= v2;
}
const Vector3 operator*(const Vector3& v, float s)
{
	Vector3 temp(v);
	return temp *= s;
}
const Vector3 operator*(float s, const Vector3& v)
{
	return v * s;
}
const Vector3 operator/(const Vector3& v, float s)
{
	Vector3 temp(v);
	return temp /= s;
}


</file_content>

<file_content path="engine/math/Vector3.h">
#pragma once
#include <cmath>

class Vector3 {
public:
	float x;//xæˆåˆ†
	float y;//yæˆåˆ†
	float z;//zæˆåˆ†

public:
	//ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ãƒˆ
	Vector3();                            //ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«ã¨ã—ã¦ç”Ÿæˆ
	Vector3(float x, float y, float z);   //xæˆåˆ†,yæˆåˆ†ã‚’æŒ‡å®šã—ã¦ã®ç”Ÿæˆ

	//ã€€ãƒ¡ãƒ³ãƒé–¢æ•°
	float length() const;                 //ãƒãƒ«ãƒ (é•·ã•)ã‚’æ±‚ã‚ã‚‹
	Vector3& normalize();                 //æ­£è¦åŒ–ã™ã‚‹
	static float dot(const Vector3& v, const Vector3& v2);   //å†…ç©ã‚’æ±‚ã‚ã‚‹
	Vector3 cross(const Vector3& v)const; //å¤–ç©ã‚’æ±‚ã‚ã‚‹

	// ç·šå½¢è£œé–“(1æ¬¡é–¢æ•°è£œé–“)
	static const Vector3 lerp(const Vector3& start, const Vector3& end, const float t);

	//ç”²é …æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Vector3 operator+() const;
	Vector3 operator-() const;

	//ä»£å…¥æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Vector3& operator+=(const Vector3& v);
	Vector3& operator-=(const Vector3& v);
	Vector3& operator*=(const Vector3& v);
	Vector3& operator*=(float s);
	Vector3& operator/=(float s);
};
//2é …æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
//â€»ã„ã‚ã‚“ãªå¼•æ•°(å¼•æ•°ã®å‹ã¨é †åº)ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æº–å‚™ã—ã¦ã„ã‚‹
const Vector3  operator+(const Vector3& v1, const Vector3& v2);
const Vector3  operator-(const Vector3& v1, const Vector3& v2);
const Vector3  operator*(const Vector3& v, float s);
const Vector3  operator*(float s, const Vector3& v);
const Vector3  operator/(const Vector3& v, float s);



</file_content>

<file_content path="engine/math/Vector4.cpp">
#include "Vector4.h"

#include<cmath>  //sprt

Vector4::Vector4() :x(0), y(0), z(0), w(0)
{
}

Vector4::Vector4(float x, float y, float z, float w) {
	this->x = x;
	this->y = y;
	this->z = z;
	this->w = w;
}

float Vector4::length()const {
	return std::sqrt(x * x + y * y + z * z + w * w);
}

Vector4& Vector4::normalize() {
	float len = length();
	if (len != 0) {
		return *this /= len;
	}
	return *this;
}

float Vector4::dot(const Vector4& v) const
{
	return x * v.x + y * v.y + z * v.z + w * v.w;
}

Vector4 Vector4::cross(const Vector4& v) const
{
	return Vector4(
		y * v.z - z * v.y,
		z * v.x - x * v.z,
		x * v.y - y * v.x,
		v.w
	);
}

Vector4 Vector4::operator+() const
{
	return Vector4(x, y, z, w);
}

Vector4 Vector4::operator-() const
{
	return Vector4(x, y, z, w);
}

Vector4& Vector4::operator+=(const Vector4& v)
{
	this->x += v.x;
	this->y += v.y;
	this->z += v.z;
	this->w += v.w;
	return *this;
}

Vector4& Vector4::operator-=(const Vector4& v)
{
	this->x -= v.x;
	this->y -= v.y;
	this->z -= v.z;
	this->w -= v.w;
	return *this;
}

Vector4& Vector4::operator*=(float s)
{
	this->x *= s;
	this->y *= s;
	this->z *= s;
	this->w *= s;
	return *this;
}

Vector4& Vector4::operator/=(float s)
{
	x /= s;
	y /= s;
	z /= s;
	w /= s;
	return *this;
}

//Vector4 ã‚¯ãƒ©ã‚¹ã«å±ã•ãªã„é–¢æ•°ç¾¤


const Vector4 operator+(const Vector4& v1, const Vector4& v2)
{
	Vector4 temp(0,0,0,0);
	temp.x = v1.x + v2.x;
	temp.y = v1.y + v2.y;
	temp.z = v1.z + v2.z;
	temp.w = v1.w + v2.w;
	return temp;
}

const Vector4 operator-(const Vector4& v1, const Vector4& v2)
{
	Vector4 temp(0, 0, 0, 0);
	temp.x = v1.x - v2.x;
	temp.y = v1.y - v2.y;
	temp.z = v1.z - v2.z;
	temp.w = v1.w - v2.w;
	return temp;
}

const Vector4 operator*(const Vector4& v, float s)
{
	Vector4 temp(0,0,0,0);
	temp.x = v.x * s;
	temp.y = v.y * s;
	temp.z = v.z * s;
	temp.w = v.w * s;
	return temp;
}

const Vector4 operator/(const Vector4& v, float s)
{
	Vector4 temp(0, 0, 0, 0);
	temp.x = v.x / s;
	temp.y = v.y / s;
	temp.z = v.z / s;
	temp.w = v.w / s;
	return temp;
}
</file_content>

<file_content path="engine/math/Vector4.h">
#pragma once

class Vector4
{
public:
	float x;
	float y;
	float z;
	float w;
public:
	//ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Vector4();								//é›¶ãƒ™ã‚¯ãƒˆãƒ«ã¨ã™ã‚‹
	Vector4(float x, float y, float z, float w);		//xæˆåˆ†,yæˆåˆ†,zæˆåˆ† ã‚’æŒ‡å®šã—ã¦ç”Ÿæˆ

	//ãƒ¡ãƒ³ãƒé–¢æ•°
	float length() const;					//ãƒãƒ«ãƒ (é•·ã•)ã‚’æ±‚ã‚ã‚‹
	Vector4& normalize();					//æ­£è¦åŒ–ã™ã‚‹
	float dot(const Vector4& v) const;		//å†…ç©ã‚’æ±‚ã‚ã‚‹
	Vector4 cross(const Vector4& v) const;	//å¤–ç©ã‚’æ±‚ã‚ã‚‹


	//å˜é …æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Vector4 operator+() const;
	Vector4 operator-() const;

	//ä»£å…¥æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
	Vector4& operator+=(const Vector4& v);
	Vector4& operator-=(const Vector4& v);
	Vector4& operator*=(float s);
	Vector4& operator/=(float s);

};


//ã€€2é …æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
//ã€€ã„ã‚ã„ã‚ãªå¼•æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾å¿œ(å¼•æ•°ã®åºåˆ—)ã™ã‚‹ãŸã‚ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æº–å‚™ã—ã¦ã„ã‚‹
const Vector4 operator+(const Vector4& v1, const Vector4& v2);
const Vector4 operator-(const Vector4& v1, const Vector4& v2);
const Vector4 operator*(const Vector4& v, float s);
const Vector4 operator*(float s, const Vector4& v);
const Vector4 operator/(const Vector4& v, float s);
</file_content>

<file_content path="engine/scene/AbstractSceneFactory.h">
#pragma once

#include "GameBaseScene.h"
#include <string>

class AbstractSceneFactory
{
public:
	virtual ~AbstractSceneFactory() = default;

	virtual GameBaseScene* CreateScene(const std::string& sceneName) = 0;
};
</file_content>

<file_content path="engine/scene/Game.cpp">
#include "Game.h"

#include "SceneFactory.h"

void Game::Initialize()
{	
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–å‡¦ç†
	SIFrameWork::Initialize();

	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªã‚’ç”Ÿæˆã—ã€ãƒãƒãƒ¼ã‚¸ãƒ£ã«ã‚»ãƒƒãƒˆ
	sceneFactory_ = new SceneFactory();
	sceneManager_->SetSceneFactory(sceneFactory_);
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã«æœ€åˆã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆ
	sceneManager_->ChangeScene("TITLE");
}

void Game::Finalize()
{
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®çµ‚äº†å‡¦ç†
	SIFrameWork::Finalize();
}

void Game::Update()
{
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®æ›´æ–°å‡¦ç†
	SIFrameWork::Update();
}

void Game::Draw()
{
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å–å¾—
	ID3D12GraphicsCommandList* cmdList = dxCommon->GetCommandList();

	//=== ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã®æç”» ===//
	sceneManager_->Draw();
}

</file_content>

<file_content path="engine/scene/Game.h">
#pragma once

#include "SIFrameWork.h"

// ã‚²ãƒ¼ãƒ å…¨ä½“
class Game : public SIFrameWork
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize() override;

	// çµ‚äº†
	void Finalize() override;

	// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
	void Update() override;

	// æç”»
	void Draw() override;
};

</file_content>

<file_content path="engine/scene/GameBaseScene.cpp">
#include "GameBaseScene.h"


void GameBaseScene::LoadObjFromLevelEditor(const std::string& fileName) {
	JsonLoader* file = nullptr;
	LevelData* levelData = file->LoadFile(fileName);

	//ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…ç½®
	for (auto& objectData : levelData->objects) {
		//ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ç™»éŒ²æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
		Model* model = nullptr;
		decltype(models)::iterator it = models.find(objectData.fileName);
		if (it != models.end()) { model = it->second; }
		//ãƒ¢ãƒ‡ãƒ«ã‚’æŒ‡å®šã—ã¦3DObjectã‚’ç”Ÿæˆ
		Object3d* newObject = Object3d::Create();
		newObject->Initialize();
		newObject->SetModel(model);
		//åº§æ¨™
		Vector3 pos;
		pos = Vector3(objectData.translation.x, objectData.translation.y, objectData.translation.z);
		newObject->SetPosition(pos);
		//å›è»¢è§’
		Vector3 rot;
		rot = Vector3(objectData.rotation.x, objectData.rotation.y, objectData.rotation.z);
		newObject->SetRotation(rot);
		//ã‚¹ã‚±ãƒ¼ãƒ«
		Vector3 scale;
		scale = Vector3(objectData.scaling.x, objectData.scaling.y, objectData.scaling.z);
		newObject->SetScale(scale);
		//é…åˆ—ã«ç™»éŒ²
		objects.push_back(newObject);
	}
}

</file_content>

<file_content path="engine/scene/GameBaseScene.h">
#pragma once

#include "Sprite.h"
#include "JsonLoader.h"	
#include "Model.h"
#include "Object3d.h"

#include <cassert>
#include <fstream>
#include <sstream>
#include <map>
#include <list>

// å‰æ–¹å®£è¨€
class GameSceneManager;

// ã‚·ãƒ¼ãƒ³åŸºåº•ã‚¯ãƒ©ã‚¹
class GameBaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	GameBaseScene() = default;
	virtual ~GameBaseScene() = default;

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	virtual void Initialize() = 0;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	virtual void Update() = 0;

	/// <summary>
	/// æç”»
	/// </summary>
	virtual void Draw() = 0;

	/// <summary>
	/// è§£æ”¾
	/// </summary>
	virtual void Finalize() = 0;

	void LoadObjFromLevelEditor(const std::string& fileName);

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	virtual void SetSceneManager(GameSceneManager* gSceneManager) { gSceneManager_ = gSceneManager; }

protected: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ï¼ˆå€Ÿã‚Šã¦ãã‚‹ï¼‰
	GameSceneManager* gSceneManager_ = nullptr;
	//leveleditor
	std::map<std::string, Model*> models;
	std::vector<Object3d*> objects;
};


</file_content>

<file_content path="engine/scene/GameClearScene.cpp">
#include "GameClearScene.h"

using namespace DirectX;

GameClearScene::GameClearScene()
{
}

GameClearScene::~GameClearScene()
{
}

void GameClearScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon = DirectXCommon::GetInstance();


	//ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–
	viewProjection = new ViewProjection();
	viewProjection->Initialize();

	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon->GetDevice());

	//gameclearã®ç”»åƒ
	clearGH.LoadTexture(spriteCommon_, 0, L"Resources/clear.png", dxCommon->GetDevice());
	clearGH.SpriteCreate(dxCommon->GetDevice(), 1280, 720, 0, Vector2(0.0f, 0.0f), false, false);
	clearGH.SetScale(Vector2(1280 * 1, 720 * 1));
	clearGH.SpriteTransferVertexBuffer(clearGH, 0);
	clearGH.SpriteUpdate(clearGH, spriteCommon_);
	
	showTime = 0;
	isNext = false;
	curHit01 = false;
	curHit02 = false;
}

void GameClearScene::Update()
{
	viewProjection->UpdateMatrix();
	clearGH.SpriteUpdate(clearGH, spriteCommon_);
	if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
		GameSceneManager::GetInstance()->ChangeScene("TITLE");
	}
}

void GameClearScene::Draw()
{
	// æç”»å‰å‡¦ç†
	dxCommon->PreDraw();

	Object3d::PreDraw(dxCommon->GetCommandList());


	Object3d::PostDraw();

	Sprite::PreDraw(dxCommon->GetCommandList(),spriteCommon_);

	clearGH.SpriteDraw(dxCommon->GetCommandList(), spriteCommon_, dxCommon->GetDevice());

	Sprite::PostDraw();

	
	// æç”»å¾Œå‡¦ç†
	dxCommon->PostDraw();
}

void GameClearScene::Finalize()
{
}

</file_content>

<file_content path="engine/scene/GameClearScene.h">
#pragma once

#include "Input.h"
#include "DirectXCommon.h"
#include "GameBaseScene.h"
#include "Sprite.h"
#include "GameSceneManager.h"
#include "GameTitleScene.h"
#include "Object3d.h"

#include <DirectXMath.h>

class GameClearScene : public GameBaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	GameClearScene();
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~GameClearScene();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// è§£æ”¾
	/// </summary>
	void Finalize() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	Input* input_ = nullptr;
	DirectXCommon* dxCommon = nullptr;
	Sprite* cross = nullptr;
	//ã‚«ãƒ¡ãƒ©
	ViewProjection* viewProjection = nullptr;
	//score
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite clearGH;
	int scores[6];
	float numPosX;
	int showTime;
	//title
	Sprite* title01 = nullptr;
	Sprite* title02 = nullptr;
	//retry
	Sprite* retry01 = nullptr;
	Sprite* retry02 = nullptr;
	bool isNext;
	bool curHit01;
	bool curHit02;
};

</file_content>

<file_content path="engine/scene/GameOverScene.cpp">
#include "GameOverScene.h"

GameOverScene::GameOverScene()
{
}

GameOverScene::~GameOverScene()
{
}

void GameOverScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon = DirectXCommon::GetInstance();


	//ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–
	viewProjection = new ViewProjection();
	viewProjection->Initialize();

	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon->GetDevice());
}

void GameOverScene::Update()
{
	viewProjection->UpdateMatrix();
	if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
		GameSceneManager::GetInstance()->ChangeScene("TITLE");
	}
}

void GameOverScene::Draw()
{
	// æç”»å‰å‡¦ç†
	dxCommon->PreDraw();

	Object3d::PreDraw(dxCommon->GetCommandList());


	Object3d::PostDraw();


	// æç”»å¾Œå‡¦ç†
	dxCommon->PostDraw();
}

void GameOverScene::Finalize()
{
}

</file_content>

<file_content path="engine/scene/GameOverScene.h">
#pragma once

#include "Input.h"
#include "DirectXCommon.h"
#include "GameBaseScene.h"
#include "Sprite.h"
#include "GameSceneManager.h"
#include "GameTitleScene.h"
#include "Object3d.h"

#include <DirectXMath.h>

class GameOverScene : public GameBaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	GameOverScene();
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~GameOverScene();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// è§£æ”¾
	/// </summary>
	void Finalize() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	Input* input_ = nullptr;
	DirectXCommon* dxCommon = nullptr;
	Sprite* cross = nullptr;
	//ã‚«ãƒ¡ãƒ©
	ViewProjection* viewProjection = nullptr;
	//score
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite clearGH;
	int scores[6];
	float numPosX;
	int showTime;
	//title
	Sprite* title01 = nullptr;
	Sprite* title02 = nullptr;
	//retry
	Sprite* retry01 = nullptr;
	Sprite* retry02 = nullptr;
	bool isNext;
	bool curHit01;
	bool curHit02;
};


</file_content>

<file_content path="engine/scene/GameScene.cpp">
#include "GameScene.h"
#include "FbxLoader.h"
#include "FbxObject3d.h"
#include "SphereCollider.h"
#include "CollisionManager.h"
#include "GameSceneManager.h"

#include <cassert>
#include <fstream>
#include <sstream>
#include <map>

std::list<std::unique_ptr<Energy>> GameScene::energys_;
int GameScene::popEnergyCount = 0;
GameScene::GameScene() {}

GameScene::~GameScene() {
	delete player;
}

///-----å¤‰æ•°ã®åˆæœŸåŒ–-----///
void GameScene::Initialize() {
	//åŸºç›¤
	dxCommon_ = DirectXCommon::GetInstance();
	winApp = WinApp::GetInstance();
	input = Input::GetInstance();
	//å½“ãŸã‚Šåˆ¤å®š
	collisionManager = CollisionManager::GetInstance();

	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 0.7f));

	//ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	skyModel = Model::LoadFromOBJ("sky");
	seaModel = Model::LoadFromOBJ("sea");
	block01Model = Model::LoadFromOBJ("block01");
	block02Model = Model::LoadFromOBJ("block02");
	stoneModel = Model::LoadFromOBJ("stone");
	models.insert(std::make_pair("sky", skyModel));
	models.insert(std::make_pair("sea", seaModel));
	models.insert(std::make_pair("block01", block01Model));
	models.insert(std::make_pair("block02", block02Model));
	models.insert(std::make_pair("stone", stoneModel));
	//ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿èª­ã¿è¾¼ã¿
	LoadObjFromLevelEditor("scene");

	railCamera = new RailCamera;
	railCamera->Initialize(player);

	xmViewProjection = new XMViewProjection;

	////FbxObjectã®é™çš„åˆæœŸåŒ–
	////ã‚«ãƒ¡ãƒ©ã‚’ã‚»ãƒƒãƒˆ
	//FbxObject3d::SetCamera(viewProjection);
	////ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’åˆæœŸåŒ–
	//FbxObject3d::CreateGraphicsPipeline();

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon_->GetDevice());

	//titleã®ç”»åƒ
	titleGH.LoadTexture(spriteCommon_, 0, L"Resources/title.png", dxCommon_->GetDevice());
	titleGH.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 0, Vector2(0.0f, 0.0f), false, false);
	titleGH.SetScale(Vector2(1280 * 1, 720 * 1));
	titleGH.SpriteTransferVertexBuffer(titleGH, 0);
	titleGH.SpriteUpdate(titleGH, spriteCommon_);

	//ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ã®ç”»åƒ
	for (int i = 0; i < 4; i++) {
		crosshair[i].LoadTexture(spriteCommon_, 1, L"Resources/crosshair.png", dxCommon_->GetDevice());
		crosshair[i].SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 1, Vector2(0.5f, 0.5f), false, false);
		crosshair[i].SetPosition(Vector3(1100, 0, 0));
		crosshair[i].SetScale(Vector2(24.0f * (i + 1.0f), 24.0f * (i + 1.0f)));
		crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
		crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
	}

	//HPç”¨ç”»åƒ
	hp.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 2, Vector2(0.0f, 0.0f), false, false);
	hp.SetPosition(Vector3(28, 650, 0));
	hp.SetScale(Vector2(4 * 1, 48 * 1));
	hp.LoadTexture(spriteCommon_, 2, L"Resources/life.png", dxCommon_->GetDevice());
	hp.SpriteTransferVertexBuffer(hp, 2);
	hp.SpriteUpdate(hp, spriteCommon_);

	//gameclearã®ç”»åƒ
	clearGH.LoadTexture(spriteCommon_, 3, L"Resources/clear.png", dxCommon_->GetDevice());
	clearGH.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 3, Vector2(0.0f, 0.0f), false, false);
	clearGH.SetScale(Vector2(1280 * 1, 720 * 1));
	clearGH.SpriteTransferVertexBuffer(clearGH, 3);
	clearGH.SpriteUpdate(clearGH, spriteCommon_);

	//gameoverã®ç”»åƒ
	overGH.LoadTexture(spriteCommon_, 4, L"Resources/over.png", dxCommon_->GetDevice());
	overGH.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 4, Vector2(0.0f, 0.0f), false, false);
	overGH.SetScale(Vector2(1280 * 1, 720 * 1));
	overGH.SpriteTransferVertexBuffer(overGH, 4);
	overGH.SpriteUpdate(overGH, spriteCommon_);

	for (int i = 0; i < 10; i++) {
		lock[i].LoadTexture(spriteCommon_, 1, L"Resources/crosshair.png", dxCommon_->GetDevice());
		lock[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 1, Vector2(0.0f, 0.0f), false, false);
		lock[i].SetScale(Vector2(128 * 1, 128 * 1));
		lock[i].SpriteTransferVertexBuffer(lock[i], 1);
		lock[i].SpriteUpdate(lock[i], spriteCommon_);
	}

	//fade
	fade.LoadTexture(spriteCommon_, 5, L"Resources/black.png", dxCommon_->GetDevice());
	fade.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 5, Vector2(0.0f, 0.0f), false, false);
	fade.SetScale(Vector2(1280 * 1, 720 * 1));
	fade.SpriteTransferVertexBuffer(fade, 5);
	fade.SpriteUpdate(fade, spriteCommon_);
	//alpha
	fadeAlpha = 1.0f;
	fade.SetAlpha(fade, fadeAlpha);
	//boosHP
	bossHP.LoadTexture(spriteCommon_, 6, L"Resources/hp.png", dxCommon_->GetDevice());
	bossHP.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 6, Vector2(0.0f, 0.5f), false, false);
	bossHP.SetPosition(Vector3(25, 50, 0));
	bossHP.SetScale(Vector2(2 * 1, 48 * 1));
	bossHP.SpriteTransferVertexBuffer(bossHP, 6);
	bossHP.SpriteUpdate(bossHP, spriteCommon_);
	//gage
	gage.LoadTexture(spriteCommon_, 7, L"Resources/green.png", dxCommon_->GetDevice());
	gage.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 7, Vector2(0.0f, 0.5f), false, false);
	gage.SetPosition(Vector3(28, 641, 0));
	gage.SetScale(Vector2(2 * 1, 18 * 1));
	gage.SpriteTransferVertexBuffer(gage, 7);
	gage.SpriteUpdate(gage, spriteCommon_);
	//
	gageBack.LoadTexture(spriteCommon_, 8, L"Resources/green.png", dxCommon_->GetDevice());
	gageBack.SpriteCreate(dxCommon_->GetDevice(), 1280, 720, 8, Vector2(0.0f, 0.5f), false, false);
	gageBack.SetPosition(Vector3(28, 641, 0));
	gageBack.SetScale(Vector2(2 * 178, 18 * 1));
	gageBack.SetAlpha(gageBack, 0.5f);
	gageBack.SpriteTransferVertexBuffer(gageBack, 8);
	gageBack.SpriteUpdate(gageBack, spriteCommon_);
	//
	hpBack.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 9, Vector2(0.0f, 0.0f), false, false);
	hpBack.SetPosition(Vector3(28, 650, 0));
	hpBack.SetScale(Vector2(396, 48 * 1));
	hpBack.LoadTexture(spriteCommon_, 9, L"Resources/life.png", dxCommon_->GetDevice());
	hpBack.SetAlpha(hpBack, 0.5f);
	hpBack.SpriteTransferVertexBuffer(hpBack, 9);
	hpBack.SpriteUpdate(hpBack, spriteCommon_);
	//ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	fadeout.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 10, Vector2(1.0f, 0.0f), false, false);
	fadeout.SetScale(Vector2(1280 * 1, 1120 * 1));
	fadeout.SetPosition({ 0,100,0 });
	fadeout.SetRotation(45);
	fadeout.SpriteTransferVertexBuffer(fadeout, 10);
	fadeout.SpriteUpdate(fadeout, spriteCommon_);
	fadeout.LoadTexture(spriteCommon_, 10, L"Resources/fade.png", dxCommon_->GetDevice());

	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åˆæœŸåŒ–
	particle = Particle::LoadParticleTexture("blue.png");
	pm_ = ParticleManager::Create();
	particle_ = Particle::LoadParticleTexture("crosshair.png");
	pm = ParticleManager::Create();
	//ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¢ãƒ‡ãƒ«ã‚’ç´ä»˜ã‘ã‚‹
	pm->SetParticleModel(particle);
	pm_->SetParticleModel(particle_);
	//ã‚«ãƒ¡ãƒ©ã‚’ã‚»ãƒƒãƒˆ
	pm->SetXMViewProjection(xmViewProjection);
	pm_->SetXMViewProjection(xmViewProjection);

	////ãƒ¢ãƒ‡ãƒ«åã‚’æŒ‡å®šã—ã¦èª­ã¿è¾¼ã¿
	//obj = new FbxObject3d;
	//obj->Initialize();
	//model = FbxLoader::GetInstance()->LoadModelFlomFile("cube");
	//obj->SetModel(model);
	//obj->SetPosition(Vector3(1, 0, -10));
	//obj->SetScale(Vector3((float)0.01, (float)0.01, (float)0.01));

	//boss
	boss = new Boss;
	boss->BossInitialize();
	boss->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 10.0f));


	//ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³åˆ¶å¾¡ç‚¹ã®èª­ã¿è¾¼ã¿
	stageNum = 1;
	LoadStage(stageNum);
	LoadEnemy(stageNum);
	//å¤‰æ•°
	isCheckPoint = false;
	isPlayable = false;
	gameState = MAIN;
	infos.clear();
	gameTime = 150;
	cursorRotate = 0.001f;
	bossPass = 0;
	cameraTmpPos = { 0,0,0 };
	cameraTmpRot = { 0,0,0 };
	isStart = false;
}

///-----æ›´æ–°å‡¦ç†-----///
void GameScene::Update() {
	//ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ã‚’æ›´æ–°
	GetCrosshair();
	//ãƒªã‚»ãƒƒãƒˆ
	if (Input::GetInstance()->TriggerKey(DIK_R)) {
		Reset();
		gameState = MAIN;
		gameTime = 150;
		railCamera->GetView()->SetEye(Vector3(-1, 0.5f, 490.0f));
		railCamera->GetView()->SetTarget(Vector3(0.0f, 0.5f, 495));
		player->SetPosition({ 0,0.5f,495 });
		Vector3 cursor = GetWorldToScreenPos(Vector3(0, 0, 0), railCamera);
		input->SetMousePos({ cursor.x,cursor.y });
	}
	if (isStart == false) {
		fadeAlpha = 0.0f;
		fade.SetAlpha(fade, fadeAlpha);
		gameTime = 150;
		railCamera->GetView()->SetEye(Vector3(-1, 0.5f, 490.0f));
		railCamera->GetView()->SetTarget(Vector3(0.0f, 0.5f, 495));
		player->SetPosition({ 0,0.5f,495 });
		Vector3 cursor = GetWorldToScreenPos(Vector3(-230, 85, 0), railCamera);
		input->SetMousePos({ cursor.x,cursor.y });
		for (auto& object : objects) {
			object->Update();
		}
		isStart = true;
	}
	//ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	//if (fadeout.GetPosition().y < 400) {
	//	fadeout.SetPosition(fadeout.GetPosition() + Vector3(0, 40, 0));
	//	fadeout.SpriteUpdate(fadeout, spriteCommon_);
	//}

	Vector3 shotVec = { 0,0,0 };


  //æ“ä½œå¯èƒ½çŠ¶æ…‹ãªã‚‰HPã‚’æ›´æ–°
	if (isPlayable == true) {
		//playerhp
		float playerHp_ = player->GetHP() - (hp.GetScale().x / 4);
		if (playerHp_ > 0) {
			if ((playerHp_) > 4) {
				hp.SetScale(hp.GetScale() + Vector2(16.0f, 0.0f));
			}
			else if ((playerHp_) > 2) {
				hp.SetScale(hp.GetScale() + Vector2(8.0f, 0.0f));
			}
			else if ((playerHp_) > 1) {
				hp.SetScale(hp.GetScale() + Vector2(4.0f, 0.0f));
			}
		}
		else if (playerHp_ < 0) {
			if ((playerHp_) < 4) {
				hp.SetScale(hp.GetScale() - Vector2(8.0f, 0.0f));
			}
			else if ((playerHp_) < 2) {
				hp.SetScale(hp.GetScale() - Vector2(4.0f, 0.0f));
			}
			else if ((playerHp_) < 1) {
				hp.SetScale(hp.GetScale() - Vector2(2.0f, 0.0f));
			}
		}

		hp.SpriteTransferVertexBuffer(hp, 2);
		hp.SpriteUpdate(hp, spriteCommon_);
		//gage
		float gage_ = player->GetEnergy() - (gage.GetScale().x / 4);
		if (gage_ > 0) {
			if (player->GetEnergy() < 100) {
				if ((gage_) > 4) {
					gage.SetScale(gage.GetScale() + Vector2(16.0f, 0.0f));
				}
				else if ((gage_) > 2) {
					gage.SetScale(gage.GetScale() + Vector2(8.0f, 0.0f));
				}
				else if ((gage_) > 1) {
					gage.SetScale(gage.GetScale() + Vector2(4.0f, 0.0f));
				}
			}
		}
		else if (gage_ < 0) {
			if ((gage_) < 4) {
				gage.SetScale(gage.GetScale() - Vector2(8.0f, 0.0f));
			}
			else if ((gage_) < 2) {
				gage.SetScale(gage.GetScale() - Vector2(4.0f, 0.0f));
			}
			else if ((gage_) < 1) {
				gage.SetScale(gage.GetScale() - Vector2(2.0f, 0.0f));
			}
		}

		gage.SpriteTransferVertexBuffer(gage, 7);
		gage.SpriteUpdate(gage, spriteCommon_);
	}

	//ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ä¸­
	switch (gameState)
	{
		//ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ 
	case GameScene::MAIN:
		//ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚æ¼”å‡º
		if (gameTime > 0) {
			//SPACEã§æ¼”å‡ºã‚¹ã‚­ãƒƒãƒ—
			if (Input::GetInstance()->TriggerKey(DIK_SPACE)) {
				gameTime = 1;
			}
			railCamera->GetView()->SetEye(railCamera->GetView()->GetEye() + Vector3(0, 0.0f, 0.05f));
			gameTime--;
			if (gameTime <= 0) {
				player->SetPosition(Vector3(0, -1.0f, -5.5f));
				player->SetAlpha(0.0f);
			}
			player->worldTransform_.UpdateMatrix();
		}
		//ã‚²ãƒ¼ãƒ ä¸­
		if (gameTime == 0) {
			//æ“ä½œä¸å¯çŠ¶æ…‹ã‚’è§£é™¤
			if (isPlayable == false) {
				isPlayable = true;
			}
			//bossæˆ¦ã¸
			if (railCamera->GetOnRail() == false) {
				if (isCheckPoint == false) {
					isCheckPoint = true;
					boss->Pop();
					gameState = BOSS;
					delete railCamera;
					railCamera = new RailCamera;
					railCamera->Initialize(player);
				}
			}
			/////ãƒ‡ãƒãƒƒã‚¯ç”¨(ãƒœã‚¹ã¾ã§ã‚¹ã‚­ãƒƒãƒ—)/////
			if (input->TriggerKey(DIK_B)) {
				railCamera->SetOnRail(false);
			}

			//playeræ›´æ–°(ã‚«ãƒ¡ãƒ©ã®å‰)
			if (input->PushMouseLeft()) {
				shotVec = GetScreenToWorldPos(crosshair[0], railCamera);
			}
			if (isPlayable == true) {
				SerchEnemy();
				player->Update(shotVec, infos);
				if (gameState == BOSS && railCamera->GetOnRail() == true) {
					player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				}
				LockedClear();
			}
			//æ›´æ–°
			railCamera->Update(player, points);
			//ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ãã‚‰ã£ãŸã¨ãã«ç”»é¢ã‚·ã‚§ã‚¤ã‚¯
			if (player->GetIsHit() == true) {
				railCamera->ShakeCamera(-0.2f, 0.2f);
			}
		}
		break;
		//ãƒœã‚¹æˆ¦
	case GameScene::BOSS:
		if (boss->GetTimer() > 0) {
			player->SetIsHit(false);
			//playerã‚’æ“ä½œä¸å¯ã«
			if (isPlayable == true) {
				isPlayable = false;
				railCamera->GetView()->SetEye(Vector3(-40, 55, -150));
			}
			//SPACEã§æ¼”å‡ºã‚¹ã‚­ãƒƒãƒ—
			if (input->TriggerKey(DIK_SPACE)) {
				boss->SkipMovie();
			}
			//æ¼”å‡º
			railCamera->GetView()->SetTarget(boss->GetPosition());
			if (boss->GetTimer() == 150) {
				railCamera->GetView()->SetEye(Vector3(-80, 55, -300));
			}
			else if (boss->GetTimer() < 150) {
				railCamera->GetView()->SetEye(railCamera->GetView()->GetEye() + Vector3(0.5f, 0.0f, 0.05f));
			}
		}
		else {
			//æ“ä½œå¯èƒ½çŠ¶æ…‹ã«
			if (isPlayable == false) {
				railCamera->GetView()->SetEye(Vector3(0, 60, -95));
				railCamera->GetView()->SetTarget(Vector3(0, 52, -200));
				railCamera->GetCamera()->SetPosition(Vector3(0, 59, -100));
				railCamera->GetCamera()->SetRotation(Vector3(0, 180, 0));
				player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				fadeAlpha = 1.0f;
				fade.SetAlpha(fade, fadeAlpha);
				isPlayable = true;
			}
			//BossHP
			float bossHp_ = boss->GetHP() - (bossHP.GetScale().x / 4);
			if (bossHp_ > 0) {
				if ((bossHp_) > 4) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(16.0f, 0.0f));
				}
				else if ((bossHp_) > 2) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(8.0f, 0.0f));
				}
				else if ((bossHp_) > 1) {
					bossHP.SetScale(bossHP.GetScale() + Vector2(4.0f, 0.0f));
				}
			}
			else if (bossHp_ < 0) {
				if ((bossHp_) < 4) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(8.0f, 0.0f));
				}
				else if ((bossHp_) < 2) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(4.0f, 0.0f));
				}
				else if ((bossHp_) < 1) {
					bossHP.SetScale(bossHP.GetScale() - Vector2(2.0f, 0.0f));
				}
			}
			bossHP.SpriteTransferVertexBuffer(bossHP, 6);
			bossHP.SpriteUpdate(bossHP, spriteCommon_);
			//playeræ›´æ–°(ã‚«ãƒ¡ãƒ©ã®å‰)
			if (input->PushMouseLeft()) {
				shotVec = GetScreenToWorldPos(crosshair[0], railCamera);
			}
			if (isPlayable == true) {
				SerchEnemy();
				player->Update(shotVec, infos);
				if (gameState == BOSS && railCamera->GetOnRail() == true) {
					player->SetPosition(Vector3(0.0f, 0.0f, 0.0f));
				}
				LockedClear();
			}

			//ã‚«ãƒ¡ãƒ©æ›´æ–°
			if (railCamera->GetOnRail() == false) {
				gameTime++;
				if (gameTime == 300) {
					railCamera->SetOnRail(true);
					gameTime = 0;
				}
			}
			railCamera->Update(player, bossPoint);
			railCamera->GetView()->SetTarget(boss->GetPosition());
			railCamera->GetCamera()->SetRotation(railCamera->GetView()->GetTarget());
			//ã‚«ãƒ¡ãƒ©åˆ¶å¾¡
			if (bossPass == 0) {
				if (railCamera->GetPasPoint() + 1.0f > 3.0f) {
					railCamera->SetOnRail(false);
					bossPass = 1;
				}
			}
			else if (bossPass == 1) {
				if (railCamera->GetPasPoint() + 1.0f > 5.0f) {
					railCamera->SetOnRail(false);
					bossPass = 2;
				}
			}
			else if (bossPass == 2) {
				if (railCamera->GetPasPoint() + 1.0f > 7.0f) {
					railCamera->SetOnRail(false);
					bossPass = 3;
				}
			}
			else if (bossPass == 3) {
				if (railCamera->GetPasPoint() + 1.0f >= 8.96f) {
					railCamera->SetOnRail(false);
					railCamera->RailReset();
					bossPass = 0;
				}
			}
		}
		//fadein
		if (fadeAlpha > 0.0f) {
			fadeAlpha -= 0.005f;
			fade.SetAlpha(fade, fadeAlpha);
		}
		//gameclear
		if (boss->GetIsDead() == true) {
			LockedClear();
			GameSceneManager::GetInstance()->ChangeScene("CLEAR");
		}
		//æ›´æ–°
		boss->Update(player->GetWorldPos());
		//ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ãã‚‰ã£ãŸã¨ãã«ç”»é¢ã‚·ã‚§ã‚¤ã‚¯
		if (player->GetIsHit() == true) {
			railCamera->ShakeCamera(-2.0f, 2.0f);
		}
		break;
	case GameScene::ULT:
		if (isPlayable == true) {
			isPlayable = false;
		}
		player->Ultimate();
		railCamera->SetTarget(player->GetWorldPos());
		if (player->GetIsUltimate() == false) {
			player->BackRail();
			railCamera->SetEye(cameraTmpPos);
			railCamera->SetTarget(cameraTmpRot);
			gameState = gameState_bak;
		}
		break;
	}
	//////////////æ“ä½œå¯èƒ½ãªã‚‰æ›´æ–°///////////////////
	if (player->GetIsUltimate() == true && gameState != ULT) {
		cameraTmpPos = railCamera->GetView()->GetEye();
		cameraTmpRot = railCamera->GetView()->GetTarget();
		railCamera->SetEye(player->GetWorldPos() + Vector3(-2, 0, -3));
		railCamera->SetTarget(player->GetWorldPos());
		gameState_bak = gameState;
		gameState = ULT;
	}
	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°ã®ç«‹ã£ãŸæ•µã‚’å‰Šé™¤
	enemys_.remove_if([](std::unique_ptr < Enemy>& enemy_) {
		return enemy_->GetIsDead();
		});
	//æ•µã‚­ãƒ£ãƒ©ã®æ›´æ–°
	for (const std::unique_ptr<Enemy>& enemy : enemys_) {
		enemy->Update(player->GetWorldPos(), railCamera->GetPasPoint());
	}
	//å¿…æ®ºæŠ€ã‚¨ãƒãƒ«ã‚®ãƒ¼
	for (const std::unique_ptr<Energy>& energy : energys_) {
		energy->Update(player->GetWorldPos(), railCamera->GetCamera()->GetRotation());
	}
	//ãƒ‡ã‚¹ãƒ•ãƒ©ã‚°ã®ç«‹ã£ãŸæ•µã‚’å‰Šé™¤
	energys_.remove_if([](std::unique_ptr <Energy>& energys_) {
		return energys_->GetIsDead();
		});
	//gameover
	if (player->GetHP() == 0) {
		LockedClear();
		GameSceneManager::GetInstance()->ChangeScene("OVER");
	}
	//å½“ãŸã‚Šåˆ¤å®šãƒã‚§ãƒƒã‚¯
	collisionManager->CheckAllCollisions();
}

void GameScene::Draw() {
#pragma region 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»

	dxCommon_->PreDraw();

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»å‰å‡¦ç†
	Object3d::PreDraw(dxCommon_->GetCommandList());

	//èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	for (auto& object : objects) {
		object->Draw(railCamera->GetView());
	}
	//æ•µã‚­ãƒ£ãƒ©ã®æç”»
	for (const std::unique_ptr<Enemy>& enemy : enemys_) {
		enemy->EnemyDraw(railCamera->GetView());
	}
	for (const std::unique_ptr<Energy>& energy : energys_) {
		energy->Draw(railCamera->GetView());
	}
	//ãƒœã‚¹
	if (gameState == BOSS) {
		boss->BossDraw(railCamera->GetView());
	}
	//ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	player->PlayerDraw(railCamera->GetView());

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»å¾Œå‡¦ç†
	Object3d::PostDraw();

#pragma endregion

#pragma region FBX3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»

	//// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»å‰å‡¦ç†
	//FbxObject3d::PreDraw(dxCommon_->GetCommandList());

	//// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»å¾Œå‡¦ç†
	//FbxObject3d::PostDraw();

#pragma endregion

#pragma region ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»å‰å‡¦ç†
	ParticleManager::PreDraw(dxCommon_->GetCommandList());

	///==== ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”» ====///
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	/*pm->Draw();
	pm_->Draw();*/

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»å¾Œå‡¦ç†
	ParticleManager::PostDraw();

#pragma endregion

#pragma region ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»å‰å‡¦ç†
	Sprite::PreDraw(dxCommon_->GetCommandList(), spriteCommon_);

	///=== ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”» ===///

	if (gameState == BOSS) {
		fade.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		if (boss->GetTimer() == 0) {
			//ãƒœã‚¹ã®HP
			bossHP.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
	}
	if (isPlayable == true) {
		hpBack.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		gageBack.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		hp.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		gage.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}
	if (isPlayable == true) {
		for (int i = 0; i < 4; i++) {
			crosshair[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
	}
	for (int i = 0; i < infos.size(); i++) {
		lock[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}
	fadeout.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»å¾Œå‡¦ç†
	Sprite::PostDraw();

	dxCommon_->PostDraw();
}

void GameScene::LoadStage(int stageNum) {
	points.clear();
	bossPoint.clear();

	//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file;
	file.open("Resources/csv/stagePop.csv");
	assert(file.is_open());

	HRESULT result = S_FALSE;

	std::string num;
	num = stageNum + 48;

	// ï¼‘è¡Œãšã¤èª­ã¿è¾¼ã‚€
	string line;
	while (getline(file, line)) {

		// ï¼‘è¡Œåˆ†ã®æ–‡å­—åˆ—ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¤‰æ›ã—ã¦è§£æã—ã‚„ã™ãã™ã‚‹
		std::istringstream line_stream(line);

		// åŠè§’ã‚¹ãƒ‘ãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§è¡Œã®å…ˆé ­æ–‡å­—åˆ—ã‚’å–å¾—
		string key;
		getline(line_stream, key, ' ');


		// å…ˆé ­æ–‡å­—åˆ—ãŒstãªã‚‰ã‚¹ãƒ†ãƒ¼ã‚¸
		if (key == "st" + num) {
			// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
			points.emplace_back(position);
		}
		if (stageNum == 10) {
			if (key == "st10") {
				// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
				points.emplace_back(position);
			}
		}
		else if (stageNum > 10) {
			if (key == "st1" + stageNum - 10) {
				// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
				points.emplace_back(position);
			}
		}
		//å…ˆé ­æ–‡å­—ãŒboãªã‚‰ãƒœã‚¹
		if (key == "bo" + num) {
			// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
			Vector3 position{};
			line_stream >> position.x;
			line_stream >> position.y;
			line_stream >> position.z;
			// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
			bossPoint.emplace_back(position);
		}
		if (stageNum == 10) {
			if (key == "st10") {
				// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
				bossPoint.emplace_back(position);
			}
		}
		else if (stageNum > 10) {
			if (key == "st1" + stageNum - 10) {
				// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
				Vector3 position{};
				line_stream >> position.x;
				line_stream >> position.y;
				line_stream >> position.z;
				// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
				bossPoint.emplace_back(position);
			}
		}
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«ã¨é–‰ã˜ã‚‹
	file.close();
}

void GameScene::Reset() {
	delete player;
	delete railCamera;
	delete enemy;
	delete boss;

	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 0.7f));
	player->SetPosition({ 0,0.5f,495 });
	hp.SetScale(Vector2(0, 48 * 1));
	//boss
	boss = new Boss;
	boss->BossInitialize();
	boss->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 10.0f));
	bossHP.SetScale(Vector2(12 * 1, 48 * 1));
	//camera
	railCamera = new RailCamera;
	railCamera->Initialize(player);
	//enemy
	LoadEnemy(stageNum);
	//å¤‰æ•°
	isCheckPoint = false;
	isPlayable = false;
	cursorRotate = 0.001f;
	LockedClear();
	infos.clear();
	gameState = MAIN;
	gameTime = 150;
	bossPass = 0;
	fadeAlpha = 1.0f;
	fade.SetAlpha(fade, fadeAlpha);
	popEnergyCount = 0;
}

void GameScene::Finalize()
{
}

void GameScene::LoadEnemy(int stageNum) {

	Spline spline;
	spline.Initialize();

	pointsL = points;
	pointsR = points;

	for (int i = 0; i < points.size(); i++)
	{
		pointsL[i] += Vector3(-2, 0, 0);
		pointsR[i] += Vector3(2, 0, 0);
	}

	enemys_.clear();

	//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file;
	file.open("Resources/csv/EnemyPop.csv");
	assert(file.is_open());

	HRESULT result = S_FALSE;

	std::string num;
	num = stageNum + 48;

	// ï¼‘è¡Œãšã¤èª­ã¿è¾¼ã‚€
	string line;
	while (getline(file, line)) {

		// ï¼‘è¡Œåˆ†ã®æ–‡å­—åˆ—ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¤‰æ›ã—ã¦è§£æã—ã‚„ã™ãã™ã‚‹
		std::istringstream line_stream(line);

		// åŠè§’ã‚¹ãƒ‘ãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§è¡Œã®å…ˆé ­æ–‡å­—åˆ—ã‚’å–å¾—
		string key;
		getline(line_stream, key, ' ');

		string word;
		getline(line_stream, word, ' ');

		if (stageNum < 10) {
			// å…ˆé ­æ–‡å­—åˆ—ãŒï½–ãªã‚‰é ‚ç‚¹åº§æ¨™
			if (key == "ea" + num) {
				//æ•µã®ç”Ÿæˆ
				std::unique_ptr<Enemy> newEnemy = std::make_unique<Enemy>();
				//æ•µã®åˆæœŸåŒ–
				newEnemy->EnemyInitialize();
				////ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¿½åŠ 
				newEnemy->SetCollider(new SphereCollider());
				// X,Y,Zåº§æ¨™èª­ã¿è¾¼ã¿
				Vector3 position{};
				float t;

				if (word.find("L") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(pointsL, t);
				}
				else if (word.find("M") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(points, t);
				}
				else if (word.find("R") == 0)
				{
					line_stream >> t;
					newEnemy->SetStagePoint(t);
					position = spline.EnemyPosition(pointsR, t);
				}

				// åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
				newEnemy->SetPosition(position);
				newEnemy->SetScale({ 0.6f,0.6f,0.6f });
				//ç™»éŒ²
				enemys_.push_back(std::move(newEnemy));
			}
		}
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«ã¨é–‰ã˜ã‚‹
	file.close();
}

void GameScene::SerchEnemy()
{
	Vector3 cur = input->GetMousePos();

	if (input->PushKey(DIK_LSHIFT)) {
		for (int i = 0; i < boss->GetPartsNum(); i++) {
			Vector3 epos1 = GetWorldToScreenPos(boss->GetParts(i)->GetWorldPos(), railCamera);
			if (boss->GetIsInvisible() == false) {
				if (pow((epos1.x - cur.x), 2) + pow((epos1.y - cur.y), 2) < pow(50, 2)) {
					if (boss->GetParts(i)->GetIsLocked() == false && infos.size() < 10) {
						LockInfo info;
						info.vec = boss->GetParts(i)->GetWorldPos();
						info.obj = boss->GetParts(i);
						infos.push_back(info);
						boss->GetParts(i)->SetIsLocked(true);
					}
				}
			}
		}

		for (const std::unique_ptr<Enemy>& enemy : enemys_) {
			Vector3 epos2 = GetWorldToScreenPos(enemy->GetWorldPos(), railCamera);
			Vector3 len = enemy->GetWorldPos() - player->GetWorldPos();
			float len_ = len.length();
			if (pow((epos2.x - cur.x), 2) + pow((epos2.y - cur.y), 2) < pow(30, 2)) {
				if (enemy->GetIsLocked() == false && infos.size() < 10) {
					LockInfo info;
					info.vec = enemy->GetWorldPos();
					info.obj = enemy->GetPointer();
					infos.push_back(info);
					enemy->SetIsLocked(true);
				}
			}
		}
		if (cursorRotate < 0.005f) {
			cursorRotate += 0.0001f;
		}
	}
	else {
		if (cursorRotate > 0.001f) {
			cursorRotate -= 0.0001f;
		}
	}
	//ãƒ­ãƒƒã‚¯ã‚ªãƒ³ç”»åƒã®æ›´æ–°
	for (int i = 0; i < infos.size(); i++) {
		lock[i].SetScale(GetWorldToScreenScale(infos[i].obj, railCamera));
		lock[i].SetPosition(GetWorldToScreenPos(infos[i].obj->GetWorldPos(), railCamera) - (Vector3(lock[i].GetScale().x, lock[i].GetScale().y, 0) / 2));
		lock[i].SpriteUpdate(lock[i], spriteCommon_);
		lock[i].SpriteTransferVertexBuffer(lock[i], 1);
	}
}

void GameScene::LockedClear()
{
	if (player->GetIsShooted() == true) {
		if (boss->GetIsLocked() == true) {
			boss->SetIsLocked(false);
		}

		for (const std::unique_ptr<Enemy>& enemy : enemys_) {
			if (enemy->GetIsLocked() == true) {
				enemy->SetIsLocked(false);
			}
		}
		infos.clear();
	}
}

void GameScene::GetCrosshair()
{
	Vector3 mPos = input->GetMousePos();
	//ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®å ´æ‰€ã«ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ã‚’è¡¨ç¤º
	if (gameState == MAIN) {
		for (int i = 0; i < 4; i++) {
			if (i == 0) {
				crosshair[i].SetPosition(mPos);
			}
			else if (i == 1) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.1f);
			}
			else if (i == 2) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.25f);
			}
			else if (i == 3) {
				crosshair[i].SetPosition(mPos - (mPos - GetWorldToScreenPos(player->GetWorldPos(), railCamera)) * 0.55f);
			}
			if (i % 2 == 0) {
				crosshair[i].SetRotation(crosshair[i].GetRotation() + cursorRotate);
			}
			else {
				crosshair[i].SetRotation(crosshair[i].GetRotation() - cursorRotate);
			}
			if (crosshair[i].GetRotation() == 1.0f) {
				crosshair[i].SetRotation(0.0f);
			}
			crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
			crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
		}
	}
	else {
		for (int i = 0; i < 4; i++) {
			crosshair[i].SetPosition(mPos);
			if (i % 2 == 0) {
				crosshair[i].SetRotation(crosshair[i].GetRotation() + cursorRotate);
			}
			else {
				crosshair[i].SetRotation(crosshair[i].GetRotation() - cursorRotate);
			}
			if (crosshair[i].GetRotation() == 1.0f) {
				crosshair[i].SetRotation(0.0f);
			}
			crosshair[i].SpriteTransferVertexBuffer(crosshair[i], 1);
			crosshair[i].SpriteUpdate(crosshair[i], spriteCommon_);
		}
	}
}

void GameScene::PopEnergy(Vector3 pos_)
{
	//ä¹±æ•°ç”Ÿæˆè£…ç½®
	std::random_device seed_gen;
	std::mt19937_64 engine(seed_gen());
	std::uniform_real_distribution<float>dist(-1.5f, 1.5f);
	std::uniform_real_distribution<float>dist2(-2.5f, 2.5f);
	std::uniform_real_distribution<float>dist3(-1.5f, 1.5f);
	//å¼¾ã‚’ç”Ÿæˆã—åˆæœŸåŒ–
	std::unique_ptr<Energy> newEnergy = std::make_unique<Energy>();

	//å˜ç™º													   
	newEnergy->EnergyInitialize();
	newEnergy->SetCollider(new SphereCollider(Vector3{ 0,0,0 }, 2.0f));
	newEnergy->SetPosition(pos_ + Vector3(dist(engine), dist2(engine), dist3(engine)));
	energys_.push_back(std::move(newEnergy));
}

Vector3 GameScene::GetScreenToWorldPos(Sprite& sprite_, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector3(0, 0, 1);
	}

	//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¡Œåˆ—ç”Ÿæˆ
	Matrix4 viewPort = viewPort.ViewPortMat(WinApp::window_width, WinApp::window_height, Vector2(0.0f, 0.0f));

	//ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆåˆæˆè¡Œåˆ—
	Matrix4 invViewPort = viewPort;
	invViewPort.MakeInverse();
	//ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—//
	float fovAngleY = 45.0f * (3.141592f / 180.0f);;
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	//ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ç”Ÿæˆ
	Matrix4 projection = projection.ProjectionMat(fovAngleY, aspectRatio, 0.1f, 200.0f);
	Matrix4 invProjection = projection;
	invProjection.MakeInverse();
	//ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—//
	Matrix4 view = railCamera->GetView()->GetMatView();
	Matrix4 invView = view;
	invView.MakeInverse();
	////åˆæˆè¡Œåˆ—ã®é€†è¡Œåˆ—ã‚’è¨ˆç®—ã™ã‚‹
	Matrix4 matInverseVPV = invViewPort * invProjection * invView;
	//ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ç³»ã‹ã‚‰ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»
	Matrix4 mat1, mat2;
	//wé™¤ç®—
	Vector3 posNear = Vector3(sprite_.GetPosition().x, sprite_.GetPosition().y, 0);
	Vector3 posFar = Vector3(sprite_.GetPosition().x, sprite_.GetPosition().y, 1);
	posNear = mat1.transform(posNear, matInverseVPV);
	posFar = mat2.transform(posFar, matInverseVPV);

	//ãƒã‚¦ã‚¹ãƒ¬ã‚¤ã®æ–¹å‘
	Vector3 mouseDirection = posFar - posNear;
	mouseDirection = mouseDirection.normalize();
	//ã‚«ãƒ¡ãƒ©ã‹ã‚‰ç…§æº–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è·é›¢
	const float kDistanceTestObject = 0.05f;

	Vector3 pos = player->GetWorldPos();
	Vector3 translate = (posFar - pos) * kDistanceTestObject;

	return translate;
}

Vector3 GameScene::GetWorldToScreenPos(Vector3 pos_, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector3(0, 0, 0);
	}

	//ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—//
	Matrix4 view = railCamera->GetView()->GetMatView();
	//ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—//
	float fovAngleY = 45.0f * (3.141592f / 180.0f);;
	float aspectRatio = (float)WinApp::window_width / WinApp::window_height;
	//ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ç”Ÿæˆ
	Matrix4 projection = projection.ProjectionMat(fovAngleY, aspectRatio, 0.1f, 200.0f);
	//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¡Œåˆ—ç”Ÿæˆ
	Matrix4 viewPort = viewPort.ViewPortMat(WinApp::window_width, WinApp::window_height, Vector2(0.0f, 0.0f));

	Matrix4 matVPV = view * projection * viewPort;

	Matrix4 mat;
	Vector3 posScreen = pos_;
	posScreen = mat.transform(posScreen, matVPV);
	posScreen.z = 0;

	return posScreen;
}

Vector2 GameScene::GetWorldToScreenScale(Object3d* obj, RailCamera* rail)
{
	if (rail == nullptr) {
		return Vector2(0, 0);
	}

	Vector3 v = obj->GetPosition() - rail->GetView()->GetEye();
	v.normalize();
	float len = v.length();

	float x = 64;
	x *= obj->GetScale().x;
	float y = 64;
	y *= obj->GetScale().y;


	return Vector2(x / len, y / len);
}

//void GameScene::LoadObjFromLevelEditor(const std::string& fileName) {
//	JsonLoader* file = nullptr;
//	LevelData* levelData = file->LoadFile(fileName);
//
//	//ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…ç½®
//	for (auto& objectData : levelData->objects) {
//		//ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ç™»éŒ²æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
//		Model* model = nullptr;
//		decltype(models)::iterator it = models.find(objectData.fileName);
//		if (it != models.end()) { model = it->second; }
//		//ãƒ¢ãƒ‡ãƒ«ã‚’æŒ‡å®šã—ã¦3DObjectã‚’ç”Ÿæˆ
//		Object3d* newObject = Object3d::Create();
//		newObject->Initialize();
//		newObject->SetModel(model);
//		//åº§æ¨™
//		Vector3 pos;
//		pos = Vector3(objectData.translation.x, objectData.translation.y, objectData.translation.z);
//		newObject->SetPosition(pos);
//		//å›è»¢è§’
//		Vector3 rot;
//		rot = Vector3(objectData.rotation.x, objectData.rotation.y, objectData.rotation.z);
//		newObject->SetRotation(rot);
//		//ã‚¹ã‚±ãƒ¼ãƒ«
//		Vector3 scale;
//		scale = Vector3(objectData.scaling.x, objectData.scaling.y, objectData.scaling.z);
//		newObject->SetScale(scale);
//		//é…åˆ—ã«ç™»éŒ²
//		objects.push_back(newObject);
//	}
//}
</file_content>

<file_content path="engine/scene/GameScene.h">
#pragma once
#include "Sprite.h"
#include "Object3d.h"
#include"WinApp.h"
#include"DirectXCommon.h"
#include "Object3d.h"
#include "Input.h"
#include "time.h"
#include <random>
#include "Model.h"
#include "ViewProjection.h"
#include "Particle.h"
#include "ParticleManager.h"
#include "FbxObject3d.h"
#include "FbxModel.h"
#include "Player.h"
#include "RailCamera.h"
#include "Enemy.h"
#include "CollisionManager.h"
#include "Boss.h"
#include "JsonLoader.h"	
#include "energy.h"
#include "GameBaseScene.h"


class GameScene : public GameBaseScene {
public:
	//ãƒ¡ãƒ³ãƒé–¢æ•°
	GameScene();

	~GameScene();

	void Initialize() override;
	/*void LoadObjFromLevelEditor(const std::string& fileName);*/

	void Update();

	void Draw();
	void Reset();
	void Finalize()override;

	void LoadStage(int stageNum);
	void LoadEnemy(int stageNum);
	void SerchEnemy();
	void LockedClear();
	void GetCrosshair();
	static void PopEnergy(Vector3 pos_);

	Vector3 GetScreenToWorldPos(Sprite& sprite_, RailCamera* rail);
	Vector3 GetWorldToScreenPos(Vector3 pos_, RailCamera* rail);
	Vector2 GetWorldToScreenScale(Object3d* obj, RailCamera* rail);

private:
	//base
	DirectXCommon* dxCommon_ = nullptr;
	WinApp* winApp = nullptr;
	//å…¥åŠ›ã®ãƒã‚¤ãƒ³ã‚¿
	Input* input = nullptr;
	//ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ãƒã‚¤ãƒ³ã‚¿
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite titleGH;
	Sprite crosshair[4];
	Sprite hp;
	Sprite clearGH;
	Sprite overGH;
	Sprite lock[10];
	Sprite fade;
	float fadeAlpha;
	Sprite bossHP;
	Sprite gage;
	Sprite gageBack;
	Sprite hpBack;
	Sprite fadeout;
	//ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒã‚¤ãƒ³ã‚¿
	//3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
	Player* player = nullptr;
	Enemy* enemy = nullptr;
	Model* skyModel = nullptr;
	Model* seaModel = nullptr;
	Model* block01Model = nullptr;
	Model* block02Model = nullptr;
	Model* stoneModel = nullptr;
	Boss* boss = nullptr;
	//ã‚«ãƒ¡ãƒ©
	ViewProjection* viewProjection = nullptr;
	XMViewProjection* xmViewProjection = nullptr;
	RailCamera* railCamera = nullptr;
	Vector3 cameraTmpPos;
	Vector3 cameraTmpRot;
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	Particle* particle = nullptr;
	ParticleManager* pm = nullptr;
	Particle* particle_ = nullptr;
	ParticleManager* pm_ = nullptr;
	//enemy
	std::list<std::unique_ptr<Enemy>> enemys_;
	//energy
	static std::list<std::unique_ptr<Energy>> energys_;
	static int popEnergyCount;
	//å½“ãŸã‚Šåˆ¤å®š
	CollisionManager* collisionManager = nullptr;
	//FBX
	FbxModel* model = nullptr;
	FbxObject3d* obj = nullptr;
	//ã‚«ãƒ¡ãƒ©ç§»å‹•ç”¨ãƒ¬ãƒ¼ãƒ«
	std::vector<Vector3> points{};
	std::vector<Vector3> pointsL;
	std::vector<Vector3> pointsR;
	std::vector<Vector3> bossPoint{};
	//ã‚¹ãƒ†ãƒ¼ã‚¸
	int stageNum = 0;
	bool isCheckPoint = false;
	bool isPlayable = false;
	//ãƒ­ãƒƒã‚¯ã‚ªãƒ³æƒ…å ±
	std::vector<LockInfo> infos;
	int gameTime;
	float cursorRotate;
	//ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	enum GameState {
		MAIN,
		BOSS,
		ULT
	};
	GameState gameState;
	GameState gameState_bak;
	int bossPass;
	bool isStart;
};
</file_content>

<file_content path="engine/scene/GameSceneManager.cpp">
#include "GameSceneManager.h"

GameSceneManager::~GameSceneManager()
{
	// æœ€å¾Œã®ã‚·ãƒ¼ãƒ³ã®çµ‚äº†ã¨è§£æ”¾
	if (scene_ != nullptr) {
		scene_->Finalize();
		delete scene_;
		scene_ = nullptr;
	}
}

GameSceneManager* GameSceneManager::GetInstance() 
{
	static GameSceneManager instance;

	return &instance;
}

void GameSceneManager::Update()
{
	// äºˆç´„ã‚·ãƒ¼ãƒ³ã®äºˆç´„ãŒã‚ã‚‹ãªã‚‰
	if (nextScene_) {
		// æ—§ã‚·ãƒ¼ãƒ³ã®çµ‚äº†
		if (scene_) {
			scene_->Finalize();

			delete scene_;
		}

		// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
		scene_ = nextScene_;
		nextScene_ = nullptr;

		// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ã‚»ãƒƒãƒˆ
		scene_->SetSceneManager(this);

		// æ¬¡ã‚·ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–ã™ã‚‹
		scene_->Initialize();
	}

	// å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ã‚’æ›´æ–°ã™ã‚‹
	scene_->Update();
}

void GameSceneManager::Draw()
{
	// ã‚·ãƒ¼ãƒ³ã®æç”»
	scene_->Draw();
}

void GameSceneManager::Destroy()
{
	if (scene_ != nullptr) {
		scene_->Finalize();
		delete scene_;
		scene_ = nullptr;
	}
}

void GameSceneManager::ChangeScene(const std::string& sceneName)
{
	assert(sceneFactory_);
	assert(nextScene_ == nullptr);

	// æ¬¡ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	nextScene_ = sceneFactory_->CreateScene(sceneName);
}

</file_content>

<file_content path="engine/scene/GameSceneManager.h">
#pragma once

#include "GameBaseScene.h"
#include "AbstractSceneFactory.h"

/// <summary>
/// ã‚·ãƒ¼ãƒ³ç®¡ç†
/// </summary>
class GameSceneManager final
{
private: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	GameSceneManager() = default;
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~GameSceneManager();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ã®è§£æ”¾
	/// </summary>
	void Destroy();

public:
	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆ
	static GameSceneManager* GetInstance();

private:
	// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç„¡åŠ¹ã«ã™ã‚‹
	GameSceneManager(const GameSceneManager&) = delete;
	// ä»£å…¥æ¼”ç®—å­ã‚’ç„¡åŠ¹ã«ã™ã‚‹
	GameSceneManager& operator=(const GameSceneManager&) = delete;

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// æ¬¡ã‚·ãƒ¼ãƒ³äºˆç´„
	/// </summary>
	/// <param name="sceneName">ãƒ•ã‚¡ã‚¤ãƒ«å</param>
	void ChangeScene(const std::string& sceneName);

	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®setter
	void SetSceneFactory(AbstractSceneFactory* sceneFactory) { sceneFactory_ = sceneFactory; }

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ä»Šã®ã‚·ãƒ¼ãƒ³(å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³)
	GameBaseScene* scene_ = nullptr;
	// æ¬¡ã‚·ãƒ¼ãƒ³
	GameBaseScene* nextScene_ = nullptr;
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ï¼ˆå€Ÿã‚Šã¦ãã‚‹ï¼‰
	AbstractSceneFactory* sceneFactory_ = nullptr;
};


</file_content>

<file_content path="engine/scene/GameTitleScene.cpp">
#include "GameTitleScene.h"

using namespace DirectX;

GameTitleScene::GameTitleScene()
{
	//// ã‚µã‚¦ãƒ³ãƒ‰ã®é™çš„åˆæœŸåŒ–
	//Sound::StaticInitialize();
}

GameTitleScene::~GameTitleScene()
{
}

void GameTitleScene::Initialize()
{
	input_ = Input::GetInstance();
	dxCommon_ = DirectXCommon::GetInstance();
	sprite = new Sprite();
	spriteCommon_ = sprite->SpriteCommonCreate(dxCommon_->GetDevice());

	//titleã®ç”»åƒ
	title.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 0, Vector2(0.0f, 0.0f), false, false);
	title.SetScale(Vector2(1280 * 1, 720 * 1));
	title.SetPosition({ -354,-32,0 });
	title.SpriteTransferVertexBuffer(title, 0);
	title.SpriteUpdate(title, spriteCommon_);
	title.LoadTexture(spriteCommon_, 0, L"Resources/title.png", dxCommon_->GetDevice());
	//titleèƒŒæ™¯
	for (int i = 0; i < 3; i++) {
		titleBack[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, i + 1, Vector2(0.0f, 0.0f), false, false);
		titleBack[i].SetScale(Vector2(1280 * 1.1, 720 * 1.7));
		titleBack[i].SetPosition({ -418,-192,0 });
		titleBack[i].SpriteTransferVertexBuffer(titleBack[i], i + 1);
		titleBack[i].SpriteUpdate(titleBack[i], spriteCommon_);
	}
	titleBack[0].LoadTexture(spriteCommon_, 1, L"Resources/titleBack.png", dxCommon_->GetDevice());
	titleBack[1].LoadTexture(spriteCommon_, 2, L"Resources/titleBack2.png", dxCommon_->GetDevice());
	titleBack[2].LoadTexture(spriteCommon_, 3, L"Resources/titleBack3.png", dxCommon_->GetDevice());
	//ã‚«ãƒ¼ã‚½ãƒ«
	for (int i = 0; i < 9; i++) {
		cursor[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 4, Vector2(0.5f, 0.5f), false, false);
		cursor[i].SetScale(Vector2(48 * 1, 48 * 1));
		cursor[i].SetPosition(Input::GetInstance()->GetMousePos());
		cursor[i].SetAlpha(cursor[i], 1 - (i * 0.1f));
		cursor[i].SpriteTransferVertexBuffer(cursor[i], 4);
		cursor[i].SpriteUpdate(cursor[i], spriteCommon_);
		cursor[i].LoadTexture(spriteCommon_, 4, L"Resources/cursor.png", dxCommon_->GetDevice());
	}
	//ã‚¯ãƒªãƒƒã‚¯
	for (int i = 0; i < 2; i++) {
		click[i].SpriteCreate(dxCommon_->GetDevice(), 50, 50, 5+i, Vector2(0.5f, 0.5f), false, false);
		click[i].SetScale(Vector2(312.0f * 1.2f, 52.0f * 1.2f));
		click[i].SetPosition({ 640,640,0 });
		click[i].SpriteTransferVertexBuffer(click[i], 5+i);
		click[i].SpriteUpdate(click[i], spriteCommon_);
	}
	click[0].LoadTexture(spriteCommon_, 5, L"Resources/click1.png", dxCommon_->GetDevice());
	click[1].LoadTexture(spriteCommon_, 6, L"Resources/click2.png", dxCommon_->GetDevice());
	//ã‚«ãƒ¼ã‚½ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	circle.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 7, Vector2(0.5f, 0.5f), false, false);
	circle.SetScale(Vector2(48 * circleSize, 48 * circleSize));
	circle.SetPosition({ 0,0,0 });
	circle.SpriteTransferVertexBuffer(circle, 7);
	circle.SpriteUpdate(circle, spriteCommon_);
	circle.LoadTexture(spriteCommon_, 7, L"Resources/circle.png", dxCommon_->GetDevice());
	//ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	fade.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 8, Vector2(0.0f, 0.0f), false, false);
	fade.SetScale(Vector2(1280 * 1, 1120 * 1));
	fade.SetPosition({ 0,-1120,0 });
	fade.SpriteTransferVertexBuffer(fade, 8);
	fade.SpriteUpdate(fade, spriteCommon_);
	fade.LoadTexture(spriteCommon_, 8, L"Resources/fade.png", dxCommon_->GetDevice());
	//loading
	loading.SpriteCreate(dxCommon_->GetDevice(), 50, 50, 9, Vector2(0.0f, 0.0f), false, false);
	loading.SetScale(Vector2(256 * 1, 48 * 1));
	loading.SetPosition({ 1000,600,0 });
	loading.SpriteTransferVertexBuffer(loading, 9);
	loading.LoadTexture(spriteCommon_, 9, L"Resources/loading.png", dxCommon_->GetDevice());


	//player
	player = new Player;
	player->PlayerInitialize();
	player->SetPosition({ 0.0f,33.3f,288.0f });
	player->SetRotation({ 0,90,0 });

	//ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–
	viewProjection = new ViewProjection();
	viewProjection->Initialize();
	viewProjection->SetEye({ 3.5f,34.5f,298.0f });
	viewProjection->SetTarget({0,40,-400});

	//ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	skyModel = Model::LoadFromOBJ("sky");
	seaModel = Model::LoadFromOBJ("sea");
	block01Model = Model::LoadFromOBJ("block01");
	block02Model = Model::LoadFromOBJ("block02");
	stoneModel = Model::LoadFromOBJ("stone");
	models.insert(std::make_pair("sky", skyModel));
	models.insert(std::make_pair("sea", seaModel));
	models.insert(std::make_pair("block01", block01Model));
	models.insert(std::make_pair("block02", block02Model));
	models.insert(std::make_pair("stone", stoneModel));
	//ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿èª­ã¿è¾¼ã¿
	LoadObjFromLevelEditor("title");
	gameTimer = 0;
	isBackNum = 0;
	onCursor = false;
	isNext = false;
	circleSize = 1.0f;
}

void GameTitleScene::Update()
{
	if (isNext == false) {
		Vector3 cur = Input::GetInstance()->GetMousePos();
		cursor[8].SetPosition(cursor[7].GetPosition());
		cursor[7].SetPosition(cursor[6].GetPosition());
		cursor[6].SetPosition(cursor[5].GetPosition());
		cursor[5].SetPosition(cursor[4].GetPosition());
		cursor[4].SetPosition(cursor[3].GetPosition());
		cursor[3].SetPosition(cursor[2].GetPosition());
		cursor[2].SetPosition(cursor[1].GetPosition());
		cursor[1].SetPosition(cursor[0].GetPosition());
		cursor[0].SetPosition(cur);
		circle.SetPosition(cur);
		if (Input::GetInstance()->TriggerMouseLeft() == true) {
			circleSize = 1.0f;
		}
		else if (circleSize < 6.0f) {
			circleSize += 0.1f;
		}
		else {
			circleSize = 1.0f;
		}
		circle.SetScale(Vector2(64 * circleSize, 64 * circleSize));
		circle.SpriteTransferVertexBuffer(circle, 7);
		circle.SpriteUpdate(circle, spriteCommon_);
		for (int i = 0; i < 9; i++) {
			cursor[i].SpriteUpdate(cursor[i], spriteCommon_);
		}
		//ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
		if (cur.x > click[0].GetPosition().x - 156 && cur.x < click[0].GetPosition().x + 156) {
			if (cur.y > click[0].GetPosition().y - 26 && cur.y < click[0].GetPosition().y + 26) {
				if (onCursor == false) {
					onCursor = true;
				}
				if (Input::GetInstance()->TriggerMouseLeft()) {
					isNext = true;
					gameTimer = 0;
				}
			}
			else {
				if (onCursor == true) {
					onCursor = false;
				}
			}
		}
		else {
			if (onCursor == true) {
				onCursor = false;
			}
		}
		//ã‚¿ã‚¤ãƒˆãƒ«æ¼”å‡º
		if (gameTimer % 8 == 0) {
			if (isBackNum < 2) {
				isBackNum++;
			}
			else if (isBackNum == 2) {
				isBackNum = 0;
			}
		}
		title.SpriteUpdate(title, spriteCommon_);
		for (int i = 0; i < 3; i++) {
			titleBack[i].SpriteUpdate(titleBack[i], spriteCommon_);
		}
		//ã‚¯ãƒªãƒƒã‚¯
		for (int i = 0; i < 2; i++) {
			click[i].SpriteUpdate(click[i], spriteCommon_);
		}

		//æ›´æ–°
		for (auto& object : objects) {
			object->Update();
		}
		if (gameTimer < 50) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.005f, 0));
		}
		else if (gameTimer < 100) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.005f, 0));
		}
		gameTimer++;
		if (gameTimer > 100) {
			gameTimer = 0;
		}
	}
	else {
		//ã‚·ãƒ¼ãƒ³é·ç§»
		if (gameTimer < 10) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.0075f, 0));
		}
		else if (gameTimer < 25) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.01f, 0));
		}
		else if (gameTimer < 75) {
			player->SetPosition(player->GetPosition() + Vector3(0, -0.0025f, 0));
		}
		else if(player->GetPosition().y < 60.0f) {
			player->SetPosition(player->GetPosition() + Vector3(0, 0.8f, 0));
			viewProjection->SetTarget(viewProjection->GetTarget() + Vector3(0,3.0f,0));
		}
		else if (fade.GetPosition().y < 0) {
			fade.SetPosition(fade.GetPosition() + Vector3(0, +40, 0));
			fade.SpriteUpdate(fade, spriteCommon_);
		}
		else {
			loading.SpriteUpdate(loading, spriteCommon_);
			//æ¬¡ã‚·ãƒ¼ãƒ³ã¸
			GameSceneManager::GetInstance()->ChangeScene("GAMEPLAY");
		}
		gameTimer++;
	}
	//æ›´æ–°
	player->worldTransform_.UpdateMatrix();
	viewProjection->UpdateMatrix();
}

void GameTitleScene::Draw()
{
	dxCommon_->PreDraw();

	Object3d::PreDraw(dxCommon_->GetCommandList());

	player->Draw(viewProjection);
	//èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	for (auto& object : objects) {
		object->Draw(viewProjection);
	}

	Object3d::PostDraw();

	Sprite::PreDraw(dxCommon_->GetCommandList(), spriteCommon_);
	if (isNext == false) {
		titleBack[isBackNum].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		title.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		if (onCursor == false) {
			click[0].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
		else {
			click[1].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
		circle.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		for (int i = 0; i < 9; i++) {
			cursor[i].SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		}
   }
	else {
		fade.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
		loading.SpriteDraw(dxCommon_->GetCommandList(), spriteCommon_, dxCommon_->GetDevice());
	}

	Sprite::PostDraw();

	dxCommon_->PostDraw();
}

void GameTitleScene::Finalize()
{

}
</file_content>

<file_content path="engine/scene/GameTitleScene.h">
#pragma once

#include "DirectXCommon.h"
#include "Input.h"
#include "Sprite.h"
#include "GameBaseScene.h"
#include "GameSceneManager.h"
#include "GameScene.h"
#include "viewProjection.h"
#include "Player.h"


#include <DirectXMath.h>

class GameTitleScene : public GameBaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	GameTitleScene();

	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~GameTitleScene();

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="dXCommon"></param>
	void Draw() override;

	/// <summary>
	/// è§£æ”¾
	/// </summary>
	void Finalize() override;

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// å…¥åŠ›
	Input* input_ = nullptr;
	DirectXCommon* dxCommon_ = nullptr;


	//ã‚«ãƒ¡ãƒ©
	ViewProjection* viewProjection = nullptr;

	//ã‚«ãƒ¼ã‚½ãƒ«
	Sprite* sprite = new Sprite;
	SpriteCommon spriteCommon_;
	Sprite title;
	Sprite titleBack[3];
	Sprite cursor[9];
	Sprite click[2];
	Sprite circle;
	Sprite fade;
	Sprite loading;

	Model* skyModel = nullptr;
	Model* seaModel = nullptr;
	Model* block01Model = nullptr;
	Model* block02Model = nullptr;
	Model* stoneModel = nullptr;
	Player* player = nullptr;

	int gameTimer;
	int isBackNum;
	bool onCursor;
	bool isNext;
	float circleSize;
};

</file_content>

<file_content path="engine/scene/SIFrameWork.cpp">
#include "SIFrameWork.h"

void SIFrameWork::Initialize()
{
	// WindowsAPIã®åˆæœŸåŒ–
	winApp = WinApp::GetInstance();
	winApp->Initialize();

	// DirectXã®åˆæœŸåŒ–
	dxCommon = DirectXCommon::GetInstance();
	dxCommon->Initialize(winApp);

	// å…¥åŠ›ã®åˆæœŸåŒ–
	input = Input::GetInstance();
	input->Initialize(winApp);
	//3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé™çš„åˆæœŸåŒ–
	Object3d::StaticInitialize(dxCommon->GetDevice(), WinApp::window_width, WinApp::window_height);
	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
	ViewProjection::StaticInitialize(dxCommon->GetDevice());
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã®ç”Ÿæˆ
	sceneManager_ = GameSceneManager::GetInstance();
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é™çš„åˆæœŸåŒ–
	ParticleManager::StaticInitialize(dxCommon->GetDevice());
	//fbxæ±ç”¨åˆæœŸåŒ–
	FbxLoader::GetInstance()->Initialize(dxCommon->GetDevice());
	//
	FbxObject3d::StaticInitialize(dxCommon->GetDevice());

	/*postEffect.Initialize(dxCommon->GetDevice());*/
	
}

void SIFrameWork::Finalize()
{
	sceneManager_->Destroy();
	//ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªã®è§£æ”¾
	delete sceneFactory_;

	// WindowsAPIã®çµ‚äº†å‡¦ç†
	winApp->Finalize();

	// DirectXè§£æ”¾
	dxCommon->fpsFixedFinalize();
}

void SIFrameWork::Update()
{
	// Windowsã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	if (winApp->ProcessMessage()) {
		// ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		endRequest = true;
	}

	// å…¥åŠ›ã®æ›´æ–°
	input->Update();

	if (Input::GetInstance()->TriggerKey(DIK_ESCAPE)) {
		endRequest = true;
	}

	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°
	sceneManager_->Update();
}

void SIFrameWork::Run()
{
	// ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
	Initialize();

	while (true) // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— 
	{
		// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
		Update();

		// çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæ¥ãŸã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		if (IsEndRequest()) {
			// ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			break;
		}

		// æç”»
		Draw();
	}

	// ã‚²ãƒ¼ãƒ ã®çµ‚äº†
	Finalize();
}

</file_content>

<file_content path="engine/scene/SIFrameWork.h">
#pragma once
#include"Input.h"
#include"WinApp.h"
#include"DirectXCommon.h"
#include "Sprite.h"
#include "Object3d.h"
#include "FbxObject3d.h"
#include"Model.h"
#include "ParticleManager.h"
#include "FbxLoader.h"
#include "AbstractSceneFactory.h"
#include "GameSceneManager.h"

class SIFrameWork
{
public://ãƒ¡ãƒ³ãƒé–¢æ•°
	//åˆæœŸåŒ–
	virtual void Initialize();
	//çµ‚äº†
	virtual void Finalize();
	//æ›´æ–°
	virtual void Update();
	//æç”»
	virtual void Draw() = 0;
	//çµ‚äº†ãƒã‚§ãƒƒã‚¯
	virtual bool IsEndRequest() { return endRequest; }

public:
	virtual ~SIFrameWork() = default;

public:
	//å®Ÿè¡Œ
	void Run();

protected:
	//WindowsAPIã®ãƒã‚¤ãƒ³ã‚¿
	WinApp* winApp = nullptr;
	//DirectXã®ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon = nullptr;
	//å…¥åŠ›ã®ãƒã‚¤ãƒ³ã‚¿
	Input* input = nullptr;
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£
	GameSceneManager* sceneManager_ = nullptr;
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	AbstractSceneFactory* sceneFactory_ = nullptr;
private:
	bool endRequest = false;
};


</file_content>

<file_content path="engine/scene/SceneFactory.cpp">
#include "SceneFactory.h"

GameBaseScene* SceneFactory::CreateScene(const std::string& sceneName)
{
    // æ¬¡ã®ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
    GameBaseScene* newScene = nullptr;

    if (sceneName == "TITLE") {
        newScene = new GameTitleScene();
    }
    else if (sceneName == "GAMEPLAY") {
        newScene = new GameScene();
    }
    else if (sceneName == "CLEAR") {
        newScene = new GameClearScene();
    }
    else if (sceneName == "OVER") {
        newScene = new GameOverScene();
    }

    return newScene;
}

</file_content>

<file_content path="engine/scene/SceneFactory.h">
#pragma once

#include "AbstractSceneFactory.h"
#include "GameTitleScene.h"
#include "GameScene.h"
#include "GameClearScene.h"
#include "GameOverScene.h"

/// <summary>
/// ã“ã®ã‚²ãƒ¼ãƒ ç”¨ã®ã‚·ãƒ¼ãƒ³å·¥å ´
/// </summary>
class SceneFactory : public AbstractSceneFactory
{
public:
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName">ã‚·ãƒ¼ãƒ³å</param>
	/// <returns></returns>
	GameBaseScene* CreateScene(const std::string& sceneName) override;
};


</file_content>

<file_content path="main.cpp">
#include "Game.h"


int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
	SIFrameWork* game = new Game();

	game->Run();

	delete game;

	return 0;
}
</file_content>

